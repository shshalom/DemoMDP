/**
 * MCP Protocol Handler - JSON-RPC 2.0 request/response handling
 */
/**
 * JSON-RPC Error Codes
 */
export const ErrorCode = {
    PARSE_ERROR: -32700,
    INVALID_REQUEST: -32600,
    METHOD_NOT_FOUND: -32601,
    INVALID_PARAMS: -32602,
    INTERNAL_ERROR: -32603,
};
/**
 * MCP Protocol Handler
 *
 * Handles JSON-RPC 2.0 requests and dispatches to tool handlers
 */
export class MCPProtocolHandler {
    tools = new Map();
    /**
     * Register a tool handler
     */
    registerTool(handler) {
        if (this.tools.has(handler.name)) {
            throw new Error(`Tool ${handler.name} is already registered`);
        }
        this.tools.set(handler.name, handler);
    }
    /**
     * Unregister a tool handler
     */
    unregisterTool(name) {
        return this.tools.delete(name);
    }
    /**
     * Get all registered tools
     */
    getTools() {
        return Array.from(this.tools.values()).map((handler) => ({
            name: handler.name,
            description: handler.description,
            inputSchema: handler.inputSchema,
        }));
    }
    /**
     * Handle a JSON-RPC 2.0 request
     */
    async handleRequest(request) {
        // Validate request
        if (request.jsonrpc !== '2.0') {
            return this.errorResponse(request.id, ErrorCode.INVALID_REQUEST, 'Invalid JSON-RPC version');
        }
        try {
            // Handle different methods
            switch (request.method) {
                case 'tools/list':
                    return this.handleToolsList(request);
                case 'tools/call':
                    return await this.handleToolsCall(request);
                case 'initialize':
                    return this.handleInitialize(request);
                default:
                    return this.errorResponse(request.id, ErrorCode.METHOD_NOT_FOUND, `Method not found: ${request.method}`);
            }
        }
        catch (error) {
            return this.errorResponse(request.id, ErrorCode.INTERNAL_ERROR, error instanceof Error ? error.message : 'Internal error');
        }
    }
    /**
     * Handle tools/list method
     */
    handleToolsList(request) {
        return {
            jsonrpc: '2.0',
            id: request.id,
            result: {
                tools: this.getTools(),
            },
        };
    }
    /**
     * Handle tools/call method
     */
    async handleToolsCall(request) {
        const params = request.params;
        if (!params || !params.name) {
            return this.errorResponse(request.id, ErrorCode.INVALID_PARAMS, 'Missing tool name');
        }
        const tool = this.tools.get(params.name);
        if (!tool) {
            return this.errorResponse(request.id, ErrorCode.METHOD_NOT_FOUND, `Tool not found: ${params.name}`);
        }
        const startTime = Date.now();
        try {
            const toolResponse = await tool.handle(params.arguments || {});
            const latency = Date.now() - startTime;
            // Update latency in response
            toolResponse.metadata = {
                ...toolResponse.metadata,
                latency_ms: latency,
            };
            // Convert to MCP content format
            const content = this.formatToolResponse(toolResponse);
            return {
                jsonrpc: '2.0',
                id: request.id,
                result: {
                    content,
                    isError: !toolResponse.success,
                },
            };
        }
        catch (error) {
            const latency = Date.now() - startTime;
            return {
                jsonrpc: '2.0',
                id: request.id,
                result: {
                    content: [
                        {
                            type: 'text',
                            text: `Tool execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
                        },
                    ],
                    isError: true,
                    metadata: {
                        latency_ms: latency,
                        cached: false,
                    },
                },
            };
        }
    }
    /**
     * Handle initialize method
     */
    handleInitialize(request) {
        return {
            jsonrpc: '2.0',
            id: request.id,
            result: {
                protocolVersion: '2024-11-05',
                serverInfo: {
                    name: '@mdp-framework/mcp-server',
                    version: '1.0.0',
                },
                capabilities: {
                    tools: {},
                },
            },
        };
    }
    /**
     * Format tool response as MCP content
     */
    formatToolResponse(response) {
        const content = [];
        if (response.success) {
            // Add success text
            content.push({
                type: 'text',
                text: `Tool executed successfully${response.data ? ': ' + JSON.stringify(response.data, null, 2) : ''}`,
            });
            // Add data as resource if present
            if (response.data) {
                content.push({
                    type: 'resource',
                    resource: {
                        uri: 'data:application/json',
                        mimeType: 'application/json',
                        text: JSON.stringify(response.data, null, 2),
                    },
                });
            }
        }
        else {
            // Add error text
            content.push({
                type: 'text',
                text: `Tool execution failed: ${response.error?.message || 'Unknown error'}`,
            });
        }
        return content;
    }
    /**
     * Create an error response
     */
    errorResponse(id, code, message) {
        return {
            jsonrpc: '2.0',
            id: id || null,
            error: {
                code,
                message,
            },
        };
    }
}
//# sourceMappingURL=handler.js.map