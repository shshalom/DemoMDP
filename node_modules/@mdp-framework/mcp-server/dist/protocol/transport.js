/**
 * MCP Transport Layer - stdio and HTTP transports
 */
import { createServer } from 'http';
/**
 * stdio Transport
 *
 * Reads JSON-RPC requests from stdin and writes responses to stdout
 */
export class StdioTransport {
    running = false;
    handleRequest;
    constructor(handleRequest) {
        this.handleRequest = handleRequest;
    }
    async start() {
        if (this.running) {
            throw new Error('Transport already running');
        }
        this.running = true;
        // Set up stdin to read line-by-line
        process.stdin.setEncoding('utf8');
        let buffer = '';
        process.stdin.on('data', async (chunk) => {
            buffer += chunk;
            // Process complete lines
            let newlineIndex;
            while ((newlineIndex = buffer.indexOf('\n')) !== -1) {
                const line = buffer.slice(0, newlineIndex).trim();
                buffer = buffer.slice(newlineIndex + 1);
                if (line) {
                    try {
                        const request = JSON.parse(line);
                        const response = await this.handleRequest(request);
                        this.sendResponse(response);
                    }
                    catch (error) {
                        // Send parse error
                        this.sendResponse({
                            jsonrpc: '2.0',
                            id: null,
                            error: {
                                code: -32700,
                                message: 'Parse error',
                            },
                        });
                    }
                }
            }
        });
        process.stdin.on('end', () => {
            this.running = false;
        });
    }
    async stop() {
        this.running = false;
        process.stdin.pause();
    }
    isRunning() {
        return this.running;
    }
    sendResponse(response) {
        process.stdout.write(JSON.stringify(response) + '\n');
    }
}
/**
 * HTTP Transport
 *
 * Handles JSON-RPC requests over HTTP POST
 */
export class HTTPTransport {
    server;
    running = false;
    handleRequest;
    port;
    constructor(port, handleRequest) {
        this.port = port;
        this.handleRequest = handleRequest;
    }
    async start() {
        if (this.running) {
            throw new Error('Transport already running');
        }
        return new Promise((resolve, reject) => {
            this.server = createServer(async (req, res) => {
                // CORS headers
                res.setHeader('Access-Control-Allow-Origin', '*');
                res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
                res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
                // Handle OPTIONS preflight
                if (req.method === 'OPTIONS') {
                    res.writeHead(204);
                    res.end();
                    return;
                }
                // Only accept POST
                if (req.method !== 'POST') {
                    res.writeHead(405, { 'Content-Type': 'application/json' });
                    res.end(JSON.stringify({ error: 'Method not allowed' }));
                    return;
                }
                // Read request body
                let body = '';
                req.on('data', (chunk) => {
                    body += chunk.toString();
                });
                req.on('end', async () => {
                    try {
                        const request = JSON.parse(body);
                        const response = await this.handleRequest(request);
                        res.writeHead(200, { 'Content-Type': 'application/json' });
                        res.end(JSON.stringify(response));
                    }
                    catch (error) {
                        // Parse error
                        const errorResponse = {
                            jsonrpc: '2.0',
                            id: null,
                            error: {
                                code: -32700,
                                message: 'Parse error',
                            },
                        };
                        res.writeHead(400, { 'Content-Type': 'application/json' });
                        res.end(JSON.stringify(errorResponse));
                    }
                });
            });
            this.server.listen(this.port, () => {
                this.running = true;
                resolve();
            });
            this.server.on('error', (error) => {
                reject(error);
            });
        });
    }
    async stop() {
        if (!this.server) {
            return;
        }
        return new Promise((resolve, reject) => {
            this.server.close((error) => {
                if (error) {
                    reject(error);
                }
                else {
                    this.running = false;
                    resolve();
                }
            });
        });
    }
    isRunning() {
        return this.running;
    }
    getPort() {
        return this.port;
    }
}
//# sourceMappingURL=transport.js.map