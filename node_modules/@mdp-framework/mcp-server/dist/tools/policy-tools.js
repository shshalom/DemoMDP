/**
 * Policy Tools - MCP tools for querying policies
 */
/**
 * Policy Get Tool
 *
 * Get a policy by ID and optional version
 */
export class PolicyGetTool {
    resolver;
    name = 'policy.get';
    description = 'Get a policy by ID and optional version. Returns the PolicyCard with all policy details.';
    inputSchema = {
        type: 'object',
        properties: {
            id: {
                type: 'string',
                description: 'Policy ID (e.g., ios.swift.no-force-unwrap)',
            },
            version: {
                type: 'string',
                description: 'Policy version (optional, defaults to latest from stable channel)',
            },
        },
        required: ['id'],
    };
    constructor(resolver) {
        this.resolver = resolver;
    }
    async handle(params) {
        const startTime = Date.now();
        try {
            // Resolve the policy
            const result = await this.resolver.resolve({
                roles: { policy: params.id },
                channel: 'stable', // Default to stable channel
                snapshotTime: new Date().toISOString(),
            });
            if (result.policies.length === 0) {
                return {
                    success: false,
                    error: {
                        code: 'NOT_FOUND',
                        message: `Policy not found: ${params.id}`,
                    },
                    metadata: {
                        latency_ms: Date.now() - startTime,
                        cached: false,
                    },
                };
            }
            const policy = result.policies[0];
            // If version was specified, check if it matches
            if (params.version && policy.version !== params.version) {
                return {
                    success: false,
                    error: {
                        code: 'VERSION_MISMATCH',
                        message: `Policy ${params.id} found but version ${policy.version} does not match requested ${params.version}`,
                    },
                    metadata: {
                        latency_ms: Date.now() - startTime,
                        cached: false,
                    },
                };
            }
            return {
                success: true,
                data: {
                    policy,
                    uri: result.policyIds[0],
                },
                metadata: {
                    latency_ms: Date.now() - startTime,
                    cached: false,
                },
            };
        }
        catch (error) {
            return {
                success: false,
                error: {
                    code: 'INTERNAL_ERROR',
                    message: error instanceof Error ? error.message : 'Unknown error',
                },
                metadata: {
                    latency_ms: Date.now() - startTime,
                    cached: false,
                },
            };
        }
    }
}
/**
 * Policy Search Tool
 *
 * Search policies by tags, owner, or scope
 */
export class PolicySearchTool {
    resolver;
    name = 'policy.search';
    description = 'Search policies by tags, owner, or scope. Returns a list of matching PolicyCards.';
    inputSchema = {
        type: 'object',
        properties: {
            tags: {
                type: 'array',
                items: { type: 'string' },
                description: 'Filter by tags (AND logic)',
            },
            owner: {
                type: 'string',
                description: 'Filter by owner/team',
            },
            scope: {
                type: 'string',
                enum: ['repo', 'org', 'team', 'global'],
                description: 'Filter by scope',
            },
            limit: {
                type: 'number',
                default: 10,
                description: 'Maximum number of results',
            },
        },
    };
    constructor(resolver) {
        this.resolver = resolver;
    }
    async handle(params) {
        const startTime = Date.now();
        try {
            // For now, we'll implement a basic search by resolving all policies
            // and filtering. In production, this should use a proper search index.
            // TODO: Implement proper search with policy registry indexing
            // For M2, we return a placeholder response indicating search is not yet fully implemented
            return {
                success: true,
                data: {
                    policies: [],
                    message: 'Policy search is not yet fully implemented. Use policy.get for specific policies.',
                    filters: params,
                },
                metadata: {
                    latency_ms: Date.now() - startTime,
                    cached: false,
                },
            };
        }
        catch (error) {
            return {
                success: false,
                error: {
                    code: 'INTERNAL_ERROR',
                    message: error instanceof Error ? error.message : 'Unknown error',
                },
                metadata: {
                    latency_ms: Date.now() - startTime,
                    cached: false,
                },
            };
        }
    }
}
//# sourceMappingURL=policy-tools.js.map