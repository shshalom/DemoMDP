/**
 * Memory Tools - MCP tools for querying state capsules
 */
/**
 * Memory Get Tool
 *
 * Get a state capsule by ID
 */
export class MemoryGetTool {
    store;
    name = 'memory.get';
    description = 'Get a state capsule by ID. Returns the full StateCapsule with all context, decisions, and evidence.';
    inputSchema = {
        type: 'object',
        properties: {
            id: {
                type: 'string',
                description: 'Capsule ID (URI format, e.g., capsule://mdp-framework/TEAM_A/pr/pr-123)',
            },
        },
        required: ['id'],
    };
    constructor(store) {
        this.store = store;
    }
    async handle(params) {
        const startTime = Date.now();
        try {
            const result = await this.store.get(params.id);
            if (!result.ok) {
                return {
                    success: false,
                    error: {
                        code: result.error.code,
                        message: result.error.message,
                    },
                    metadata: {
                        latency_ms: Date.now() - startTime,
                        cached: false,
                    },
                };
            }
            return {
                success: true,
                data: {
                    capsule: result.data,
                },
                metadata: {
                    latency_ms: Date.now() - startTime,
                    cached: false,
                },
            };
        }
        catch (error) {
            return {
                success: false,
                error: {
                    code: 'INTERNAL_ERROR',
                    message: error instanceof Error ? error.message : 'Unknown error',
                },
                metadata: {
                    latency_ms: Date.now() - startTime,
                    cached: false,
                },
            };
        }
    }
}
/**
 * Memory Search Tool
 *
 * Search capsules by query (semantic search)
 */
export class MemorySearchTool {
    store;
    name = 'memory.search';
    description = 'Search state capsules by natural language query. Supports filtering by kind (feature, issue, pr, investigation) and team.';
    inputSchema = {
        type: 'object',
        properties: {
            query: {
                type: 'string',
                description: 'Natural language query to search capsules',
            },
            filters: {
                type: 'object',
                properties: {
                    kind: {
                        type: 'string',
                        enum: ['feature', 'issue', 'pr', 'investigation', 'custom'],
                        description: 'Filter by capsule kind',
                    },
                    team: {
                        type: 'string',
                        description: 'Filter by team name',
                    },
                },
            },
            limit: {
                type: 'number',
                default: 10,
                description: 'Maximum number of results to return',
            },
        },
        required: ['query'],
    };
    constructor(store) {
        this.store = store;
    }
    async handle(params) {
        const startTime = Date.now();
        try {
            const limit = params.limit || 10;
            // List capsules with filters
            const listResult = await this.store.list({
                kind: params.filters?.kind,
                limit: limit * 2, // Get more to allow for filtering
            });
            if (!listResult.ok) {
                return {
                    success: false,
                    error: {
                        code: listResult.error.code,
                        message: listResult.error.message,
                    },
                    metadata: {
                        latency_ms: Date.now() - startTime,
                        cached: false,
                    },
                };
            }
            // Get capsule details
            const capsuleIds = listResult.data;
            const capsulesResult = await this.store.getMany(capsuleIds);
            if (!capsulesResult.ok) {
                return {
                    success: false,
                    error: {
                        code: capsulesResult.error.code,
                        message: capsulesResult.error.message,
                    },
                    metadata: {
                        latency_ms: Date.now() - startTime,
                        cached: false,
                    },
                };
            }
            // Convert map to array
            const capsules = Array.from(capsulesResult.data.values());
            // Apply semantic search (simple text matching for now)
            // TODO: Implement proper semantic search with embeddings
            const query = params.query.toLowerCase();
            const matchedCapsules = capsules.filter((capsule) => {
                // Search in context, decisions, and metadata
                const contextStr = JSON.stringify(capsule.context || {}).toLowerCase();
                const decisionsStr = JSON.stringify(capsule.decisions || []).toLowerCase();
                const metadataStr = JSON.stringify(capsule.metadata || {}).toLowerCase();
                return contextStr.includes(query) || decisionsStr.includes(query) || metadataStr.includes(query);
            });
            // Apply team filter if specified
            let filteredCapsules = matchedCapsules;
            if (params.filters?.team) {
                filteredCapsules = matchedCapsules.filter((capsule) => capsule.id.includes(params.filters.team) || capsule.context?.team === params.filters.team);
            }
            // Limit results
            const results = filteredCapsules.slice(0, limit);
            return {
                success: true,
                data: {
                    capsules: results,
                    total: filteredCapsules.length,
                    query: params.query,
                    filters: params.filters,
                },
                metadata: {
                    latency_ms: Date.now() - startTime,
                    cached: false,
                },
            };
        }
        catch (error) {
            return {
                success: false,
                error: {
                    code: 'INTERNAL_ERROR',
                    message: error instanceof Error ? error.message : 'Unknown error',
                },
                metadata: {
                    latency_ms: Date.now() - startTime,
                    cached: false,
                },
            };
        }
    }
}
//# sourceMappingURL=memory-tools.js.map