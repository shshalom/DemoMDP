/**
 * Adapter Interfaces (FROZEN as of M1.5)
 *
 * These interfaces define the contracts between Team A (Registry/Resolver)
 * and Team B (Action Engine) for provider adapters.
 *
 * BREAKING CHANGES require:
 * 1. Major version bump
 * 2. Cross-team coordination
 * 3. Migration guide in CONTRACTS.md
 *
 * @since M1.5 (Contract Hardening)
 */
/**
 * Standard provider error codes
 *
 * These codes allow Team B (Action Engine) to handle failures uniformly
 * without knowing provider-specific error details.
 */
export declare enum ProviderErrorCode {
    AUTH_MISSING = "AUTH_MISSING",
    AUTH_INVALID = "AUTH_INVALID",
    AUTH_EXPIRED = "AUTH_EXPIRED",
    PERMISSION_DENIED = "PERMISSION_DENIED",
    NOT_FOUND = "NOT_FOUND",
    GONE = "GONE",
    RATE_LIMIT = "RATE_LIMIT",
    SERVER_ERROR = "SERVER_ERROR",
    SERVICE_UNAVAILABLE = "SERVICE_UNAVAILABLE",
    NETWORK_ERROR = "NETWORK_ERROR",
    TIMEOUT = "TIMEOUT",
    INVALID_INPUT = "INVALID_INPUT",
    SCHEMA_VALIDATION_FAILED = "SCHEMA_VALIDATION_FAILED",
    UNKNOWN = "UNKNOWN"
}
/**
 * Standardized provider error
 *
 * Adapters MUST map provider-specific errors to this taxonomy.
 */
export declare class ProviderError extends Error {
    code: ProviderErrorCode;
    details?: {
        provider?: string;
        originalError?: unknown;
        retryable?: boolean;
        retryAfter?: number;
        metadata?: Record<string, unknown>;
    } | undefined;
    constructor(code: ProviderErrorCode, message: string, details?: {
        provider?: string;
        originalError?: unknown;
        retryable?: boolean;
        retryAfter?: number;
        metadata?: Record<string, unknown>;
    } | undefined);
    /**
     * Whether this error is retryable
     */
    get isRetryable(): boolean;
    private isRetryableByCode;
}
/**
 * Repository context inferred from environment or explicit input
 */
export interface RepoContext {
    owner: string;
    repo: string;
    provider: 'github' | 'gitlab' | 'bitbucket' | 'azure-devops';
    url?: string;
}
/**
 * Infers repository context from environment variables
 *
 * Used by CLI when no explicit repo is provided.
 * Each adapter MUST implement provider-specific inference.
 */
export interface RepoInference {
    /**
     * Infer repo context from environment (e.g., GITHUB_REPOSITORY, CI vars)
     */
    inferFromEnvironment(): RepoContext | null;
    /**
     * Infer repo context from git remote URL
     */
    inferFromGitRemote(remoteUrl: string): RepoContext | null;
    /**
     * Validate explicit repo context
     */
    validate(context: Partial<RepoContext>): RepoContext;
}
/**
 * Pull Request information (normalized across providers)
 */
export interface PullRequest {
    number: number;
    title: string;
    body?: string;
    state: 'open' | 'closed' | 'merged';
    author: string;
    base_branch: string;
    head_branch: string;
    url: string;
    created_at: string;
    updated_at?: string;
    merged_at?: string;
}
/**
 * Comment posted to PR or issue
 */
export interface Comment {
    id: string;
    body: string;
    author: string;
    created_at: string;
    url: string;
}
/**
 * CI check/status result
 */
export interface CheckResult {
    name: string;
    status: 'pending' | 'success' | 'failure' | 'error';
    conclusion?: 'success' | 'failure' | 'neutral' | 'cancelled' | 'skipped' | 'timed_out' | 'action_required';
    title?: string;
    summary?: string;
    details_url?: string;
}
/**
 * Base adapter interface (FROZEN)
 *
 * All provider adapters (GitHub, GitLab, Bitbucket) MUST implement this interface.
 *
 * Team A (M2) implements adapters.
 * Team B (M5) consumes adapters via this interface.
 */
export interface ProviderAdapter {
    /**
     * Provider name (github, gitlab, bitbucket, azure-devops)
     */
    readonly name: string;
    /**
     * Initialize adapter with credentials/config
     */
    initialize(config: {
        token?: string;
        baseUrl?: string;
        repo: RepoContext;
        [key: string]: unknown;
    }): Promise<void>;
    /**
     * Check if adapter is properly initialized and authenticated
     */
    healthCheck(): Promise<{
        healthy: boolean;
        error?: ProviderError;
    }>;
    /**
     * Get PR by number
     */
    getPullRequest(prNumber: number): Promise<PullRequest>;
    /**
     * List open PRs (optional filters)
     */
    listPullRequests(filters?: {
        state?: 'open' | 'closed' | 'all';
        author?: string;
        base?: string;
    }): Promise<PullRequest[]>;
    /**
     * Get files changed in a PR
     */
    getPullRequestFiles(prNumber: number): Promise<Array<{
        filename: string;
        status: 'added' | 'modified' | 'removed' | 'renamed';
        additions: number;
        deletions: number;
        patch?: string;
    }>>;
    /**
     * Post a comment to a PR
     */
    createComment(prNumber: number, body: string): Promise<Comment>;
    /**
     * List comments on a PR
     */
    listComments(prNumber: number): Promise<Comment[]>;
    /**
     * Update an existing comment
     */
    updateComment(commentId: string, body: string): Promise<Comment>;
    /**
     * Delete a comment
     */
    deleteComment(commentId: string): Promise<void>;
    /**
     * Create or update a CI check
     */
    createCheck(params: {
        name: string;
        head_sha: string;
        status: 'queued' | 'in_progress' | 'completed';
        conclusion?: 'success' | 'failure' | 'neutral' | 'cancelled' | 'skipped' | 'timed_out' | 'action_required';
        title?: string;
        summary?: string;
        details_url?: string;
    }): Promise<CheckResult>;
    /**
     * List checks for a commit
     */
    listChecks(ref: string): Promise<CheckResult[]>;
    /**
     * Get file contents from repository
     */
    getFileContent(params: {
        path: string;
        ref?: string;
    }): Promise<{
        content: string;
        sha: string;
        encoding: 'base64' | 'utf-8';
    }>;
    /**
     * Get repository information
     */
    getRepository(): Promise<{
        name: string;
        owner: string;
        default_branch: string;
        url: string;
        private: boolean;
    }>;
}
/**
 * Adapter factory function
 */
export type AdapterFactory = () => ProviderAdapter;
/**
 * Adapter registry interface
 *
 * Team A (M2) implements this.
 * Provides discovery and instantiation of adapters.
 */
export interface AdapterRegistry {
    /**
     * Register a provider adapter
     */
    register(providerName: string, factory: AdapterFactory): void;
    /**
     * Get adapter by provider name
     */
    get(providerName: string): ProviderAdapter | null;
    /**
     * List all registered providers
     */
    list(): string[];
    /**
     * Check if provider is registered
     */
    has(providerName: string): boolean;
}
//# sourceMappingURL=interfaces.d.ts.map