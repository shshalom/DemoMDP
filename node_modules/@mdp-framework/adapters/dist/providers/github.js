/**
 * GitHub Adapter (M5 - Team B)
 *
 * Implements ProviderAdapter interface for GitHub operations:
 * - PR operations: getPullRequest, getPullRequestFiles
 * - Comment operations: createComment, listComments, updateComment, deleteComment
 * - Check operations: createCheck, listChecks
 * - Repository operations: getFileContent, getRepository
 *
 * Features:
 * - Error handling with ProviderError taxonomy
 * - Rate limit detection and retry headers
 * - Octokit REST API integration
 */
import { Octokit } from '@octokit/rest';
import { ProviderError, ProviderErrorCode } from '../interfaces.js';
// ============================================================================
// GITHUB ADAPTER
// ============================================================================
export class GitHubAdapter {
    name = 'github';
    octokit;
    repo;
    /**
     * Initialize adapter with GitHub credentials
     */
    async initialize(config) {
        const token = config.token || process.env.GITHUB_TOKEN;
        if (!token) {
            throw new ProviderError(ProviderErrorCode.AUTH_MISSING, 'GitHub token is required. Provide via config.token or GITHUB_TOKEN env var.', { provider: 'github' });
        }
        this.octokit = new Octokit({
            auth: token,
            baseUrl: config.baseUrl || 'https://api.github.com',
        });
        this.repo = config.repo;
        // Validate repo context
        if (config.repo.provider !== 'github') {
            throw new ProviderError(ProviderErrorCode.INVALID_INPUT, `Invalid provider: ${config.repo.provider}. Expected 'github'.`, { provider: 'github' });
        }
    }
    /**
     * Health check - verify authentication and API access
     */
    async healthCheck() {
        if (!this.octokit) {
            return {
                healthy: false,
                error: new ProviderError(ProviderErrorCode.AUTH_MISSING, 'Adapter not initialized. Call initialize() first.', { provider: 'github' }),
            };
        }
        try {
            await this.octokit.users.getAuthenticated();
            return { healthy: true };
        }
        catch (error) {
            return {
                healthy: false,
                error: this.mapError(error),
            };
        }
    }
    // -------------------------------------------------------------------------
    // PULL REQUEST OPERATIONS
    // -------------------------------------------------------------------------
    async getPullRequest(prNumber) {
        this.ensureInitialized();
        try {
            const { data } = await this.octokit.pulls.get({
                owner: this.repo.owner,
                repo: this.repo.repo,
                pull_number: prNumber,
            });
            return {
                number: data.number,
                title: data.title,
                body: data.body || undefined,
                state: data.state === 'open' ? 'open' : data.merged_at ? 'merged' : 'closed',
                author: data.user?.login || 'unknown',
                base_branch: data.base.ref,
                head_branch: data.head.ref,
                url: data.html_url,
                created_at: data.created_at,
                updated_at: data.updated_at,
                merged_at: data.merged_at || undefined,
            };
        }
        catch (error) {
            throw this.mapError(error);
        }
    }
    async listPullRequests(filters) {
        this.ensureInitialized();
        try {
            const { data } = await this.octokit.pulls.list({
                owner: this.repo.owner,
                repo: this.repo.repo,
                state: filters?.state || 'open',
                base: filters?.base,
            });
            let prs = data;
            // Filter by author if specified
            if (filters?.author) {
                prs = prs.filter((pr) => pr.user?.login === filters.author);
            }
            return prs.map((pr) => ({
                number: pr.number,
                title: pr.title,
                state: pr.state === 'open' ? 'open' : 'closed',
                author: pr.user?.login || 'unknown',
                base_branch: pr.base.ref,
                head_branch: pr.head.ref,
                url: pr.html_url,
                created_at: pr.created_at,
                updated_at: pr.updated_at,
            }));
        }
        catch (error) {
            throw this.mapError(error);
        }
    }
    async getPullRequestFiles(prNumber) {
        this.ensureInitialized();
        try {
            const { data } = await this.octokit.pulls.listFiles({
                owner: this.repo.owner,
                repo: this.repo.repo,
                pull_number: prNumber,
            });
            return data.map((file) => ({
                filename: file.filename,
                status: file.status,
                additions: file.additions,
                deletions: file.deletions,
                patch: file.patch,
            }));
        }
        catch (error) {
            throw this.mapError(error);
        }
    }
    // -------------------------------------------------------------------------
    // COMMENT OPERATIONS
    // -------------------------------------------------------------------------
    async createComment(prNumber, body) {
        this.ensureInitialized();
        try {
            const { data } = await this.octokit.issues.createComment({
                owner: this.repo.owner,
                repo: this.repo.repo,
                issue_number: prNumber,
                body,
            });
            return {
                id: String(data.id),
                body: data.body || '',
                author: data.user?.login || 'unknown',
                created_at: data.created_at,
                url: data.html_url,
            };
        }
        catch (error) {
            throw this.mapError(error);
        }
    }
    async listComments(prNumber) {
        this.ensureInitialized();
        try {
            const { data } = await this.octokit.issues.listComments({
                owner: this.repo.owner,
                repo: this.repo.repo,
                issue_number: prNumber,
            });
            return data.map((comment) => ({
                id: String(comment.id),
                body: comment.body || '',
                author: comment.user?.login || 'unknown',
                created_at: comment.created_at,
                url: comment.html_url,
            }));
        }
        catch (error) {
            throw this.mapError(error);
        }
    }
    async updateComment(commentId, body) {
        this.ensureInitialized();
        try {
            const { data } = await this.octokit.issues.updateComment({
                owner: this.repo.owner,
                repo: this.repo.repo,
                comment_id: parseInt(commentId, 10),
                body,
            });
            return {
                id: String(data.id),
                body: data.body || '',
                author: data.user?.login || 'unknown',
                created_at: data.created_at,
                url: data.html_url,
            };
        }
        catch (error) {
            throw this.mapError(error);
        }
    }
    async deleteComment(commentId) {
        this.ensureInitialized();
        try {
            await this.octokit.issues.deleteComment({
                owner: this.repo.owner,
                repo: this.repo.repo,
                comment_id: parseInt(commentId, 10),
            });
        }
        catch (error) {
            throw this.mapError(error);
        }
    }
    // -------------------------------------------------------------------------
    // CHECK/STATUS OPERATIONS
    // -------------------------------------------------------------------------
    async createCheck(params) {
        this.ensureInitialized();
        try {
            const { data } = await this.octokit.checks.create({
                owner: this.repo.owner,
                repo: this.repo.repo,
                name: params.name,
                head_sha: params.head_sha,
                status: params.status,
                conclusion: params.conclusion,
                output: params.title || params.summary ? {
                    title: params.title || params.name,
                    summary: params.summary || '',
                } : undefined,
                details_url: params.details_url,
            });
            return {
                name: data.name,
                status: this.mapCheckStatus(data.status),
                conclusion: data.conclusion,
                title: params.title,
                summary: params.summary,
                details_url: data.details_url || undefined,
            };
        }
        catch (error) {
            throw this.mapError(error);
        }
    }
    async listChecks(ref) {
        this.ensureInitialized();
        try {
            const { data } = await this.octokit.checks.listForRef({
                owner: this.repo.owner,
                repo: this.repo.repo,
                ref,
            });
            return data.check_runs.map((check) => ({
                name: check.name,
                status: this.mapCheckStatus(check.status),
                conclusion: check.conclusion,
                summary: check.output?.summary || undefined,
                details_url: check.details_url || undefined,
            }));
        }
        catch (error) {
            throw this.mapError(error);
        }
    }
    // -------------------------------------------------------------------------
    // REPOSITORY OPERATIONS
    // -------------------------------------------------------------------------
    async getFileContent(params) {
        this.ensureInitialized();
        try {
            const { data } = await this.octokit.repos.getContent({
                owner: this.repo.owner,
                repo: this.repo.repo,
                path: params.path,
                ref: params.ref,
            });
            // Handle directory or array responses
            if (Array.isArray(data) || data.type !== 'file') {
                throw new ProviderError(ProviderErrorCode.INVALID_INPUT, `Path ${params.path} is not a file`, { provider: 'github' });
            }
            // Decode base64 content
            const content = Buffer.from(data.content, 'base64').toString('utf-8');
            return {
                content,
                sha: data.sha,
                encoding: 'utf-8',
            };
        }
        catch (error) {
            throw this.mapError(error);
        }
    }
    async getRepository() {
        this.ensureInitialized();
        try {
            const { data } = await this.octokit.repos.get({
                owner: this.repo.owner,
                repo: this.repo.repo,
            });
            return {
                name: data.name,
                owner: data.owner.login,
                default_branch: data.default_branch,
                url: data.html_url,
                private: data.private,
            };
        }
        catch (error) {
            throw this.mapError(error);
        }
    }
    // -------------------------------------------------------------------------
    // HELPERS
    // -------------------------------------------------------------------------
    ensureInitialized() {
        if (!this.octokit || !this.repo) {
            throw new ProviderError(ProviderErrorCode.AUTH_MISSING, 'Adapter not initialized. Call initialize() first.', { provider: 'github' });
        }
    }
    mapCheckStatus(status) {
        switch (status) {
            case 'queued':
            case 'in_progress':
                return 'pending';
            case 'completed':
                return 'success';
            default:
                return 'pending';
        }
    }
    /**
     * Map GitHub API errors to ProviderError taxonomy
     */
    mapError(error) {
        // Handle Octokit errors
        if (error && typeof error === 'object' && 'status' in error) {
            const status = error.status;
            const message = error.message || 'Unknown error';
            switch (status) {
                case 401:
                    return new ProviderError(ProviderErrorCode.AUTH_INVALID, `GitHub authentication failed: ${message}`, { provider: 'github', originalError: error, retryable: false });
                case 403:
                    // Check for rate limit
                    if (message.includes('rate limit')) {
                        return new ProviderError(ProviderErrorCode.RATE_LIMIT, `GitHub rate limit exceeded: ${message}`, { provider: 'github', originalError: error, retryable: true });
                    }
                    return new ProviderError(ProviderErrorCode.PERMISSION_DENIED, `GitHub permission denied: ${message}`, { provider: 'github', originalError: error, retryable: false });
                case 404:
                    return new ProviderError(ProviderErrorCode.NOT_FOUND, `GitHub resource not found: ${message}`, { provider: 'github', originalError: error, retryable: false });
                case 410:
                    return new ProviderError(ProviderErrorCode.GONE, `GitHub resource gone: ${message}`, { provider: 'github', originalError: error, retryable: false });
                case 422:
                    return new ProviderError(ProviderErrorCode.INVALID_INPUT, `GitHub validation failed: ${message}`, { provider: 'github', originalError: error, retryable: false });
                case 429:
                    return new ProviderError(ProviderErrorCode.RATE_LIMIT, `GitHub rate limit exceeded: ${message}`, { provider: 'github', originalError: error, retryable: true });
                case 500:
                case 502:
                case 503:
                    return new ProviderError(ProviderErrorCode.SERVER_ERROR, `GitHub server error: ${message}`, { provider: 'github', originalError: error, retryable: true });
                case 504:
                    return new ProviderError(ProviderErrorCode.TIMEOUT, `GitHub request timeout: ${message}`, { provider: 'github', originalError: error, retryable: true });
                default:
                    return new ProviderError(ProviderErrorCode.UNKNOWN, `GitHub error (${status}): ${message}`, { provider: 'github', originalError: error, retryable: false });
            }
        }
        // Handle network errors
        if (error instanceof Error) {
            if (error.message.includes('ECONNREFUSED') || error.message.includes('ENOTFOUND')) {
                return new ProviderError(ProviderErrorCode.NETWORK_ERROR, `GitHub network error: ${error.message}`, { provider: 'github', originalError: error, retryable: true });
            }
            if (error.message.includes('timeout')) {
                return new ProviderError(ProviderErrorCode.TIMEOUT, `GitHub timeout: ${error.message}`, { provider: 'github', originalError: error, retryable: true });
            }
        }
        // Unknown error
        return new ProviderError(ProviderErrorCode.UNKNOWN, `Unknown GitHub error: ${error instanceof Error ? error.message : String(error)}`, { provider: 'github', originalError: error, retryable: false });
    }
}
/**
 * Create a GitHub adapter instance
 */
export function createGitHubAdapter() {
    return new GitHubAdapter();
}
//# sourceMappingURL=github.js.map