/**
 * Mock Adapter (M6 - Testing)
 *
 * Provides a test adapter that simulates provider operations
 * without making actual API calls. Useful for:
 * - Local development
 * - CI testing without credentials
 * - Demo purposes
 */
import { ProviderError, ProviderErrorCode } from '../interfaces.js';
// ============================================================================
// MOCK ADAPTER
// ============================================================================
export class MockAdapter {
    name = 'mock';
    repo;
    initialized = false;
    // In-memory storage for mock data
    checks = new Map();
    comments = new Map();
    prs = new Map();
    files = new Map();
    /**
     * Initialize mock adapter
     */
    async initialize(config) {
        this.repo = config.repo;
        this.initialized = true;
        // Pre-populate with some mock data if needed
        if (config.populateMockData) {
            this.populateMockData();
        }
    }
    /**
     * Health check always succeeds for mock
     */
    async healthCheck() {
        if (!this.initialized) {
            return {
                healthy: false,
                error: new ProviderError(ProviderErrorCode.AUTH_MISSING, 'Adapter not initialized', { provider: 'mock' }),
            };
        }
        return { healthy: true };
    }
    // -------------------------------------------------------------------------
    // PULL REQUEST OPERATIONS
    // -------------------------------------------------------------------------
    async getPullRequest(prNumber) {
        this.assertInitialized();
        const pr = this.prs.get(prNumber);
        if (!pr) {
            throw new ProviderError(ProviderErrorCode.NOT_FOUND, `PR #${prNumber} not found`, { provider: 'mock' });
        }
        return pr;
    }
    async listPullRequests(filters) {
        this.assertInitialized();
        let prs = Array.from(this.prs.values());
        if (filters?.state && filters.state !== 'all') {
            prs = prs.filter((pr) => pr.state === filters.state);
        }
        if (filters?.author) {
            prs = prs.filter((pr) => pr.author === filters.author);
        }
        if (filters?.base) {
            prs = prs.filter((pr) => pr.base_branch === filters.base);
        }
        return prs;
    }
    async getPullRequestFiles(prNumber) {
        this.assertInitialized();
        const files = this.files.get(prNumber);
        if (!files) {
            throw new ProviderError(ProviderErrorCode.NOT_FOUND, `Files for PR #${prNumber} not found`, { provider: 'mock' });
        }
        return files;
    }
    // -------------------------------------------------------------------------
    // COMMENT OPERATIONS
    // -------------------------------------------------------------------------
    async createComment(prNumber, body) {
        this.assertInitialized();
        const comment = {
            id: `mock-comment-${Date.now()}`,
            body,
            author: 'mdp-bot',
            created_at: new Date().toISOString(),
            url: `https://github.com/${this.repo?.owner}/${this.repo?.repo}/pull/${prNumber}#comment-${Date.now()}`,
        };
        const prComments = this.comments.get(prNumber) || [];
        prComments.push(comment);
        this.comments.set(prNumber, prComments);
        return comment;
    }
    async listComments(prNumber) {
        this.assertInitialized();
        return this.comments.get(prNumber) || [];
    }
    async updateComment(commentId, body) {
        this.assertInitialized();
        for (const [prNumber, comments] of this.comments.entries()) {
            const comment = comments.find((c) => c.id === commentId);
            if (comment) {
                comment.body = body;
                return comment;
            }
        }
        throw new ProviderError(ProviderErrorCode.NOT_FOUND, `Comment ${commentId} not found`, { provider: 'mock' });
    }
    async deleteComment(commentId) {
        this.assertInitialized();
        for (const [prNumber, comments] of this.comments.entries()) {
            const index = comments.findIndex((c) => c.id === commentId);
            if (index !== -1) {
                comments.splice(index, 1);
                return;
            }
        }
        throw new ProviderError(ProviderErrorCode.NOT_FOUND, `Comment ${commentId} not found`, { provider: 'mock' });
    }
    // -------------------------------------------------------------------------
    // CHECK OPERATIONS
    // -------------------------------------------------------------------------
    async createCheck(params) {
        this.assertInitialized();
        const checkKey = `${params.head_sha}-${params.name}`;
        const check = {
            name: params.name,
            status: params.status === 'completed' ? 'success' : 'pending',
            conclusion: params.conclusion,
            title: params.title,
            summary: params.summary,
            details_url: params.details_url,
        };
        this.checks.set(checkKey, check);
        return check;
    }
    async listChecks(ref) {
        this.assertInitialized();
        const checks = [];
        for (const [key, check] of this.checks.entries()) {
            if (key.startsWith(ref)) {
                checks.push(check);
            }
        }
        return checks;
    }
    // -------------------------------------------------------------------------
    // REPOSITORY OPERATIONS
    // -------------------------------------------------------------------------
    async getFileContent(params) {
        this.assertInitialized();
        // Return mock content
        return {
            content: `// Mock content for ${params.path}`,
            sha: `mock-sha-${Date.now()}`,
            encoding: 'utf-8',
        };
    }
    async getRepository() {
        this.assertInitialized();
        return {
            name: this.repo?.repo || 'mock-repo',
            owner: this.repo?.owner || 'mock-owner',
            default_branch: 'main',
            url: this.repo?.url || 'https://github.com/mock-owner/mock-repo',
            private: false,
        };
    }
    // -------------------------------------------------------------------------
    // HELPER METHODS
    // -------------------------------------------------------------------------
    assertInitialized() {
        if (!this.initialized) {
            throw new ProviderError(ProviderErrorCode.AUTH_MISSING, 'Adapter not initialized. Call initialize() first.', { provider: 'mock' });
        }
    }
    populateMockData() {
        // Add a mock PR
        this.prs.set(123, {
            number: 123,
            title: 'Fix bug',
            body: 'This PR fixes a critical bug',
            state: 'open',
            author: 'developer',
            base_branch: 'main',
            head_branch: 'fix/bug',
            url: 'https://github.com/mock-owner/mock-repo/pull/123',
            created_at: '2025-01-11T00:00:00Z',
        });
        // Add mock files for the PR
        this.files.set(123, [
            {
                filename: 'src/components/Button.tsx',
                status: 'modified',
                additions: 10,
                deletions: 5,
                patch: '...',
            },
        ]);
    }
    /**
     * Helper to add mock PR data (for testing)
     */
    addMockPR(pr) {
        this.prs.set(pr.number, pr);
    }
    /**
     * Helper to add mock files for a PR (for testing)
     */
    addMockFiles(prNumber, files) {
        this.files.set(prNumber, files);
    }
    /**
     * Get all mock data (for debugging)
     */
    getMockData() {
        return {
            prs: Array.from(this.prs.entries()),
            comments: Array.from(this.comments.entries()),
            checks: Array.from(this.checks.entries()),
            files: Array.from(this.files.entries()),
        };
    }
}
//# sourceMappingURL=mock.js.map