/**
 * Policy Registry - File-based policy card storage with signature verification
 *
 * Responsibilities:
 * - Load PolicyCards from .mlang/registry/*.policy.json
 * - Verify Ed25519 signatures using public keys from .mlang/keys/
 * - Manage versions and channels
 * - Support registry operations: register, get, list, verify
 *
 * @since M2 (Team A)
 */
import { readFileSync, readdirSync, existsSync, writeFileSync, mkdirSync } from 'node:fs';
import { join } from 'node:path';
import { createHash } from 'node:crypto';
import { validators } from '@mdp-framework/schemas/contracts';
/**
 * PolicyRegistry - File-based registry with signature verification
 */
export class PolicyRegistry {
    config;
    registryPath;
    channelsPath;
    publicKeys = new Map();
    constructor(config) {
        this.config = {
            basePath: config.basePath,
            keysPath: config.keysPath || join(config.basePath, 'keys'),
            requireSignature: config.requireSignature ?? false,
            verifyHash: config.verifyHash ?? true,
        };
        this.registryPath = join(this.config.basePath, 'registry');
        this.channelsPath = join(this.config.basePath, 'channels');
        // Load public keys
        this.loadPublicKeys();
    }
    /**
     * Load public keys from .mlang/keys/*.pub
     */
    loadPublicKeys() {
        if (!existsSync(this.config.keysPath)) {
            return;
        }
        try {
            const files = readdirSync(this.config.keysPath);
            for (const file of files) {
                if (file.endsWith('.pub')) {
                    const keyPath = join(this.config.keysPath, file);
                    const keyContent = readFileSync(keyPath, 'utf-8').trim();
                    const keyName = file.replace('.pub', '');
                    // Parse PEM format or raw base64
                    const keyData = this.parsePublicKey(keyContent);
                    this.publicKeys.set(keyName, keyData);
                }
            }
        }
        catch (err) {
            // Silently ignore if keys directory doesn't exist or has issues
        }
    }
    /**
     * Parse public key from PEM or base64 format
     */
    parsePublicKey(content) {
        // Remove PEM headers if present
        const cleaned = content
            .replace(/-----BEGIN PUBLIC KEY-----/g, '')
            .replace(/-----END PUBLIC KEY-----/g, '')
            .replace(/\s/g, '');
        return Buffer.from(cleaned, 'base64');
    }
    /**
     * Register a policy card
     *
     * @param card - PolicyCard to register
     * @param channel - Channel to associate with (optional)
     * @returns Result of registration
     */
    async register(card, channel) {
        // Validate schema
        if (!validators.policyCard.validate(card)) {
            return {
                ok: false,
                error: {
                    code: 'SCHEMA_VALIDATION_FAILED',
                    message: 'PolicyCard validation failed',
                    details: validators.policyCard.errors(),
                },
            };
        }
        // Verify hash
        if (this.config.verifyHash) {
            const hashResult = this.verifyHash(card);
            if (!hashResult.ok) {
                return hashResult;
            }
        }
        // Verify signature (if present or required)
        if (card.signature || this.config.requireSignature) {
            const sigResult = this.verifySignature(card);
            if (!sigResult.ok) {
                return sigResult;
            }
        }
        // Create directory structure
        const cardDir = join(this.registryPath, card.id);
        if (!existsSync(cardDir)) {
            mkdirSync(cardDir, { recursive: true });
        }
        // Write card file
        const cardPath = join(cardDir, `${card.version}.policy.json`);
        try {
            writeFileSync(cardPath, JSON.stringify(card, null, 2), 'utf-8');
        }
        catch (err) {
            return {
                ok: false,
                error: {
                    code: 'WRITE_FAILED',
                    message: `Failed to write policy card: ${err}`,
                },
            };
        }
        // Update channel pointer if specified
        if (channel) {
            const channelResult = await this.updateChannel(card.id, channel, card.version);
            if (!channelResult.ok) {
                return channelResult;
            }
        }
        return { ok: true };
    }
    /**
     * Get a policy card by ID and version
     *
     * @param id - Policy ID (e.g., "eng.pr.review")
     * @param version - Optional version (YYYY.MM.DD). If not provided, returns latest.
     * @returns Policy card or error
     */
    async get(id, version) {
        const cardDir = join(this.registryPath, id);
        if (!existsSync(cardDir)) {
            return {
                ok: false,
                error: {
                    code: 'NOT_FOUND',
                    message: `Policy ID not found: ${id}`,
                },
            };
        }
        let cardPath;
        if (version) {
            // Specific version requested
            cardPath = join(cardDir, `${version}.policy.json`);
        }
        else {
            // Get latest version
            const versions = this.listVersions(cardDir);
            if (versions.length === 0) {
                return {
                    ok: false,
                    error: {
                        code: 'NOT_FOUND',
                        message: `No versions found for policy: ${id}`,
                    },
                };
            }
            const latestVersion = versions[versions.length - 1];
            cardPath = join(cardDir, `${latestVersion}.policy.json`);
        }
        if (!existsSync(cardPath)) {
            return {
                ok: false,
                error: {
                    code: 'NOT_FOUND',
                    message: `Policy version not found: ${id}@${version || 'latest'}`,
                },
            };
        }
        // Load and parse card
        let card;
        try {
            const content = readFileSync(cardPath, 'utf-8');
            card = JSON.parse(content);
        }
        catch (err) {
            return {
                ok: false,
                error: {
                    code: 'PARSE_FAILED',
                    message: `Failed to parse policy card: ${err}`,
                },
            };
        }
        // Validate schema
        if (!validators.policyCard.validate(card)) {
            return {
                ok: false,
                error: {
                    code: 'SCHEMA_VALIDATION_FAILED',
                    message: 'PolicyCard validation failed',
                    details: validators.policyCard.errors(),
                },
            };
        }
        // Verify hash
        if (this.config.verifyHash) {
            const hashResult = this.verifyHash(card);
            if (!hashResult.ok) {
                return hashResult;
            }
        }
        // Verify signature (if present or required)
        if (card.signature || this.config.requireSignature) {
            const sigResult = this.verifySignature(card);
            if (!sigResult.ok) {
                return sigResult;
            }
        }
        return { ok: true, data: card };
    }
    /**
     * List all policy IDs in registry
     *
     * @param prefix - Optional prefix filter (e.g., "eng." to get all eng.* policies)
     * @returns List of policy IDs
     */
    async list(prefix) {
        if (!existsSync(this.registryPath)) {
            return { ok: true, data: [] };
        }
        try {
            const entries = readdirSync(this.registryPath, { withFileTypes: true });
            let ids = entries
                .filter((entry) => entry.isDirectory())
                .map((entry) => entry.name);
            if (prefix) {
                ids = ids.filter((id) => id.startsWith(prefix));
            }
            return { ok: true, data: ids.sort() };
        }
        catch (err) {
            return {
                ok: false,
                error: {
                    code: 'LIST_FAILED',
                    message: `Failed to list policies: ${err}`,
                },
            };
        }
    }
    /**
     * Get channel pointer (resolve channel to version)
     *
     * @param id - Policy ID
     * @param channel - Channel name
     * @returns Version for the channel
     */
    async getChannel(id, channel) {
        const channelPath = join(this.channelsPath, id, channel);
        if (!existsSync(channelPath)) {
            return {
                ok: false,
                error: {
                    code: 'CHANNEL_NOT_FOUND',
                    message: `Channel not found: ${id}@${channel}`,
                },
            };
        }
        try {
            const version = readFileSync(channelPath, 'utf-8').trim();
            return { ok: true, data: version };
        }
        catch (err) {
            return {
                ok: false,
                error: {
                    code: 'READ_FAILED',
                    message: `Failed to read channel pointer: ${err}`,
                },
            };
        }
    }
    /**
     * Update channel pointer
     *
     * @param id - Policy ID
     * @param channel - Channel name
     * @param version - Version to point to
     * @returns Result of update
     */
    async updateChannel(id, channel, version) {
        const channelDir = join(this.channelsPath, id);
        if (!existsSync(channelDir)) {
            mkdirSync(channelDir, { recursive: true });
        }
        const channelPath = join(channelDir, channel);
        try {
            writeFileSync(channelPath, version, 'utf-8');
            return { ok: true };
        }
        catch (err) {
            return {
                ok: false,
                error: {
                    code: 'WRITE_FAILED',
                    message: `Failed to update channel pointer: ${err}`,
                },
            };
        }
    }
    /**
     * Verify a policy card's signature and hash
     *
     * @param card - Policy card to verify
     * @returns Verification result
     */
    async verify(card) {
        const hashResult = this.verifyHash(card);
        const sigResult = card.signature ? this.verifySignature(card) : { ok: true };
        return {
            ok: hashResult.ok && sigResult.ok,
            data: {
                hash: hashResult.ok,
                signature: sigResult.ok,
                signedBy: card.signed_by,
            },
            error: !hashResult.ok ? hashResult.error : !sigResult.ok ? sigResult.error : undefined,
        };
    }
    /**
     * Verify hash integrity
     */
    verifyHash(card) {
        // Compute hash of card content (excluding hash and signature fields)
        const { hash: _, signature: __, ...content } = card;
        const computed = this.computeHash(content);
        if (computed !== card.hash) {
            return {
                ok: false,
                error: {
                    code: 'HASH_MISMATCH',
                    message: `Hash mismatch: expected ${card.hash}, got ${computed}`,
                },
            };
        }
        return { ok: true };
    }
    /**
     * Verify Ed25519 signature
     */
    verifySignature(card) {
        if (!card.signature) {
            return {
                ok: false,
                error: {
                    code: 'SIGNATURE_MISSING',
                    message: 'Signature is required but not present',
                },
            };
        }
        if (!card.signed_by) {
            return {
                ok: false,
                error: {
                    code: 'SIGNER_MISSING',
                    message: 'signed_by field is required for signature verification',
                },
            };
        }
        const publicKey = this.publicKeys.get(card.signed_by);
        if (!publicKey) {
            return {
                ok: false,
                error: {
                    code: 'PUBLIC_KEY_NOT_FOUND',
                    message: `Public key not found for signer: ${card.signed_by}`,
                },
            };
        }
        try {
            // TODO: Implement Ed25519 signature verification
            // For M2, we'll use a placeholder that checks signature format
            // Full implementation requires proper Ed25519 crypto
            // Signature should be base64-encoded
            const signatureBuffer = Buffer.from(card.signature, 'base64');
            // Verify signature length (Ed25519 signatures are 64 bytes)
            if (signatureBuffer.length !== 64) {
                return {
                    ok: false,
                    error: {
                        code: 'INVALID_SIGNATURE',
                        message: 'Signature must be 64 bytes (Ed25519)',
                    },
                };
            }
            // TODO: Actual verification with crypto.verify()
            // For now, we accept properly formatted signatures as a stub
            // Real implementation in production would verify using:
            // verify('ed25519', Buffer.from(card.hash), publicKey, signatureBuffer)
            return { ok: true };
        }
        catch (err) {
            return {
                ok: false,
                error: {
                    code: 'SIGNATURE_VERIFICATION_FAILED',
                    message: `Signature verification failed: ${err}`,
                },
            };
        }
    }
    /**
     * Compute SHA-256 hash of content with sha256: prefix
     */
    computeHash(content) {
        const canonical = JSON.stringify(content, Object.keys(content).sort());
        const hashHex = createHash('sha256').update(canonical).digest('hex');
        return `sha256:${hashHex}`;
    }
    /**
     * List versions for a policy (sorted oldest to newest)
     */
    listVersions(cardDir) {
        try {
            const files = readdirSync(cardDir);
            const versions = files
                .filter((f) => f.endsWith('.policy.json'))
                .map((f) => f.replace('.policy.json', ''))
                .sort(); // YYYY.MM.DD format sorts naturally
            return versions;
        }
        catch {
            return [];
        }
    }
}
/**
 * Create a policy registry instance
 *
 * @param basePath - Path to .mlang directory
 * @param config - Optional configuration
 * @returns PolicyRegistry instance
 */
export function createRegistry(basePath, config) {
    return new PolicyRegistry({
        basePath,
        ...config,
    });
}
//# sourceMappingURL=registry.js.map