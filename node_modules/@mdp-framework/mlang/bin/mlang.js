#!/usr/bin/env node

import { config } from 'dotenv';
import { existsSync } from 'fs';
import { join } from 'path';
import { Command } from 'commander';
import { createRequire } from 'module';
import { runCapsulePrune, runCapsuleExport, runCapsuleImport } from '../dist/commands/capsule.js';
import { runDoctor } from '../dist/commands/doctor.js';
import { runInit } from '../dist/commands/init.js';
import { runRegistryHead, runRegistryGet, runRegistryVerify, runRegistryList } from '../dist/commands/registry.js';
import { runPolicyInit, runPolicyBuild, runPolicySign, runPolicyVerify, runKeysGenerate } from '../dist/commands/policy.js';
import { runEvaluate } from '../dist/commands/evaluate.js';
import { runPRReview } from '../dist/commands/pr.js';
import { createLogger } from '../dist/utils/logger.js';

// Load .env file - prefer .mlang/.env, fall back to root .env
const mlangEnvPath = join(process.cwd(), '.mlang', '.env');
const rootEnvPath = join(process.cwd(), '.env');

if (existsSync(mlangEnvPath)) {
  config({ path: mlangEnvPath });
} else if (existsSync(rootEnvPath)) {
  config({ path: rootEnvPath });
}

const require = createRequire(import.meta.url);
const packageJson = require('../package.json');

const program = new Command();

program
  .name('mlang')
  .description('MLang CLI - Policy compiler, PR governance, and developer tools')
  .version(packageJson.version);

// Doctor command
program
  .command('doctor')
  .description('Check MLang environment and dependencies')
  .option('--ci', 'Run in CI mode (requires GITHUB_TOKEN)')
  .option('--verbose', 'Show detailed check information')
  .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
      const results = await runDoctor(logger, options);
      const failed = results.filter((r) => !r.passed && r.required).length;
      process.exit(failed > 0 ? 1 : 0);
    } catch (error) {
      logger.error(`Doctor failed: ${error.message}`);
      process.exit(1);
    }
  });

// Init command
program
  .command('init')
  .description('Initialize MLang in the current project')
  .option('--force', 'Reinitialize even if .mlang directory exists')
  .option('--verbose', 'Show detailed initialization steps')
  .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
      await runInit(logger, options);
      process.exit(0);
    } catch (error) {
      logger.error(`Initialization failed: ${error.message}`);
      process.exit(1);
    }
  });

// Policy commands (M4)
const policy = program
  .command('policy')
  .description('Policy compilation and management');

policy
  .command('init')
  .description('Initialize a new policy file')
  .requiredOption('--id <id>', 'Policy ID (e.g., eng.pr.review)')
  .requiredOption('--scope <scope>', 'Policy scope (e.g., pr/governance)')
  .requiredOption('--out <file>', 'Output file path')
  .option('--verbose', 'Show detailed information')
  .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
      await runPolicyInit(logger, options);
      process.exit(0);
    } catch (error) {
      logger.error(`Command failed: ${error.message}`);
      process.exit(1);
    }
  });

policy
  .command('build')
  .description('Compile Markdown policies to PolicyCards')
  .option('--in <dir>', 'Input directory (default: policies/ or from config)')
  .option('--out <dir>', 'Output directory (default: .mlang/packs/<channel>)')
  .option('--channel <channel>', 'Target channel (stable, preview, dev)', 'stable')
  .option('--version <version>', 'Override version (default: YYYY.MM.DD)')
  .option('--strict', 'Fail on warnings')
  .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
  .option('--verbose', 'Show detailed information')
  .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
      await runPolicyBuild(logger, options);
      process.exit(0);
    } catch (error) {
      logger.error(`Command failed: ${error.message}`);
      process.exit(1);
    }
  });

policy
  .command('sign')
  .description('Sign compiled policies with ed25519')
  .requiredOption('--in <dir>', 'Input directory (unsigned JSON)')
  .requiredOption('--out <dir>', 'Output directory for signed JSON')
  .requiredOption('--key-file <file>', 'Private key file (ed25519)')
  .option('--verbose', 'Show detailed information')
  .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
      await runPolicySign(logger, options);
      process.exit(0);
    } catch (error) {
      logger.error(`Command failed: ${error.message}`);
      process.exit(1);
    }
  });

policy
  .command('verify')
  .description('Verify signed policy signatures')
  .requiredOption('--in <path>', 'File or directory to verify')
  .option('--key-file <file>', 'Public key file (default: .mlang/keys/*.pub)')
  .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
  .option('--verbose', 'Show detailed information')
  .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
      await runPolicyVerify(logger, options);
      process.exit(0);
    } catch (error) {
      logger.error(`Command failed: ${error.message}`);
      process.exit(1);
    }
  });

// Evaluate command (M5)
program
  .command('evaluate')
  .description('Evaluate PR or local changes against policies')
  .option('--pr <number>', 'PR number (requires GitHub token)')
  .option('--file <file>', 'Load PR data from JSON file')
  .option('--policies <dir>', 'Policy directory (default: .mlang/policies)')
  .option('--policy-ids <ids>', 'Filter specific policies by ID (comma-separated)')
  .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
  .option('--format <format>', 'Output format: text or json', 'text')
  .option('--execute', 'Execute ActionPlan (requires GitHub token for real execution)')
  .option('--dry-run', 'Execute ActionPlan in dry-run mode (no actual API calls)')
  .option('--github-token <token>', 'GitHub token for execution (or use GITHUB_TOKEN env var)')
  .option('--verbose', 'Show detailed information')
  .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
      await runEvaluate(logger, options);
      // Exit code set by runEvaluate
    } catch (error) {
      logger.error(`Evaluation failed: ${error.message}`);
      process.exit(1);
    }
  });

// PR commands (M7)
const pr = program
  .command('pr')
  .description('Pull request operations');

pr
  .command('review')
  .description('Review PR against policies (CI entrypoint)')
  .requiredOption('--pr <number>', 'PR number to review')
  .option('--repo <repo>', 'Repository (owner/repo) - auto-inferred if not provided')
  .option('--check-name <name>', 'GitHub check name', 'mdp-governance')
  .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
  .option('--emit-envelope <file>', 'Emit envelope JSON to file')
  .option('--dry-run', 'Skip action execution (evaluation only)')
  .option('--verbose', 'Show detailed information')
  .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
      await runPRReview(logger, options);
      // Exit code set by runPRReview
    } catch (error) {
      logger.error(`PR review failed: ${error.message}`);
      process.exit(1);
    }
  });

const keys = program
  .command('keys')
  .description('Signing key management');

keys
  .command('generate')
  .description('Generate ed25519 signing keypair')
  .requiredOption('--out <path>', 'Output path (will create .ed25519 and .pub files)')
  .option('--name <name>', 'Key name/identifier (for documentation)')
  .option('--verbose', 'Show detailed information')
  .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
      await runKeysGenerate(logger, options);
      process.exit(0);
    } catch (error) {
      logger.error(`Command failed: ${error.message}`);
      process.exit(1);
    }
  });

// Registry commands (M2)
const registry = program
  .command('registry')
  .description('Policy registry operations');

registry
  .command('head <id>')
  .description('Show latest version on channel')
  .option('--channel <channel>', 'Channel name (stable, preview, dev)', 'stable')
  .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
  .option('--verbose', 'Show detailed information')
  .action(async (id, options) => {
    const logger = createLogger(options.verbose);
    try {
      await runRegistryHead(logger, id, options);
      process.exit(0);
    } catch (error) {
      logger.error(`Command failed: ${error.message}`);
      process.exit(1);
    }
  });

registry
  .command('get <id>')
  .description('Fetch policy by ID')
  .option('--version <version>', 'Specific version (YYYY.MM.DD)')
  .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
  .option('--save <file>', 'Save policy to file')
  .option('--verbose', 'Show detailed information')
  .action(async (id, options) => {
    const logger = createLogger(options.verbose);
    try {
      await runRegistryGet(logger, id, options);
      process.exit(0);
    } catch (error) {
      logger.error(`Command failed: ${error.message}`);
      process.exit(1);
    }
  });

registry
  .command('verify <file>')
  .description('Verify policy signature')
  .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
  .option('--verbose', 'Show detailed information')
  .action(async (file, options) => {
    const logger = createLogger(options.verbose);
    try {
      await runRegistryVerify(logger, file, options);
      process.exit(0);
    } catch (error) {
      logger.error(`Command failed: ${error.message}`);
      process.exit(1);
    }
  });

registry
  .command('list [prefix]')
  .description('List all policies in registry')
  .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
  .option('--verbose', 'Show detailed information')
  .action(async (prefix, options) => {
    const logger = createLogger(options.verbose);
    try {
      await runRegistryList(logger, prefix, options);
      process.exit(0);
    } catch (error) {
      logger.error(`Command failed: ${error.message}`);
      process.exit(1);
    }
  });

// Capsule commands (M3)
const capsule = program
  .command('capsule')
  .description('Capsule store operations (state management)');

capsule
  .command('prune')
  .description('Prune old capsules based on retention policy')
  .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
  .option('--apply', 'Actually delete capsules (default is dry-run)')
  .option('--keep-days <days>', 'Override retention days', parseInt)
  .option('--yes', 'Skip confirmation prompts')
  .option('--verbose', 'Show detailed information')
  .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
      await runCapsulePrune(logger, options);
      process.exit(0);
    } catch (error) {
      logger.error(`Command failed: ${error.message}`);
      process.exit(1);
    }
  });

capsule
  .command('export')
  .description('Export capsules to NDJSON file')
  .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
  .option('--capsule <id>', 'Export specific capsule by ID')
  .option('--kind <kind>', 'Export all capsules of a kind (pr, feature, aoi)')
  .option('--out <file>', 'Output file (default: stdout)')
  .option('--verbose', 'Show detailed information')
  .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
      await runCapsuleExport(logger, options);
      process.exit(0);
    } catch (error) {
      logger.error(`Command failed: ${error.message}`);
      process.exit(1);
    }
  });

capsule
  .command('import')
  .description('Import capsules from NDJSON file')
  .requiredOption('--file <file>', 'Input NDJSON file')
  .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
  .option('--overwrite', 'Overwrite existing capsules')
  .option('--verbose', 'Show detailed information')
  .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
      await runCapsuleImport(logger, options);
      process.exit(0);
    } catch (error) {
      logger.error(`Command failed: ${error.message}`);
      process.exit(1);
    }
  });

program.parse();
