#!/usr/bin/env node
/**
 * MLang CLI - Main Entry Point (Development Mode)
 *
 * This uses direct source imports via tsx for development.
 * For production, use the compiled bin/mlang.js
 */
import { Command } from 'commander';
import { runCapsulePrune, runCapsuleExport, runCapsuleImport } from './commands/capsule.js';
import { runDoctor } from './commands/doctor.js';
import { runInit } from './commands/init.js';
import { runRegistryHead, runRegistryGet, runRegistryVerify, runRegistryList } from './commands/registry.js';
import { runPolicyInit, runPolicyBuild, runPolicySign, runPolicyVerify, runKeysGenerate } from './commands/policy.js';
import { runEvaluate } from './commands/evaluate.js';
import { runPRReview } from './commands/pr.js';
import { runGateway } from './commands/gateway.js';
import { runWorkflowRun, runWorkflowStatus, runWorkflowList } from './commands/workflow.js';
import { runAOIGenerate, runAOICheck, runAOIActions, runAOIConfig } from './commands/aoi.js';
import { createLogger } from './utils/logger.js';
const program = new Command();
program
    .name('mlang')
    .description('MLang CLI - Policy compiler, PR governance, and developer tools')
    .version('0.1.0');
// Doctor command
program
    .command('doctor')
    .description('Check MLang environment and dependencies')
    .option('--ci', 'Run in CI mode (requires GITHUB_TOKEN)')
    .option('--verbose', 'Show detailed check information')
    .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
        const results = await runDoctor(logger, options);
        const failed = results.filter((r) => !r.passed && r.required).length;
        process.exit(failed > 0 ? 1 : 0);
    }
    catch (error) {
        logger.error(`Doctor failed: ${error.message}`);
        process.exit(1);
    }
});
// Init command
program
    .command('init')
    .description('Initialize MLang in the current project')
    .option('--force', 'Reinitialize even if .mlang directory exists')
    .option('--verbose', 'Show detailed initialization steps')
    .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
        await runInit(logger, options);
        process.exit(0);
    }
    catch (error) {
        logger.error(`Initialization failed: ${error.message}`);
        process.exit(1);
    }
});
// Evaluate command (M5)
program
    .command('evaluate')
    .description('Evaluate PR or local changes against policies')
    .option('--pr <number>', 'PR number (requires GitHub token)')
    .option('--file <file>', 'Load PR data from JSON file')
    .option('--policies <dir>', 'Policy directory (default: .mlang/policies)')
    .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
    .option('--format <format>', 'Output format: text or json', 'text')
    .option('--execute', 'Execute ActionPlan (requires GitHub token for real execution)')
    .option('--dry-run', 'Execute ActionPlan in dry-run mode (no actual API calls)')
    .option('--github-token <token>', 'GitHub token for execution (or use GITHUB_TOKEN env var)')
    .option('--verbose', 'Show detailed information')
    .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
        await runEvaluate(logger, options);
        // Exit code set by runEvaluate
    }
    catch (error) {
        logger.error(`Evaluation failed: ${error.message}`);
        process.exit(1);
    }
});
// PR commands (M7)
const pr = program
    .command('pr')
    .description('Pull request operations');
pr
    .command('review')
    .description('Review PR against policies (CI entrypoint)')
    .requiredOption('--pr <number>', 'PR number to review')
    .option('--repo <repo>', 'Repository (owner/repo) - auto-inferred if not provided')
    .option('--check-name <name>', 'GitHub check name', 'mdp-governance')
    .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
    .option('--emit-envelope <file>', 'Emit envelope JSON to file')
    .option('--dry-run', 'Skip action execution (evaluation only)')
    .option('--verbose', 'Show detailed information')
    .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
        await runPRReview(logger, options);
        // Exit code set by runPRReview
    }
    catch (error) {
        logger.error(`PR review failed: ${error.message}`);
        process.exit(1);
    }
});
// Policy commands (M4)
const policy = program
    .command('policy')
    .description('Policy compilation and management');
policy
    .command('init')
    .description('Initialize a new policy file')
    .requiredOption('--id <id>', 'Policy ID (e.g., eng.pr.review)')
    .requiredOption('--scope <scope>', 'Policy scope (e.g., pr/governance)')
    .requiredOption('--out <file>', 'Output file path')
    .option('--verbose', 'Show detailed information')
    .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
        await runPolicyInit(logger, options);
        process.exit(0);
    }
    catch (error) {
        logger.error(`Command failed: ${error.message}`);
        process.exit(1);
    }
});
policy
    .command('build')
    .description('Compile Markdown policies to unsigned PolicyCards')
    .requiredOption('--in <dir>', 'Input directory (policies/*.md)')
    .requiredOption('--out <dir>', 'Output directory for unsigned JSON')
    .option('--version <version>', 'Override version (default: YYYY.MM.DD)')
    .option('--strict', 'Fail on warnings')
    .option('--no-ai', 'Disable AI-powered constraint generation')
    .option('--verbose', 'Show detailed information')
    .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
        await runPolicyBuild(logger, options);
        process.exit(0);
    }
    catch (error) {
        logger.error(`Command failed: ${error.message}`);
        process.exit(1);
    }
});
policy
    .command('sign')
    .description('Sign compiled policies with ed25519')
    .requiredOption('--in <dir>', 'Input directory (unsigned JSON)')
    .requiredOption('--out <dir>', 'Output directory for signed JSON')
    .requiredOption('--key-file <file>', 'Private key file (ed25519)')
    .option('--verbose', 'Show detailed information')
    .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
        await runPolicySign(logger, options);
        process.exit(0);
    }
    catch (error) {
        logger.error(`Command failed: ${error.message}`);
        process.exit(1);
    }
});
policy
    .command('verify')
    .description('Verify signed policy signatures')
    .requiredOption('--in <path>', 'File or directory to verify')
    .option('--key-file <file>', 'Public key file (default: .mlang/keys/*.pub)')
    .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
    .option('--verbose', 'Show detailed information')
    .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
        await runPolicyVerify(logger, options);
        process.exit(0);
    }
    catch (error) {
        logger.error(`Command failed: ${error.message}`);
        process.exit(1);
    }
});
const keys = program
    .command('keys')
    .description('Signing key management');
keys
    .command('generate')
    .description('Generate ed25519 signing keypair')
    .requiredOption('--out <path>', 'Output path (will create .ed25519 and .pub files)')
    .option('--name <name>', 'Key name/identifier (for documentation)')
    .option('--verbose', 'Show detailed information')
    .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
        await runKeysGenerate(logger, options);
        process.exit(0);
    }
    catch (error) {
        logger.error(`Command failed: ${error.message}`);
        process.exit(1);
    }
});
// Registry commands (M2)
const registry = program
    .command('registry')
    .description('Policy registry operations');
registry
    .command('head <id>')
    .description('Show latest version on channel')
    .option('--channel <channel>', 'Channel name (stable, preview, dev)', 'stable')
    .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
    .option('--verbose', 'Show detailed information')
    .action(async (id, options) => {
    const logger = createLogger(options.verbose);
    try {
        await runRegistryHead(logger, id, options);
        process.exit(0);
    }
    catch (error) {
        logger.error(`Command failed: ${error.message}`);
        process.exit(1);
    }
});
registry
    .command('get <id>')
    .description('Fetch policy by ID')
    .option('--version <version>', 'Specific version (YYYY.MM.DD)')
    .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
    .option('--save <file>', 'Save policy to file')
    .option('--verbose', 'Show detailed information')
    .action(async (id, options) => {
    const logger = createLogger(options.verbose);
    try {
        await runRegistryGet(logger, id, options);
        process.exit(0);
    }
    catch (error) {
        logger.error(`Command failed: ${error.message}`);
        process.exit(1);
    }
});
registry
    .command('verify <file>')
    .description('Verify policy signature')
    .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
    .option('--verbose', 'Show detailed information')
    .action(async (file, options) => {
    const logger = createLogger(options.verbose);
    try {
        await runRegistryVerify(logger, file, options);
        process.exit(0);
    }
    catch (error) {
        logger.error(`Command failed: ${error.message}`);
        process.exit(1);
    }
});
registry
    .command('list [prefix]')
    .description('List all policies in registry')
    .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
    .option('--verbose', 'Show detailed information')
    .action(async (prefix, options) => {
    const logger = createLogger(options.verbose);
    try {
        await runRegistryList(logger, prefix, options);
        process.exit(0);
    }
    catch (error) {
        logger.error(`Command failed: ${error.message}`);
        process.exit(1);
    }
});
// Capsule commands (M3)
const capsule = program
    .command('capsule')
    .description('Capsule store operations (state management)');
capsule
    .command('prune')
    .description('Prune old capsules based on retention policy')
    .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
    .option('--apply', 'Actually delete capsules (default is dry-run)')
    .option('--keep-days <days>', 'Override retention days', parseInt)
    .option('--yes', 'Skip confirmation prompts')
    .option('--verbose', 'Show detailed information')
    .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
        await runCapsulePrune(logger, options);
        process.exit(0);
    }
    catch (error) {
        logger.error(`Command failed: ${error.message}`);
        process.exit(1);
    }
});
capsule
    .command('export')
    .description('Export capsules to NDJSON file')
    .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
    .option('--capsule <id>', 'Export specific capsule by ID')
    .option('--kind <kind>', 'Export all capsules of a kind (pr, feature, aoi)')
    .option('--out <file>', 'Output file (default: stdout)')
    .option('--verbose', 'Show detailed information')
    .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
        await runCapsuleExport(logger, options);
        process.exit(0);
    }
    catch (error) {
        logger.error(`Command failed: ${error.message}`);
        process.exit(1);
    }
});
capsule
    .command('import')
    .description('Import capsules from NDJSON file')
    .requiredOption('--file <file>', 'Input NDJSON file')
    .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
    .option('--overwrite', 'Overwrite existing capsules')
    .option('--verbose', 'Show detailed information')
    .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
        await runCapsuleImport(logger, options);
        process.exit(0);
    }
    catch (error) {
        logger.error(`Command failed: ${error.message}`);
        process.exit(1);
    }
});
// Gateway command (Stream 3 - MCP Server)
program
    .command('gateway')
    .description('Run gateway in MCP server mode (for Claude Code, Cursor, etc.)')
    .option('--mode <mode>', 'Gateway mode (only "mcp" supported)', 'mcp')
    .option('--stdio', 'Use stdio transport (default)')
    .option('--http', 'Use HTTP transport')
    .option('--port <port>', 'HTTP port (default: 8080)', parseInt)
    .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
    .option('--verbose', 'Show detailed information')
    .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
        await runGateway(logger, options);
        // Server runs indefinitely until killed
    }
    catch (error) {
        logger.error(`Gateway failed: ${error.message}`);
        process.exit(1);
    }
});
// Workflow commands (Stream 6 - Multi-Agent Workflows)
const workflow = program
    .command('workflow')
    .description('Multi-agent workflow operations');
workflow
    .command('run')
    .description('Run multi-agent workflow on a capsule')
    .option('--capsule <id>', 'Capsule ID to run workflow on')
    .option('--workflow <name>', 'Workflow definition name (from .mlang/workflows/)')
    .option('--agents <agents>', 'Comma-separated agent names (e.g., pm,architect,engineer)')
    .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
    .option('--json', 'Output as JSON')
    .option('--verbose', 'Show detailed information')
    .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
        await runWorkflowRun(logger, options);
        // Exit code set by runWorkflowRun
    }
    catch (error) {
        logger.error(`Workflow run failed: ${error.message}`);
        process.exit(1);
    }
});
workflow
    .command('status')
    .description('Show workflow status for a capsule')
    .requiredOption('--capsule <id>', 'Capsule ID')
    .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
    .option('--json', 'Output as JSON')
    .option('--verbose', 'Show detailed information')
    .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
        await runWorkflowStatus(logger, options);
        process.exit(0);
    }
    catch (error) {
        logger.error(`Workflow status failed: ${error.message}`);
        process.exit(1);
    }
});
workflow
    .command('list')
    .description('List available workflow definitions')
    .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
    .option('--json', 'Output as JSON')
    .option('--verbose', 'Show detailed information')
    .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
        await runWorkflowList(logger, options);
        process.exit(0);
    }
    catch (error) {
        logger.error(`Workflow list failed: ${error.message}`);
        process.exit(1);
    }
});
// AOI commands (Stream 6 - Architecture of Intent)
const aoi = program
    .command('aoi')
    .description('Architecture of Intent (AOI) operations');
aoi
    .command('generate')
    .description('Manually trigger AOI spec generation')
    .requiredOption('--pr <file>', 'PR data file (JSON)')
    .option('--policy <id>', 'Policy ID (defaults to first AOI-enabled policy)')
    .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
    .option('--json', 'Output as JSON')
    .option('--verbose', 'Show detailed information')
    .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
        await runAOIGenerate(logger, options);
        process.exit(0);
    }
    catch (error) {
        logger.error(`AOI generation failed: ${error.message}`);
        process.exit(1);
    }
});
aoi
    .command('check')
    .description('Check if a component exists via similarity search')
    .requiredOption('--component <query>', 'Component name or description')
    .option('--framework <repo>', 'Framework repository')
    .option('--threshold <number>', 'Similarity threshold (0.0-1.0)', parseFloat)
    .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
    .option('--json', 'Output as JSON')
    .option('--verbose', 'Show detailed information')
    .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
        await runAOICheck(logger, options);
        process.exit(0);
    }
    catch (error) {
        logger.error(`AOI check failed: ${error.message}`);
        process.exit(1);
    }
});
aoi
    .command('actions')
    .description('List pending AOI actions')
    .option('--pr <number>', 'Filter by PR number')
    .option('--status <status>', 'Filter by status (pending, completed, failed)')
    .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
    .option('--json', 'Output as JSON')
    .option('--verbose', 'Show detailed information')
    .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
        await runAOIActions(logger, options);
        process.exit(0);
    }
    catch (error) {
        logger.error(`AOI actions failed: ${error.message}`);
        process.exit(1);
    }
});
aoi
    .command('config')
    .description('Show AOI configuration')
    .option('--base-path <path>', 'Base path to .mlang directory', '.mlang')
    .option('--json', 'Output as JSON')
    .option('--verbose', 'Show detailed information')
    .action(async (options) => {
    const logger = createLogger(options.verbose);
    try {
        await runAOIConfig(logger, options);
        process.exit(0);
    }
    catch (error) {
        logger.error(`AOI config failed: ${error.message}`);
        process.exit(1);
    }
});
program.parse();
//# sourceMappingURL=cli.js.map