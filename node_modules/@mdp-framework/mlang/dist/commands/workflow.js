/**
 * Workflow Commands - Multi-agent workflow orchestration
 *
 * Stream 6: CLI AI Commands
 * See: Docs/contracts/STREAM-6-CLI-AI-COMMANDS.md
 */
// @ts-nocheck - Type mismatches between package versions, will be resolved in integration
import { existsSync, readdirSync, readFileSync } from 'fs';
import { join } from 'path';
import { SequentialAgentWorkflow, PMAgent, ArchitectAgent, EngineerAgent, DesignerAgent, } from '@mdp-framework/agents';
import { createCapsuleStore } from '@mdp-framework/gateway/store';
import chalk from 'chalk';
// Mock createAIProvider for now (would come from ai-services)
function createAIProvider() {
    return {
        complete: async () => ({ text: 'mock response' }),
        embed: async () => [0.1, 0.2, 0.3],
    };
}
/**
 * Run a multi-agent workflow
 */
export async function runWorkflowRun(logger, options) {
    const basePath = options.basePath || '.mlang';
    // Validate input
    if (!options.capsule && !options.workflow) {
        throw new Error('Must specify either --capsule or --workflow');
    }
    // Initialize capsule store
    const storePath = join(basePath, 'state', 'capsules');
    if (!existsSync(storePath)) {
        throw new Error(`Capsule store not found: ${storePath}. Run 'mlang init' first.`);
    }
    const store = await createCapsuleStore({
        backend: 'file',
        baseDir: storePath,
    });
    try {
        // Load capsule
        let capsule;
        if (options.capsule) {
            const result = await store.get(options.capsule);
            if (!result.ok) {
                throw new Error(`Capsule not found: ${options.capsule}`);
            }
            capsule = result.data;
        }
        else {
            throw new Error('Capsule loading not yet implemented for --workflow');
        }
        logger.info(`Running workflow for capsule: ${capsule.id}`);
        // Load workflow definition or use default agents
        let agents;
        if (options.workflow) {
            // Load workflow from .mlang/workflows/<name>.json
            const workflowPath = join(basePath, 'workflows', `${options.workflow}.json`);
            if (!existsSync(workflowPath)) {
                throw new Error(`Workflow not found: ${workflowPath}`);
            }
            const workflowDef = JSON.parse(readFileSync(workflowPath, 'utf-8'));
            agents = await createAgentsFromDefinition(workflowDef);
            logger.info(`Loaded workflow: ${workflowDef.name}`);
        }
        else if (options.agents) {
            // Parse agent names from command line
            const agentNames = options.agents.split(',').map((a) => a.trim());
            agents = await createAgentsFromNames(agentNames);
        }
        else {
            // Default: PM → Architect → Engineer
            agents = await createAgentsFromNames(['pm', 'architect', 'engineer']);
        }
        logger.info(`Agents: ${agents.map((a) => a.name).join(' → ')}`);
        // Create workflow
        const workflow = new SequentialAgentWorkflow();
        // Execute workflow
        const startTime = Date.now();
        logger.info('Starting workflow execution...');
        const result = await workflow.execute(capsule, agents);
        // Save updated capsule
        await store.put(capsule);
        // Output result
        if (options.json) {
            console.log(JSON.stringify(result, null, 2));
        }
        else {
            printWorkflowResult(logger, result, options.verbose || false);
        }
        // Exit with error code if workflow failed
        if (result.status === 'failed') {
            process.exitCode = 1;
        }
    }
    finally {
        await store.close();
    }
}
/**
 * Show workflow status
 */
export async function runWorkflowStatus(logger, options) {
    const basePath = options.basePath || '.mlang';
    if (!options.capsule) {
        throw new Error('Must specify --capsule');
    }
    // Initialize capsule store
    const storePath = join(basePath, 'state', 'capsules');
    const store = await createCapsuleStore({
        backend: 'file',
        baseDir: storePath,
    });
    try {
        // Load capsule
        const result = await store.get(options.capsule);
        if (!result.ok) {
            throw new Error(`Capsule not found: ${options.capsule}`);
        }
        const capsule = result.data;
        // Get workflow status from capsule metadata
        const status = {
            state: capsule.metadata?.workflow_status || 'idle',
            currentAgent: capsule.metadata?.current_agent,
            agentsCompleted: capsule.metadata?.agents_completed || [],
            startTime: capsule.metadata?.workflow_start_time,
            endTime: capsule.metadata?.workflow_end_time,
        };
        // Output status
        if (options.json) {
            console.log(JSON.stringify(status, null, 2));
        }
        else {
            printWorkflowStatus(logger, capsule, status, options.verbose || false);
        }
    }
    finally {
        await store.close();
    }
}
/**
 * List available workflows
 */
export async function runWorkflowList(logger, options) {
    const basePath = options.basePath || '.mlang';
    const workflowsPath = join(basePath, 'workflows');
    if (!existsSync(workflowsPath)) {
        logger.warn('No workflows directory found. Create workflows in .mlang/workflows/');
        return;
    }
    // Load all workflow files
    const files = readdirSync(workflowsPath).filter((f) => f.endsWith('.json'));
    if (files.length === 0) {
        logger.info('No workflows found.');
        return;
    }
    const workflows = [];
    for (const file of files) {
        try {
            const content = readFileSync(join(workflowsPath, file), 'utf-8');
            const workflow = JSON.parse(content);
            workflows.push({
                ...workflow,
                filename: file.replace('.json', ''),
            });
        }
        catch (error) {
            logger.warn(`Failed to load workflow ${file}: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    // Output workflows
    if (options.json) {
        console.log(JSON.stringify(workflows, null, 2));
    }
    else {
        logger.info(`Found ${workflows.length} workflow(s):\n`);
        for (const workflow of workflows) {
            console.log(chalk.bold(workflow.filename));
            console.log(`  ${workflow.description}`);
            console.log(`  Agents: ${workflow.agents.map((a) => a.type).join(' → ')}`);
            console.log();
        }
    }
}
// ============================================================================
// Helper Functions
// ============================================================================
/**
 * Create agents from workflow definition
 */
async function createAgentsFromDefinition(workflow) {
    const agents = [];
    const aiProvider = createAIProvider();
    for (const agentDef of workflow.agents) {
        const agent = await createAgent(agentDef.type, agentDef.config || {}, aiProvider);
        agents.push(agent);
    }
    return agents;
}
/**
 * Create agents from names
 */
async function createAgentsFromNames(names) {
    const agents = [];
    const aiProvider = createAIProvider();
    for (const name of names) {
        const agent = await createAgent(name, {}, aiProvider);
        agents.push(agent);
    }
    return agents;
}
/**
 * Create agent by type
 */
async function createAgent(type, config, aiProvider) {
    switch (type) {
        case 'pm':
            return new PMAgent({ aiProvider, ...config });
        case 'architect':
            return new ArchitectAgent({ aiProvider, ...config });
        case 'engineer':
            return new EngineerAgent({ aiProvider, ...config });
        case 'designer':
            return new DesignerAgent({ aiProvider, ...config });
        default:
            throw new Error(`Unknown agent type: ${type}`);
    }
}
/**
 * Print workflow result (human-readable)
 */
function printWorkflowResult(logger, result, verbose) {
    const statusIcon = result.status === 'success' ? '✓' : '✗';
    const statusColor = result.status === 'success' ? chalk.green : chalk.red;
    console.log();
    console.log(statusColor(`${statusIcon} Workflow: ${result.status.toUpperCase()}`));
    console.log();
    console.log(chalk.bold('Summary:'));
    console.log(`  Capsule: ${result.capsule_id}`);
    console.log(`  Agents: ${result.agents_invoked.join(' → ')}`);
    console.log(`  Time: ${(result.execution_time_ms / 1000).toFixed(1)}s`);
    console.log();
    if (result.error) {
        console.log(chalk.red.bold('Error:'));
        console.log(`  Agent: ${result.error.agent}`);
        console.log(`  Message: ${result.error.message}`);
        console.log(`  Recoverable: ${result.error.recoverable ? 'Yes' : 'No'}`);
        console.log();
    }
    if (result.final_decisions.length > 0) {
        console.log(chalk.bold(`Decisions (${result.final_decisions.length}):`));
        result.final_decisions.forEach((d, i) => {
            console.log(`  ${i + 1}. ${chalk.cyan(d.question)}`);
            console.log(`     ${d.answer}`);
            if (verbose && d.reasoning) {
                console.log(chalk.dim(`     → ${d.reasoning}`));
            }
            if (d.confidence !== undefined) {
                const confidenceColor = d.confidence >= 0.8 ? chalk.green : d.confidence >= 0.5 ? chalk.yellow : chalk.red;
                console.log(confidenceColor(`     Confidence: ${(d.confidence * 100).toFixed(0)}%`));
            }
        });
        console.log();
    }
    if (result.handoffs.length > 0) {
        console.log(chalk.bold(`Handoffs (${result.handoffs.length}):`));
        result.handoffs.forEach((h, i) => {
            console.log(`  ${i + 1}. ${h.from} → ${h.to}`);
            if (verbose) {
                console.log(chalk.dim(`     ${h.context_summary}`));
            }
        });
        console.log();
    }
}
/**
 * Print workflow status (human-readable)
 */
function printWorkflowStatus(logger, capsule, status, verbose) {
    const stateIcon = status.state === 'completed'
        ? '✓'
        : status.state === 'failed'
            ? '✗'
            : status.state === 'running'
                ? '⚙'
                : '○';
    const stateColor = status.state === 'completed'
        ? chalk.green
        : status.state === 'failed'
            ? chalk.red
            : status.state === 'running'
                ? chalk.yellow
                : chalk.gray;
    console.log();
    console.log(stateColor(`${stateIcon} Workflow Status: ${status.state.toUpperCase()}`));
    console.log();
    console.log(chalk.bold('Capsule:'));
    console.log(`  ID: ${capsule.id}`);
    console.log(`  Kind: ${capsule.kind}`);
    console.log(`  Version: ${capsule.version}`);
    console.log();
    if (status.currentAgent) {
        console.log(chalk.bold('Current Agent:'));
        console.log(`  ${status.currentAgent}`);
        console.log();
    }
    if (status.agentsCompleted.length > 0) {
        console.log(chalk.bold('Completed Agents:'));
        status.agentsCompleted.forEach((agent, i) => {
            console.log(`  ${i + 1}. ${agent}`);
        });
        console.log();
    }
    if (capsule.decisions && capsule.decisions.length > 0) {
        console.log(chalk.bold(`Decisions (${capsule.decisions.length}):`));
        capsule.decisions.forEach((d, i) => {
            console.log(`  ${i + 1}. ${chalk.cyan(d.question)}`);
            console.log(`     ${d.answer}`);
            if (verbose) {
                console.log(chalk.dim(`     Source: ${d.source}`));
                console.log(chalk.dim(`     Time: ${d.timestamp}`));
            }
        });
        console.log();
    }
    if (status.startTime) {
        const elapsed = status.endTime
            ? status.endTime - status.startTime
            : Date.now() - status.startTime;
        console.log(chalk.bold('Timing:'));
        console.log(`  Started: ${new Date(status.startTime).toISOString()}`);
        if (status.endTime) {
            console.log(`  Ended: ${new Date(status.endTime).toISOString()}`);
        }
        console.log(`  Elapsed: ${(elapsed / 1000).toFixed(1)}s`);
        console.log();
    }
}
//# sourceMappingURL=workflow.js.map