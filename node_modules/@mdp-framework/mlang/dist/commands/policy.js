/**
 * Policy CLI Commands - init, build, sign, verify
 *
 * Implements Build Step 10 policy authoring and compilation flow.
 */
import { mkdir, readFile, readdir, writeFile } from 'node:fs/promises';
import { join, basename, dirname } from 'node:path';
import { existsSync } from 'node:fs';
import chalk from 'chalk';
import ora from 'ora';
import dotenv from 'dotenv';
import { parsePolicyDir } from '../compiler/parser.js';
import { compilePolicies, generateDefaultVersion, canonicalizeCard } from '../compiler/compiler.js';
import { signPolicy, verifyPolicy, generateKeyPair, saveKeyPair } from '../compiler/signer.js';
import { generateConstraints } from '../compiler/constraint-generator.js';
import { AnthropicProvider } from '@mdp-framework/ai-services';
/**
 * Initialize a new policy file with scaffold
 */
export async function runPolicyInit(logger, options) {
    const spinner = ora('Creating policy scaffold...').start();
    try {
        // Validate ID format
        if (!options.id.includes('.')) {
            spinner.fail('Invalid ID format');
            logger.error('Policy ID must be namespaced (e.g., eng.pr.review)');
            throw new Error('Invalid policy ID');
        }
        // Check if file exists
        if (existsSync(options.out)) {
            spinner.fail('File already exists');
            logger.error(`Policy file already exists: ${options.out}`);
            throw new Error('File exists');
        }
        // Create directory if needed
        const dir = dirname(options.out);
        if (!existsSync(dir)) {
            await mkdir(dir, { recursive: true });
        }
        // Generate scaffold
        const scaffold = generatePolicyScaffold(options.id, options.scope);
        // Write file
        await writeFile(options.out, scaffold, 'utf-8');
        spinner.succeed(chalk.green(`Created policy: ${options.out}`));
        logger.info(`Edit the file to add constraints and documentation.`);
    }
    catch (error) {
        spinner.fail('Failed to create policy');
        throw error;
    }
}
/**
 * Build policies from Markdown to unsigned JSON
 */
export async function runPolicyBuild(logger, options) {
    const spinner = ora('Building policies...').start();
    try {
        // Determine input directory with smart defaults
        const basePath = options.basePath || '.mlang';
        const channel = options.channel || 'stable';
        let inputDir = options.in;
        if (!inputDir) {
            // Try default locations in order
            const candidates = [
                'policies', // Convention: simple policies/ folder
                `.mlang/packs/${channel}`, // Legacy: directly in packs
                `${basePath}/packs/${channel}` // With custom basePath
            ];
            for (const candidate of candidates) {
                if (existsSync(candidate)) {
                    inputDir = candidate;
                    break;
                }
            }
            if (!inputDir) {
                spinner.fail('No policy source directory found');
                logger.error('No policy source found. Create a policies/ folder or specify --in <dir>');
                throw new Error('No policy source directory');
            }
        }
        // Determine output directory with smart defaults
        let outputDir = options.out;
        if (!outputDir) {
            // Default: .mlang/packs/<channel>
            outputDir = `${basePath}/packs/${channel}`;
        }
        spinner.text = `Building from ${inputDir} â†’ ${outputDir}`;
        // Parse all policies
        const { policies, errors: parseErrors } = await parsePolicyDir(inputDir);
        if (parseErrors.length > 0) {
            spinner.fail('Parse errors');
            for (const err of parseErrors) {
                logger.error(`${err.file}: ${err.error}`);
            }
            throw new Error('Failed to parse policies');
        }
        spinner.text = `Compiling ${policies.length} policies...`;
        // Compile policies
        const { compiled, errors: compileErrors } = compilePolicies(policies, {
            version: options.version,
            strict: options.strict,
        });
        if (compileErrors.length > 0) {
            spinner.fail('Compilation errors');
            for (const err of compileErrors) {
                logger.error(`${err.file}: [${err.code}] ${err.error}`);
            }
            throw new Error('Failed to compile policies');
        }
        // Create output directory
        if (!existsSync(outputDir)) {
            await mkdir(outputDir, { recursive: true });
        }
        // AI Enhancement (unless --no-ai flag is set)
        const aiProvider = options.noAi ? null : await initializeAIProvider(basePath, logger, options.verbose);
        // Write compiled cards
        let written = 0;
        let aiEnhanced = 0;
        for (const result of compiled) {
            const filename = `${result.card.id}.json`;
            const outPath = join(outputDir, filename);
            let finalCard = { ...result.card };
            // Try AI enhancement if provider available and violation_check_prompt not present
            // This allows merging AI-generated prompts with manual constraints from YAML
            const constraints = finalCard.constraints;
            const needsAiEnhancement = aiProvider && !constraints?.violation_check_prompt;
            if (options.verbose) {
                logger.info(`ðŸ” ${filename}: constraints=${!!constraints}, violation_check_prompt=${!!constraints?.violation_check_prompt}, needsAi=${needsAiEnhancement}`);
            }
            if (needsAiEnhancement) {
                spinner.text = `Enhancing ${filename} with AI...`;
                try {
                    const constraintResult = await generateConstraints({
                        provider: aiProvider,
                        policyId: result.card.id,
                        detectionSection: result.structuredSections?.detection,
                        markdownBody: result.body,
                    });
                    if (constraintResult.constraints && constraintResult.confidence >= 0.7) {
                        // Merge AI constraints with existing constraints (AI takes precedence for optimization fields)
                        finalCard.constraints = {
                            ...finalCard.constraints,
                            ...constraintResult.constraints,
                        };
                        aiEnhanced++;
                        if (options.verbose) {
                            logger.info(`âœ¨ Enhanced ${filename} (confidence: ${constraintResult.confidence.toFixed(2)}, cost: $${constraintResult.costUsd.toFixed(4)})`);
                        }
                    }
                    else if (constraintResult.error) {
                        if (options.verbose) {
                            logger.warn(`âš ï¸  ${filename}: AI enhancement failed - ${constraintResult.error}`);
                        }
                    }
                }
                catch (error) {
                    if (options.verbose) {
                        logger.warn(`âš ï¸  ${filename}: AI enhancement error - ${error instanceof Error ? error.message : String(error)}`);
                    }
                }
            }
            // Add metadata fields
            const cardWithMetadata = {
                ...finalCard,
                _sourceMarkdown: result.body,
                _structuredSections: result.structuredSections,
            };
            // Canonicalize for stable output
            const canonical = canonicalizeCard(cardWithMetadata);
            await writeFile(outPath, JSON.stringify(canonical, null, 2), 'utf-8');
            written++;
            if (result.warnings.length > 0 && options.verbose) {
                logger.warn(`${filename}: ${result.warnings.join(', ')}`);
            }
        }
        let message = `Built ${written} policies â†’ ${outputDir}`;
        if (aiEnhanced > 0) {
            message += ` (${aiEnhanced} AI-enhanced)`;
        }
        spinner.succeed(chalk.green(message));
        if (options.verbose) {
            logger.info(`Channel: ${channel}`);
            logger.info(`Version: ${options.version || generateDefaultVersion()}`);
            if (aiProvider) {
                logger.info(`AI Provider: ${aiProvider.name}`);
            }
        }
    }
    catch (error) {
        spinner.fail('Build failed');
        throw error;
    }
}
/**
 * Sign compiled policies with ed25519
 */
export async function runPolicySign(logger, options) {
    const spinner = ora('Signing policies...').start();
    try {
        // Validate key file exists
        if (!existsSync(options.keyFile)) {
            spinner.fail('Key file not found');
            logger.error(`Private key not found: ${options.keyFile}`);
            throw new Error('Key file not found');
        }
        // Read all JSON files from input directory
        const entries = await readdir(options.in);
        const jsonFiles = entries.filter((f) => f.endsWith('.json'));
        if (jsonFiles.length === 0) {
            spinner.fail('No policies found');
            logger.error(`No JSON policies found in ${options.in}`);
            throw new Error('No policies to sign');
        }
        spinner.text = `Signing ${jsonFiles.length} policies...`;
        // Create output directory
        if (!existsSync(options.out)) {
            await mkdir(options.out, { recursive: true });
        }
        // Sign each policy
        let signed = 0;
        for (const file of jsonFiles) {
            const inPath = join(options.in, file);
            const outPath = join(options.out, file);
            const content = await readFile(inPath, 'utf-8');
            const card = JSON.parse(content);
            // Sign
            const signedCard = await signPolicy(card, { keyFile: options.keyFile });
            // Write signed card
            await writeFile(outPath, JSON.stringify(signedCard, null, 2), 'utf-8');
            signed++;
        }
        spinner.succeed(chalk.green(`Signed ${signed} policies â†’ ${options.out}`));
    }
    catch (error) {
        spinner.fail('Signing failed');
        throw error;
    }
}
/**
 * Verify signed policies
 */
export async function runPolicyVerify(logger, options) {
    const spinner = ora('Verifying policies...').start();
    try {
        // Determine input (file or directory)
        const isDirectory = !options.in.endsWith('.json');
        const files = isDirectory
            ? (await readdir(options.in)).filter((f) => f.endsWith('.json')).map((f) => join(options.in, f))
            : [options.in];
        if (files.length === 0) {
            spinner.fail('No policies found');
            throw new Error('No policies to verify');
        }
        spinner.text = `Verifying ${files.length} policies...`;
        // Find public key
        const keyFile = options.keyFile || (await findPublicKey(options.basePath || '.mlang'));
        if (!keyFile) {
            spinner.fail('No public key found');
            logger.error('No public key found. Specify --key-file or add keys to .mlang/keys/');
            throw new Error('No public key');
        }
        // Verify each policy
        let verified = 0;
        let failed = 0;
        for (const file of files) {
            const content = await readFile(file, 'utf-8');
            const card = JSON.parse(content);
            const result = await verifyPolicy(card, { keyFile });
            if (result.ok) {
                verified++;
                if (options.verbose) {
                    logger.success(`âœ“ ${basename(file)}: ${card.id}@${card.version}`);
                }
            }
            else {
                failed++;
                logger.error(`âœ— ${basename(file)}: ${result.error}`);
            }
        }
        if (failed > 0) {
            spinner.fail(chalk.red(`Verification failed: ${failed} invalid`));
            throw new Error('Verification failed');
        }
        spinner.succeed(chalk.green(`Verified ${verified} policies`));
    }
    catch (error) {
        spinner.fail('Verification failed');
        throw error;
    }
}
/**
 * Generate ed25519 keypair
 */
export async function runKeysGenerate(logger, options) {
    const spinner = ora('Generating ed25519 keypair...').start();
    try {
        // Check if files exist
        const privateKeyPath = `${options.out}.ed25519`;
        const publicKeyPath = `${options.out}.pub`;
        if (existsSync(privateKeyPath) || existsSync(publicKeyPath)) {
            spinner.fail('Key files already exist');
            logger.error('Key files already exist. Remove them first or use a different name.');
            throw new Error('Key files exist');
        }
        // Create directory if needed
        const dir = dirname(options.out);
        if (!existsSync(dir)) {
            await mkdir(dir, { recursive: true });
        }
        // Generate keypair
        const { privateKey, publicKey } = await generateKeyPair();
        // Save keys
        await saveKeyPair(privateKey, publicKey, options.out);
        spinner.succeed(chalk.green('Generated keypair'));
        logger.info(`Private key: ${privateKeyPath} (mode 0600)`);
        logger.info(`Public key:  ${publicKeyPath} (mode 0644)`);
        logger.warn('Keep private key secure! Add to .gitignore');
        if (options.verbose) {
            const pubHex = Buffer.from(publicKey).toString('hex');
            logger.info(`Public key (hex): ${pubHex}`);
        }
    }
    catch (error) {
        spinner.fail('Key generation failed');
        throw error;
    }
}
/**
 * Generate policy scaffold Markdown
 */
function generatePolicyScaffold(id, scope) {
    return `---
id: ${id}
scope: ${scope}
role: reviewer
title: ${id} policy
description: Brief description of what this policy enforces
tags:
  - governance
  - pr

# Optional: constraints define the policy rules
# constraints:
#   require_description: true
#   max_file_count: 50

# Optional: default actions when this policy is violated
# on_violation:
#   - action: comment
#     message: "This PR violates policy ${id}"
#   - action: warn
---

# ${id}

## Overview

Describe what this policy enforces and why it matters.

## Rationale

Explain the reasoning behind this policy.

## Examples

### Passes

Describe scenarios that pass this policy.

### Violates

Describe scenarios that violate this policy.

## Related Policies

- Link to related policies if any
`;
}
/**
 * Initialize AI provider from environment config
 */
async function initializeAIProvider(basePath, logger, verbose) {
    try {
        // Load .env from .mlang/.env
        const envPath = join(basePath, '.env');
        if (existsSync(envPath)) {
            dotenv.config({ path: envPath });
        }
        // Check for Anthropic API key (primary provider for now)
        const apiKey = process.env.ANTHROPIC_API_KEY;
        if (!apiKey) {
            if (verbose) {
                logger.warn('âš ï¸  No ANTHROPIC_API_KEY found in .mlang/.env - skipping AI enhancement');
                logger.info('   Add ANTHROPIC_API_KEY to .mlang/.env to enable AI-powered constraint generation');
            }
            return null;
        }
        // Initialize Anthropic provider
        const provider = new AnthropicProvider({
            apiKey,
            defaultModel: 'claude-sonnet-4-5-20250929',
        });
        if (verbose) {
            logger.info('âœ“ AI provider initialized: Anthropic');
        }
        return provider;
    }
    catch (error) {
        if (verbose) {
            logger.warn(`âš ï¸  Failed to initialize AI provider: ${error instanceof Error ? error.message : String(error)}`);
        }
        return null;
    }
}
/**
 * Find public key in .mlang/keys/ directory
 */
async function findPublicKey(basePath) {
    const keysDir = join(basePath, 'keys');
    if (!existsSync(keysDir)) {
        return null;
    }
    const entries = await readdir(keysDir);
    const pubKeys = entries.filter((f) => f.endsWith('.pub'));
    if (pubKeys.length === 0) {
        return null;
    }
    // Return first public key found
    return join(keysDir, pubKeys[0]);
}
//# sourceMappingURL=policy.js.map