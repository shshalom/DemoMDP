// GitHub integration commands - workflow generation, setup automation
// Implements policy-driven CI/CD configuration
import { mkdirSync, readFileSync, writeFileSync, existsSync, readdirSync } from 'fs';
import { resolve, join, dirname } from 'path';
import chalk from 'chalk';
import ora from 'ora';
/**
 * Main command: Initialize GitHub Actions workflow from policies
 */
export async function runGithubInit(logger, options) {
    const spinner = ora('Analyzing policies...').start();
    try {
        // Step 1: Find and analyze policies
        const packPath = resolve(process.cwd(), '.mlang/packs/stable');
        if (!existsSync(packPath)) {
            spinner.fail('No compiled policies found');
            logger.error(`Policy pack directory not found: ${packPath}`);
            logger.info('Run "mlang policy build" to compile your policies first');
            process.exit(1);
        }
        spinner.text = 'Analyzing policies...';
        const analysis = analyzePolicies(packPath, logger);
        if (analysis.policyCount === 0) {
            spinner.fail('No policies found');
            logger.error('No policy files found in .mlang/packs/stable/');
            logger.info('Create policies using "mlang policy init" and compile with "mlang policy build"');
            process.exit(1);
        }
        spinner.succeed(`Found ${analysis.policyCount} ${analysis.policyCount === 1 ? 'policy' : 'policies'}`);
        // Step 2: Display analysis
        displayAnalysis(logger, analysis);
        // Step 3: Generate workflow file
        spinner.start('Generating GitHub Actions workflow...');
        const outputDir = options.output || '.github/workflows';
        const workflowPath = resolve(process.cwd(), outputDir, 'mdp-governance.yml');
        const setupDocsPath = resolve(process.cwd(), '.github', 'MDP-SETUP.md');
        const workflow = generateWorkflow(analysis);
        const setupDocs = generateSetupDocs(analysis);
        if (options.dryRun) {
            spinner.succeed('Dry run - showing generated files');
            logger.info('\n' + chalk.bold('=== Generated Workflow ==='));
            console.log(chalk.gray(workflow));
            logger.info('\n' + chalk.bold('=== Generated Setup Docs ==='));
            console.log(chalk.gray(setupDocs));
            return;
        }
        // Step 4: Write files
        spinner.text = 'Writing files...';
        mkdirSync(dirname(workflowPath), { recursive: true });
        mkdirSync(dirname(setupDocsPath), { recursive: true });
        writeFileSync(workflowPath, workflow, 'utf-8');
        writeFileSync(setupDocsPath, setupDocs, 'utf-8');
        spinner.succeed('GitHub Actions workflow created');
        // Step 5: Success message with next steps
        logger.success('\n‚úì GitHub Actions workflow generated successfully!\n');
        logger.info(chalk.bold('Files created:'));
        logger.info(`  ${chalk.cyan(workflowPath)}`);
        logger.info(`  ${chalk.cyan(setupDocsPath)}\n`);
        logger.info(chalk.bold('Next steps:'));
        logger.info('  1. Review the generated workflow file');
        logger.info('  2. Configure required secrets in GitHub:');
        analysis.requiredSecrets.forEach((secret) => {
            logger.info(`     - ${chalk.yellow(secret)}`);
        });
        logger.info('  3. Commit and push to your repository');
        logger.info('  4. Create a test PR to verify the workflow\n');
        logger.info(chalk.dim('See .github/MDP-SETUP.md for detailed setup instructions'));
    }
    catch (error) {
        spinner.fail('Failed to generate workflow');
        throw error;
    }
}
/**
 * Analyze all policies in the pack directory
 */
function analyzePolicies(packPath, logger) {
    const files = readdirSync(packPath).filter((f) => f.endsWith('.json'));
    const policies = [];
    for (const file of files) {
        try {
            const content = readFileSync(join(packPath, file), 'utf-8');
            const policy = JSON.parse(content);
            policies.push(policy);
        }
        catch (error) {
            logger.warn(`Failed to parse policy file ${file}: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
    // Analyze requirements
    const requiresAI = policies.some((p) => p.constraints?.violation_check_prompt || p.constraints?.ai_powered);
    const filePatterns = extractFilePatterns(policies);
    const requiredSecrets = ['GITHUB_TOKEN']; // Always required
    if (requiresAI) {
        requiredSecrets.push('ANTHROPIC_API_KEY');
    }
    const estimatedCostPerPR = calculateEstimatedCost(policies);
    const aoiEnabled = policies.some((p) => p.constraints?.aoi_feedback_enabled);
    return {
        policies,
        requiresAI,
        filePatterns,
        requiredSecrets,
        estimatedCostPerPR,
        aoiEnabled,
        policyCount: policies.length,
    };
}
/**
 * Extract unique file patterns from all policies
 */
function extractFilePatterns(policies) {
    const patterns = new Set();
    for (const policy of policies) {
        const fileTypes = policy.constraints?.file_types;
        if (Array.isArray(fileTypes)) {
            fileTypes.forEach((ext) => {
                // Convert .swift to **.swift, etc.
                const pattern = ext.startsWith('.') ? `**${ext}` : `**.${ext}`;
                patterns.add(pattern);
            });
        }
    }
    return Array.from(patterns).sort();
}
/**
 * Calculate estimated cost per PR based on policies
 */
function calculateEstimatedCost(policies) {
    // Rough estimation:
    // - AI-powered policies: ~$0.02-0.05 per evaluation
    // - Static policies: negligible cost
    const aiPolicies = policies.filter((p) => p.constraints?.violation_check_prompt || p.constraints?.ai_powered);
    // Base cost: $0.02 per AI policy
    // Complex policies (with AOI): +$0.01
    let cost = 0;
    for (const policy of aiPolicies) {
        cost += 0.02;
        if (policy.constraints?.aoi_feedback_enabled) {
            cost += 0.01;
        }
    }
    return Math.round(cost * 100) / 100; // Round to 2 decimals
}
/**
 * Display policy analysis summary
 */
function displayAnalysis(logger, analysis) {
    logger.info('\n' + chalk.bold('Policy Analysis:'));
    analysis.policies.forEach((policy) => {
        const aiTag = policy.constraints?.violation_check_prompt ? chalk.yellow('[AI]') : '';
        const aoiTag = policy.constraints?.aoi_feedback_enabled ? chalk.blue('[AOI]') : '';
        logger.info(`  ‚Ä¢ ${policy.id} ${aiTag} ${aoiTag}`);
    });
    logger.info('\n' + chalk.bold('Configuration:'));
    logger.info(`  AI Evaluation: ${analysis.requiresAI ? chalk.green('Yes') : chalk.gray('No')}`);
    logger.info(`  AOI Feedback: ${analysis.aoiEnabled ? chalk.green('Enabled') : chalk.gray('Disabled')}`);
    logger.info(`  File Patterns: ${analysis.filePatterns.length > 0 ? analysis.filePatterns.join(', ') : 'All files'}`);
    logger.info(`  Estimated Cost: ${analysis.estimatedCostPerPR > 0 ? chalk.yellow(`$${analysis.estimatedCostPerPR.toFixed(2)} per PR`) : chalk.green('Free')}`);
    logger.info('');
}
/**
 * Generate GitHub Actions workflow file
 */
function generateWorkflow(analysis) {
    const policyList = analysis.policies.map((p) => p.id).join(', ');
    const aiNote = analysis.requiresAI ? '\n# AI Required: Yes (AI-powered policy evaluation)' : '';
    const costNote = analysis.estimatedCostPerPR > 0
        ? `\n# Estimated Cost: ~$${analysis.estimatedCostPerPR.toFixed(2)} per PR`
        : '';
    const filePathsConfig = analysis.filePatterns.length > 0
        ? `\n    paths:\n${analysis.filePatterns.map((p) => `      - '${p}'`).join('\n')}`
        : '';
    return `name: MDP Governance
# Generated by mlang github init
# Policies: ${policyList}${aiNote}${costNote}

on:
  pull_request:
    types: [opened, synchronize, reopened]${filePathsConfig}

permissions:
  contents: read
  pull-requests: write
  statuses: write
  checks: write

jobs:
  evaluate:
    name: Evaluate PR against policies
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for git operations

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install MDP CLI
        run: |
          npm install -g @mdp-framework/mlang@latest
          mlang --version

      - name: Fetch PR data
        id: fetch-pr
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            const files = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });

            // Fetch file contents for each changed file
            const filesWithContent = await Promise.all(
              files.data.map(async (file) => {
                let content = '';
                if (file.status !== 'removed') {
                  try {
                    const fileContent = await github.rest.repos.getContent({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      path: file.filename,
                      ref: pr.data.head.sha
                    });
                    content = Buffer.from(fileContent.data.content, 'base64').toString('utf-8');
                  } catch (error) {
                    console.log(\`Could not fetch content for \${file.filename}: \${error.message}\`);
                  }
                }

                return {
                  path: file.filename,
                  status: file.status,
                  additions: file.additions,
                  deletions: file.deletions,
                  changes: file.changes,
                  patch: file.patch,
                  content: content
                };
              })
            );

            const prData = {
              number: pr.data.number,
              title: pr.data.title,
              description: pr.data.body || '',
              files: filesWithContent,
              author: pr.data.user.login,
              created_at: pr.data.created_at,
              updated_at: pr.data.updated_at
            };

            fs.writeFileSync('pr-data.json', JSON.stringify(prData, null, 2));
            console.log(\`Fetched PR #\${pr.data.number} with \${filesWithContent.length} files\`);

      - name: Evaluate PR
        env:${analysis.requiresAI ? '\n          ANTHROPIC_API_KEY: $' + '{{ secrets.ANTHROPIC_API_KEY }}' : ''}
          GITHUB_TOKEN: $` + `{{ secrets.GITHUB_TOKEN }}
        run: |
          mlang evaluate \\
            --file pr-data.json \\
            --format json \\
            > evaluation-result.json

          # Show results in logs
          cat evaluation-result.json | jq '.' || cat evaluation-result.json

      - name: Post results as PR comment
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            let result;
            try {
              result = JSON.parse(fs.readFileSync('evaluation-result.json', 'utf-8'));
            } catch (error) {
              console.log('Failed to parse evaluation result:', error);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: '‚ùå **MDP Governance Check Failed**\\n\\nEvaluation failed to run. Check the workflow logs for details.'
              });
              return;
            }

            const { summary, results } = result;

            // Build comment body
            let body = '## üõ°Ô∏è MDP Governance Report\\n\\n';

            if (summary.approved) {
              body += '‚úÖ **All policies passed!** This PR is approved for merge.\\n\\n';
            } else {
              body += \`‚ùå **\${summary.failed} \${summary.failed === 1 ? 'policy' : 'policies'} failed** with \${summary.total_violations} \${summary.total_violations === 1 ? 'violation' : 'violations'}.\\n\\n\`;
            }

            body += \`**Summary:**\\n\`;
            body += \`- Policies evaluated: \${summary.policies_evaluated}\\n\`;
            body += \`- Passed: \${summary.passed}\\n\`;
            body += \`- Failed: \${summary.failed}\\n\`;
            body += \`- Total violations: \${summary.total_violations}\\n\\n\`;

            // Add violations by policy
            if (summary.total_violations > 0) {
              body += '### Violations\\n\\n';

              for (const policyResult of results) {
                if (policyResult.violations.length > 0) {
                  body += \`#### \${policyResult.policy_id} (\${policyResult.status})\\n\\n\`;

                  for (const violation of policyResult.violations) {
                    const location = violation.location?.file
                      ? \` in \\\`\${violation.location.file}\\\`\${violation.location.line ? \`:\${violation.location.line}\` : ''}\`
                      : '';

                    body += \`- **[\${violation.severity.toUpperCase()}]** \${violation.message}\${location}\\n\`;

                    if (violation.suggestedFix) {
                      body += \`\\n  <details>\\n  <summary>Suggested Fix</summary>\\n\\n  \\\`\\\`\\\`diff\\n\${violation.suggestedFix}\\n  \\\`\\\`\\\`\\n  </details>\\n\\n\`;
                    }
                  }

                  body += '\\n';
                }
              }
            }

            body += '\\n---\\n';
            body += \`ü§ñ Generated by [MDP Framework](https://github.com/mdp-labs/mdp-mlang)\`;

            // Post comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });

      - name: Update commit status
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            let result, state, description;
            try {
              result = JSON.parse(fs.readFileSync('evaluation-result.json', 'utf-8'));

              if (result.summary.approved) {
                state = 'success';
                description = 'All policies passed';
              } else {
                state = 'failure';
                description = \`\${result.summary.total_violations} violation(s) found\`;
              }
            } catch (error) {
              state = 'error';
              description = 'Evaluation failed to run';
            }

            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.payload.pull_request.head.sha,
              state: state,
              description: description,
              context: 'MDP Governance',
              target_url: \`https://github.com/\${context.repo.owner}/\${context.repo.repo}/actions/runs/\${context.runId}\`
            });
`;
}
/**
 * Generate setup documentation
 */
function generateSetupDocs(analysis) {
    const policyList = analysis.policies
        .map((p) => {
        const aiTag = p.constraints?.violation_check_prompt ? ' (AI-powered)' : '';
        const aoiTag = p.constraints?.aoi_feedback_enabled ? ' [AOI enabled]' : '';
        return `${p.id}${aiTag}${aoiTag} - ${p.description}`;
    })
        .join('\n');
    const secretsList = analysis.requiredSecrets
        .map((secret) => {
        if (secret === 'GITHUB_TOKEN') {
            return `- \`${secret}\` - Automatically provided by GitHub Actions (no setup needed)`;
        }
        if (secret === 'ANTHROPIC_API_KEY') {
            return `- \`${secret}\` - Required for AI policy evaluation\n  - Get API key from: https://console.anthropic.com/\n  - Add to: Settings ‚Üí Secrets and variables ‚Üí Actions ‚Üí New repository secret`;
        }
        return `- \`${secret}\``;
    })
        .join('\n');
    const costSection = analysis.estimatedCostPerPR > 0
        ? `## Cost Estimation

Estimated cost per PR: **$${analysis.estimatedCostPerPR.toFixed(2)}**

This is based on:
- ${analysis.policies.filter((p) => p.constraints?.violation_check_prompt).length} AI-powered ${analysis.policies.filter((p) => p.constraints?.violation_check_prompt).length === 1 ? 'policy' : 'policies'}
- Typical PR size (5-20 files)
- Claude API pricing

Costs are only incurred when PRs are opened/updated.

`
        : '';
    return `# MDP Governance Setup

This workflow was automatically generated from your policies by \`mlang github init\`.

## Policies Enforced

${policyList}

## Required Secrets

${secretsList}

${costSection}## How It Works

1. **Trigger**: Workflow runs when a PR is opened, synchronized, or reopened
2. **Fetch**: Retrieves PR data including file contents
3. **Evaluate**: Runs all policies against the PR changes
4. **Report**: Posts results as a PR comment
5. **Status**: Updates commit status (blocks merge if violations found)

## File Patterns

${analysis.filePatterns.length > 0 ? `This workflow is optimized to only run on:\n${analysis.filePatterns.map((p) => `- \`${p}\``).join('\n')}` : 'This workflow runs on all file changes.'}

## Features

${analysis.requiresAI ? '- ‚úÖ AI-powered policy evaluation using Claude' : '- ‚öôÔ∏è Static policy evaluation'}
${analysis.aoiEnabled ? '- ‚úÖ AOI feedback loop (Architecture of Intent)' : ''}
- ‚úÖ Automated fix suggestions
- ‚úÖ PR comment reports
- ‚úÖ Commit status checks

## Troubleshooting

### Workflow not running?
- Check that the workflow file exists: \`.github/workflows/mdp-governance.yml\`
- Verify GitHub Actions is enabled for your repository
- Check workflow permissions in Settings ‚Üí Actions ‚Üí General

### "ANTHROPIC_API_KEY not found" error?
- Add the secret in Settings ‚Üí Secrets and variables ‚Üí Actions
- Make sure it's named exactly \`ANTHROPIC_API_KEY\`

### Workflow fails with "mlang: command not found"?
- The workflow installs mlang automatically
- Check Node.js setup step completed successfully

### High costs?
- AI evaluation only runs when policies detect potential violations
- Costs scale with PR size and number of AI-powered policies
- Consider using static policies where possible

## Next Steps

1. ‚úÖ Workflow file created
2. ‚è≥ Configure required secrets (see above)
3. ‚è≥ Commit and push to your repository
4. ‚è≥ Create a test PR to verify the workflow

## Learn More

- MDP Framework: https://github.com/mdp-labs/mdp-mlang
- Documentation: https://github.com/mdp-labs/mdp-mlang/tree/main/Docs
- Policy Examples: https://github.com/mdp-labs/mdp-mlang/tree/main/examples

---

Generated by \`mlang github init\` on ${new Date().toISOString().split('T')[0]}
`;
}
//# sourceMappingURL=github.js.map