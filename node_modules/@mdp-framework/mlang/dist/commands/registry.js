/**
 * Registry CLI Commands
 *
 * Commands:
 * - mlang registry head <channel>
 * - mlang registry get <id> [version]
 * - mlang registry verify <file>
 *
 * @since M2 (Team A)
 */
import { readFileSync, existsSync } from 'node:fs';
import { resolve } from 'node:path';
import { createRegistry } from '@mdp-framework/adapters';
import { validators } from '@mdp-framework/schemas/contracts';
/**
 * Show latest version on channel
 *
 * Usage: mlang registry head <id> [--channel stable] [--base-path .mlang]
 */
export async function runRegistryHead(logger, id, options = {}) {
    const { channel = 'stable', basePath = '.mlang', verbose = false } = options;
    if (verbose) {
        logger.debug(`Looking up channel: ${id}@${channel}`);
        logger.debug(`Registry path: ${basePath}`);
    }
    const registryPath = resolve(process.cwd(), basePath);
    if (!existsSync(registryPath)) {
        logger.error(`Registry not found: ${registryPath}`);
        logger.info('Run "mlang init" to initialize the registry');
        throw new Error('Registry not found');
    }
    const registry = createRegistry(registryPath);
    // Get channel pointer
    const channelResult = await registry.getChannel(id, channel);
    if (!channelResult.ok) {
        logger.error(`Channel not found: ${id}@${channel}`);
        logger.info(`Error: ${channelResult.error?.message}`);
        throw new Error(`Channel not found: ${id}@${channel}`);
    }
    const version = channelResult.data;
    // Get the policy card
    const cardResult = await registry.get(id, version);
    if (!cardResult.ok) {
        logger.error(`Policy card not found: ${id}@${version}`);
        logger.info(`Error: ${cardResult.error?.message}`);
        throw new Error(`Policy card not found: ${id}@${version}`);
    }
    const card = cardResult.data;
    // Display results
    logger.info(`\nPolicy: ${id}`);
    logger.info(`Channel: ${channel}`);
    logger.success(`Version: ${version}`);
    if (verbose) {
        logger.info(`\nDetails:`);
        logger.info(`  Title: ${card.title || 'N/A'}`);
        logger.info(`  Description: ${card.description || 'N/A'}`);
        logger.info(`  Scope: ${card.scope}`);
        logger.info(`  Role: ${card.role}`);
        logger.info(`  Hash: ${card.hash.substring(0, 16)}...`);
        logger.info(`  Signed: ${card.signature ? 'Yes' : 'No'}`);
        if (card.signed_by) {
            logger.info(`  Signed by: ${card.signed_by}`);
        }
    }
}
/**
 * Fetch policy by ID
 *
 * Usage: mlang registry get <id> [version] [--base-path .mlang] [--save path]
 */
export async function runRegistryGet(logger, id, options = {}) {
    const { version, basePath = '.mlang', save, verbose = false } = options;
    if (verbose) {
        logger.debug(`Fetching policy: ${id}${version ? `@${version}` : ''}`);
        logger.debug(`Registry path: ${basePath}`);
    }
    const registryPath = resolve(process.cwd(), basePath);
    if (!existsSync(registryPath)) {
        logger.error(`Registry not found: ${registryPath}`);
        logger.info('Run "mlang init" to initialize the registry');
        throw new Error('Registry not found');
    }
    const registry = createRegistry(registryPath);
    // Get the policy card
    const cardResult = await registry.get(id, version);
    if (!cardResult.ok) {
        logger.error(`Policy card not found: ${id}${version ? `@${version}` : ''}`);
        logger.info(`Error: ${cardResult.error?.message}`);
        throw new Error(`Policy card not found`);
    }
    const card = cardResult.data;
    // Display results
    logger.success(`Found policy: ${card.id}@${card.version}`);
    if (verbose) {
        logger.info(`\nDetails:`);
        logger.info(`  Title: ${card.title || 'N/A'}`);
        logger.info(`  Description: ${card.description || 'N/A'}`);
        logger.info(`  Scope: ${card.scope}`);
        logger.info(`  Role: ${card.role}`);
        logger.info(`  Hash: ${card.hash}`);
        logger.info(`  Signed: ${card.signature ? 'Yes' : 'No'}`);
        if (card.signed_by) {
            logger.info(`  Signed by: ${card.signed_by}`);
        }
        if (card.tags && card.tags.length > 0) {
            logger.info(`  Tags: ${card.tags.join(', ')}`);
        }
    }
    // Save to file if requested
    if (save) {
        const fs = await import('node:fs/promises');
        const savePath = resolve(process.cwd(), save);
        await fs.writeFile(savePath, JSON.stringify(card, null, 2), 'utf-8');
        logger.success(`Saved to: ${savePath}`);
    }
    // Display JSON if not saving
    if (!save && verbose) {
        logger.info(`\nJSON:\n${JSON.stringify(card, null, 2)}`);
    }
}
/**
 * Verify policy signature
 *
 * Usage: mlang registry verify <file> [--base-path .mlang]
 */
export async function runRegistryVerify(logger, file, options = {}) {
    const { basePath = '.mlang', verbose = false } = options;
    if (verbose) {
        logger.debug(`Verifying policy: ${file}`);
        logger.debug(`Registry path: ${basePath}`);
    }
    const filePath = resolve(process.cwd(), file);
    if (!existsSync(filePath)) {
        logger.error(`File not found: ${filePath}`);
        throw new Error('File not found');
    }
    // Load policy card
    let card;
    try {
        const content = readFileSync(filePath, 'utf-8');
        card = JSON.parse(content);
    }
    catch (err) {
        logger.error(`Failed to parse policy card: ${err}`);
        throw new Error('Failed to parse policy card');
    }
    // Validate schema
    if (!validators.policyCard.validate(card)) {
        logger.error('Schema validation failed:');
        const errors = validators.policyCard.errors();
        for (const err of errors) {
            logger.error(`  ${err.path}: ${err.message}`);
        }
        throw new Error('Schema validation failed');
    }
    logger.success('Schema validation: PASSED');
    const registryPath = resolve(process.cwd(), basePath);
    const registry = createRegistry(registryPath);
    // Verify hash and signature
    const verifyResult = await registry.verify(card);
    if (!verifyResult.ok) {
        logger.error(`Verification failed: ${verifyResult.error?.message}`);
        throw new Error('Verification failed');
    }
    const verification = verifyResult.data;
    // Display results
    logger.info(`\nPolicy: ${card.id}@${card.version}`);
    logger.success(`Hash verification: ${verification.hash ? 'PASSED' : 'FAILED'}`);
    if (card.signature) {
        logger.success(`Signature verification: ${verification.signature ? 'PASSED' : 'FAILED'}`);
        if (verification.signedBy) {
            logger.info(`Signed by: ${verification.signedBy}`);
        }
    }
    else {
        logger.info('Signature: Not present');
    }
    if (verbose) {
        logger.info(`\nDetails:`);
        logger.info(`  ID: ${card.id}`);
        logger.info(`  Version: ${card.version}`);
        logger.info(`  Scope: ${card.scope}`);
        logger.info(`  Role: ${card.role}`);
        logger.info(`  Hash: ${card.hash}`);
    }
    if (verification.hash && verification.signature) {
        logger.success('\nVerification: ALL CHECKS PASSED');
    }
    else if (verification.hash && !card.signature) {
        logger.success('\nVerification: PASSED (unsigned policy)');
    }
    else {
        logger.error('\nVerification: FAILED');
        throw new Error('Verification failed');
    }
}
/**
 * List all policies in registry
 *
 * Usage: mlang registry list [prefix] [--base-path .mlang]
 */
export async function runRegistryList(logger, prefix, options = {}) {
    const { basePath = '.mlang', verbose = false } = options;
    if (verbose) {
        logger.debug(`Listing policies${prefix ? ` with prefix: ${prefix}` : ''}`);
        logger.debug(`Registry path: ${basePath}`);
    }
    const registryPath = resolve(process.cwd(), basePath);
    if (!existsSync(registryPath)) {
        logger.error(`Registry not found: ${registryPath}`);
        logger.info('Run "mlang init" to initialize the registry');
        throw new Error('Registry not found');
    }
    const registry = createRegistry(registryPath);
    // List policies
    const listResult = await registry.list(prefix);
    if (!listResult.ok) {
        logger.error(`Failed to list policies: ${listResult.error?.message}`);
        throw new Error('Failed to list policies');
    }
    const policies = listResult.data;
    if (policies.length === 0) {
        logger.info('No policies found');
        return;
    }
    logger.info(`\nFound ${policies.length} ${policies.length === 1 ? 'policy' : 'policies'}:\n`);
    for (const policyId of policies) {
        logger.info(`  ${policyId}`);
    }
}
//# sourceMappingURL=registry.js.map