/**
 * Capsule Store CLI Commands
 * M3 - State persistence management (prune, export, import)
 */
import { readFile, writeFile } from 'node:fs/promises';
import { resolve } from 'node:path';
import { createCapsuleStore } from '@mdp-framework/gateway/store';
/**
 * Prune old capsules based on retention policy
 */
export async function runCapsulePrune(logger, options = {}) {
    const { basePath = '.mlang', apply = false, keepDays, yes = false, verbose = false, } = options;
    try {
        const storeConfig = {
            backend: 'file',
            baseDir: resolve(basePath, 'state/capsules'),
            retention: {
                localDays: keepDays ?? 14,
                protectOpen: true,
                checkLinks: false,
                pins: [],
            },
        };
        const store = await createCapsuleStore(storeConfig);
        if (!apply) {
            logger.info('üîç Running prune in DRY RUN mode (use --apply to actually delete)');
        }
        const pruneResult = await store.prune(!apply);
        if (!pruneResult.ok) {
            logger.error(`Prune failed: ${pruneResult.error.message}`);
            process.exit(1);
        }
        const { deleted, candidates, errors } = pruneResult.data;
        if (deleted.length === 0) {
            logger.success('‚úì No capsules to prune');
        }
        else {
            if (apply) {
                logger.success(`‚úì Pruned ${deleted.length} capsule(s)`);
            }
            else {
                logger.info(`Would prune ${deleted.length} capsule(s):`);
            }
            if (verbose || !apply) {
                for (const id of deleted) {
                    logger.info(`  ${apply ? '‚úó' : '‚Üí'} ${id}`);
                }
            }
        }
        if (verbose && candidates.length > 0) {
            const kept = candidates.filter(c => !deleted.includes(c.id));
            if (kept.length > 0) {
                logger.info(`\nKept ${kept.length} capsule(s):`);
                for (const candidate of kept) {
                    logger.info(`  ‚úì ${candidate.id}`);
                }
            }
        }
        if (errors.length > 0) {
            logger.warn(`\n‚ö†Ô∏è  ${errors.length} error(s) during pruning:`);
            for (const err of errors) {
                logger.warn(`  ${err.id}: ${err.error.message}`);
            }
        }
        await store.close();
    }
    catch (error) {
        logger.error(`Prune failed: ${error instanceof Error ? error.message : String(error)}`);
        if (verbose && error instanceof Error) {
            logger.error(error.stack || '');
        }
        process.exit(1);
    }
}
/**
 * Export capsules to NDJSON file
 */
export async function runCapsuleExport(logger, options) {
    const { basePath = '.mlang', capsule, kind, out, verbose = false } = options;
    if (!capsule && !kind) {
        logger.error('Must specify either --capsule <id> or --kind <kind>');
        process.exit(1);
    }
    if (capsule && kind) {
        logger.error('Cannot specify both --capsule and --kind');
        process.exit(1);
    }
    try {
        const storeConfig = {
            backend: 'file',
            baseDir: resolve(basePath, 'state/capsules'),
            retention: {
                localDays: 14,
                protectOpen: true,
                checkLinks: false,
                pins: [],
            },
        };
        const store = await createCapsuleStore(storeConfig);
        const listOptions = capsule
            ? { prefix: capsule }
            : kind
                ? { kind: kind }
                : undefined;
        const entries = [];
        let count = 0;
        for await (const entry of store.export(listOptions)) {
            const line = JSON.stringify(entry);
            entries.push(line);
            count++;
            if (verbose && entry.type === 'capsule') {
                const capsule = entry.doc;
                logger.info(`  ‚úì ${capsule.id}`);
            }
        }
        if (count === 0) {
            logger.warn('No capsules found to export');
            await store.close();
            return;
        }
        const ndjson = entries.join('\n') + '\n';
        if (out) {
            await writeFile(resolve(out), ndjson, 'utf-8');
            logger.success(`‚úì Exported ${count} capsule(s) to ${out}`);
        }
        else {
            process.stdout.write(ndjson);
            if (verbose) {
                logger.success(`‚úì Exported ${count} capsule(s) to stdout`);
            }
        }
        await store.close();
    }
    catch (error) {
        logger.error(`Export failed: ${error instanceof Error ? error.message : String(error)}`);
        if (verbose && error instanceof Error) {
            logger.error(error.stack || '');
        }
        process.exit(1);
    }
}
/**
 * Import capsules from NDJSON file
 */
export async function runCapsuleImport(logger, options) {
    const { basePath = '.mlang', file, overwrite = false, verbose = false } = options;
    try {
        const storeConfig = {
            backend: 'file',
            baseDir: resolve(basePath, 'state/capsules'),
            retention: {
                localDays: 14,
                protectOpen: true,
                checkLinks: false,
                pins: [],
            },
        };
        const store = await createCapsuleStore(storeConfig);
        const content = await readFile(resolve(file), 'utf-8');
        const lines = content
            .split('\n')
            .map((l) => l.trim())
            .filter((l) => l.length > 0);
        if (lines.length === 0) {
            logger.warn('No capsules found in import file');
            await store.close();
            return;
        }
        // Convert array to async iterable
        async function* entriesIterable() {
            for (const line of lines) {
                yield JSON.parse(line);
            }
        }
        const importResult = await store.import(entriesIterable(), overwrite);
        if (!importResult.ok) {
            logger.error(`Import failed: ${importResult.error.message}`);
            await store.close();
            process.exit(1);
        }
        const { imported, skipped, errors } = importResult.data;
        logger.success(`‚úì Imported ${imported} capsule(s)`);
        if (skipped > 0) {
            logger.info(`  Skipped ${skipped} existing capsule(s) (use --overwrite to replace)`);
        }
        if (verbose && imported > 0) {
            logger.info(`\nImported capsules:`);
            for (const line of lines.slice(0, imported)) {
                const entry = JSON.parse(line);
                if (entry.type === 'capsule') {
                    const capsule = entry.doc;
                    logger.info(`  ‚úì ${capsule.id}`);
                }
            }
        }
        if (errors.length > 0) {
            logger.warn(`\n‚ö†Ô∏è  ${errors.length} error(s) during import:`);
            for (const err of errors) {
                const capsule = err.entry.doc;
                logger.warn(`  ${capsule.id}: ${err.error.message}`);
            }
        }
        await store.close();
    }
    catch (error) {
        logger.error(`Import failed: ${error instanceof Error ? error.message : String(error)}`);
        if (verbose && error instanceof Error) {
            logger.error(error.stack || '');
        }
        process.exit(1);
    }
}
//# sourceMappingURL=capsule.js.map