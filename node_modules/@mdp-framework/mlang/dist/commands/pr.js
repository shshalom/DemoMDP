/**
 * PR Commands (M7)
 *
 * Commands for working with Pull Requests in CI/CD environments
 */
import { existsSync, readFileSync, writeFileSync } from 'fs';
import { join } from 'path';
import { createDefaultEvaluatorRegistry, buildActionPlan, summarizeActions, isBlocking, ActionEngine, } from '@mdp-framework/gateway';
import { GitHubAdapter } from '@mdp-framework/adapters';
/**
 * Infer repository from various sources
 */
async function inferRepo(options, logger) {
    // 1. Explicit --repo flag
    if (options.repo) {
        const [owner, repo] = options.repo.split('/');
        if (!owner || !repo) {
            throw new Error(`Invalid repo format: ${options.repo}. Expected: owner/repo`);
        }
        logger.debug(`Using explicit repo: ${owner}/${repo}`);
        return { owner, repo, provider: 'github' };
    }
    // 2. CI environment (GitHub Actions)
    if (process.env.GITHUB_REPOSITORY) {
        const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
        logger.debug(`Inferred repo from GITHUB_REPOSITORY: ${owner}/${repo}`);
        return { owner, repo, provider: 'github' };
    }
    // 3. Git remote (origin)
    try {
        const { execSync } = await import('child_process');
        const gitRemote = execSync('git remote get-url origin', { encoding: 'utf-8' }).trim();
        // Parse GitHub URLs (https or ssh)
        const httpsMatch = gitRemote.match(/github\.com[:/]([^/]+)\/(.+?)(\.git)?$/);
        if (httpsMatch) {
            const owner = httpsMatch[1];
            const repo = httpsMatch[2].replace('.git', '');
            logger.debug(`Inferred repo from git remote: ${owner}/${repo}`);
            return { owner, repo, provider: 'github' };
        }
    }
    catch (error) {
        logger.debug('Could not infer repo from git remote');
    }
    // 4. .mlang/origin.yaml
    const basePath = options.basePath || '.mlang';
    const originFile = join(basePath, 'origin.yaml');
    if (existsSync(originFile)) {
        try {
            const yaml = await import('yaml');
            const content = readFileSync(originFile, 'utf-8');
            const config = yaml.parse(content);
            if (config.repo) {
                const [owner, repo] = config.repo.split('/');
                logger.debug(`Inferred repo from ${originFile}: ${owner}/${repo}`);
                return { owner, repo, provider: 'github' };
            }
        }
        catch (error) {
            logger.warn(`Failed to parse ${originFile}: ${error.message}`);
        }
    }
    // 5. Error - cannot infer
    throw new Error('Cannot infer repository. Please provide --repo flag, set GITHUB_REPOSITORY env var, ' +
        'run from a git repository with origin remote, or create .mlang/origin.yaml');
}
/**
 * Fetch PR data from GitHub API
 */
async function fetchPRData(prNumber, repo, adapter, logger) {
    logger.info(`Fetching PR #${prNumber} from ${repo.owner}/${repo.repo}`);
    const pr = await adapter.getPullRequest(prNumber);
    const files = await adapter.getPullRequestFiles(prNumber);
    logger.debug(`PR: ${pr.title}`);
    logger.debug(`Files changed: ${files.length}`);
    // Transform to our internal format
    return {
        number: pr.number,
        title: pr.title,
        description: pr.body || '',
        files: files.map(f => ({
            path: f.filename,
            status: f.status,
            additions: f.additions,
            deletions: f.deletions,
            changes: f.additions + f.deletions,
            patch: f.patch,
        })),
        author: pr.author,
        created_at: pr.created_at,
        updated_at: pr.updated_at || pr.created_at,
    };
}
/**
 * Load policies from directory
 */
function loadPolicies(basePath, logger) {
    const policyDir = join(basePath, 'policies');
    if (!existsSync(policyDir)) {
        throw new Error(`Policy directory not found: ${policyDir}. Run 'mlang policy build' first.`);
    }
    const { readdirSync } = require('fs');
    const policyFiles = readdirSync(policyDir).filter((f) => f.endsWith('.json'));
    if (policyFiles.length === 0) {
        throw new Error(`No compiled policies found in ${policyDir}`);
    }
    const policies = [];
    for (const file of policyFiles) {
        const content = readFileSync(join(policyDir, file), 'utf-8');
        const policy = JSON.parse(content);
        policies.push(policy);
        logger.debug(`Loaded policy: ${policy.id}@${policy.version}`);
    }
    logger.info(`Loaded ${policies.length} policies`);
    return policies;
}
/**
 * Run PR review command
 */
export async function runPRReview(logger, options) {
    const basePath = options.basePath || '.mlang';
    const prNumber = parseInt(options.pr, 10);
    const checkName = options.checkName || 'mdp-governance';
    if (isNaN(prNumber)) {
        throw new Error(`Invalid PR number: ${options.pr}`);
    }
    // 1. Infer repository
    const repo = await inferRepo(options, logger);
    logger.info(`Repository: ${repo.owner}/${repo.repo}`);
    // 2. Initialize GitHub adapter
    const githubToken = process.env.GITHUB_TOKEN;
    if (!githubToken && !options.dryRun) {
        throw new Error('GITHUB_TOKEN environment variable is required. ' +
            'Use --dry-run for testing without GitHub API access.');
    }
    const adapter = new GitHubAdapter();
    if (githubToken) {
        await adapter.initialize({
            token: githubToken,
            repo: {
                owner: repo.owner,
                repo: repo.repo,
                provider: 'github',
            },
        });
        logger.debug('GitHub adapter initialized');
    }
    // 3. Fetch PR data
    const prData = await fetchPRData(prNumber, repo, adapter, logger);
    logger.info(`Evaluating PR #${prNumber}: "${prData.title}"`);
    logger.info(`Files changed: ${prData.files.length}`);
    // 4. Load policies
    const policies = loadPolicies(basePath, logger);
    // 5. Create evaluator registry and evaluate
    const registry = createDefaultEvaluatorRegistry();
    let totalViolations = 0;
    let policiesPassed = 0;
    let policiesFailed = 0;
    const results = [];
    logger.info('\n' + '─'.repeat(80));
    logger.info('POLICY EVALUATION');
    logger.info('─'.repeat(80));
    for (const policy of policies) {
        logger.info(`\nEvaluating: ${policy.id}@${policy.version}`);
        const result = await registry.evaluate(policy, { pr: prData });
        results.push(result);
        if (result.status === 'pass') {
            policiesPassed++;
            logger.success(`  ✓ PASS - No violations`);
        }
        else if (result.status === 'warning') {
            policiesPassed++;
            logger.warn(`  ⚠ WARNING - ${result.violations.length} violations`);
        }
        else {
            policiesFailed++;
            logger.error(`  ✗ FAIL - ${result.violations.length} violations`);
        }
        if (result.violations.length > 0) {
            for (const violation of result.violations) {
                const location = violation.location?.file
                    ? ` (${violation.location.file}${violation.location.line ? `:${violation.location.line}` : ''})`
                    : '';
                logger.warn(`    [${violation.severity.toUpperCase()}] ${violation.message}${location}`);
            }
            totalViolations += result.violations.length;
        }
    }
    // 6. Summary
    logger.info('\n' + '─'.repeat(80));
    logger.info('EVALUATION SUMMARY');
    logger.info('─'.repeat(80));
    logger.info(`Policies evaluated: ${policies.length}`);
    logger.info(`Passed: ${policiesPassed}`);
    logger.info(`Failed: ${policiesFailed}`);
    logger.info(`Total violations: ${totalViolations}`);
    // 7. Generate ActionPlan if violations exist
    let actionPlan = null;
    let envelope = null;
    if (totalViolations > 0) {
        logger.info('\n' + '─'.repeat(80));
        logger.info('ACTION PLAN');
        logger.info('─'.repeat(80));
        const firstPolicyId = policies[0].id;
        const firstPolicyVersion = policies[0].version;
        actionPlan = buildActionPlan(results, {
            policyId: `${firstPolicyId}@${firstPolicyVersion}`,
            triggeredBy: 'mlang-cli-pr-review',
            context: {
                pr_number: prData.number,
                pr_title: prData.title,
                repo: `${repo.owner}/${repo.repo}`,
                policies_evaluated: policies.map(p => `${p.id}@${p.version}`).join(', '),
            },
        });
        const summary = summarizeActions(actionPlan);
        const blocking = isBlocking(actionPlan);
        logger.info(`Plan ID: ${actionPlan.plan_id}`);
        logger.info(`Status: ${blocking ? 'BLOCKING' : 'NON-BLOCKING'}`);
        logger.info(`Total actions: ${summary.total}`);
        logger.info(`  Gate actions: ${summary.gates}`);
        logger.info(`  PR comments: ${summary.comments}`);
        logger.info(`  Suggested patches: ${summary.patches}`);
        // 8. Execute ActionPlan
        if (!options.dryRun) {
            logger.info('\n' + '─'.repeat(80));
            logger.info('ACTION EXECUTION');
            logger.info('─'.repeat(80));
            const actionEngine = new ActionEngine({
                mode: 'report', // Use report mode for CI (read-only operations)
                allow_enforcement: false,
                adapter,
                context: {
                    pr_number: prData.number,
                    repo: `${repo.owner}/${repo.repo}`,
                    head_sha: 'pr-review', // TODO: Get actual head SHA from PR
                },
            });
            logger.info(`Executing ${actionPlan.actions.length} actions...`);
            envelope = await actionEngine.execute(actionPlan);
            logger.success(`\n✓ Execution complete`);
            logger.info(`Envelope ID: ${envelope.id}`);
            logger.info(`Status: ${envelope.status}`);
            logger.info(`Duration: ${envelope.execution.duration_ms}ms`);
            logger.info(`Actions executed: ${envelope.actions?.length || 0}`);
            if (envelope.actions && envelope.actions.length > 0) {
                logger.info('\nAction Results:');
                for (const action of envelope.actions) {
                    const statusIcon = action.status === 'completed' ? '✓' : action.status === 'failed' ? '✗' : '○';
                    logger.info(`  ${statusIcon} ${action.type} - ${action.status}`);
                }
            }
        }
        else {
            logger.info('\n' + '─'.repeat(80));
            logger.info('DRY RUN MODE');
            logger.info('─'.repeat(80));
            logger.info('Skipping action execution (--dry-run)');
            logger.info(`Would execute ${actionPlan.actions.length} actions`);
        }
    }
    else {
        logger.success(`\n✓ PR APPROVED - All policies passed`);
    }
    // 9. Emit envelope if requested
    if (options.emitEnvelope && envelope) {
        writeFileSync(options.emitEnvelope, JSON.stringify(envelope, null, 2));
        logger.info(`\nEnvelope written to: ${options.emitEnvelope}`);
    }
    // 10. Exit with appropriate code
    if (totalViolations > 0) {
        const blocking = actionPlan ? isBlocking(actionPlan) : false;
        if (blocking) {
            logger.error('\n✗ CHECK FAILED - Blocking violations found');
            process.exitCode = 1;
        }
        else {
            logger.warn('\n⚠ CHECK WARNING - Non-blocking violations found');
            process.exitCode = 0; // Warn doesn't fail the check
        }
    }
    else {
        logger.success('\n✓ CHECK PASSED - No violations');
        process.exitCode = 0;
    }
}
//# sourceMappingURL=pr.js.map