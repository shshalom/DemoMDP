/**
 * Evaluate Command (M5)
 *
 * Evaluates PRs or local changes against compiled policies
 */
import { readFileSync, existsSync, readdirSync } from 'fs';
import { join } from 'path';
import { createAIEvaluatorRegistry, buildActionPlan, summarizeActions, isBlocking, } from '@mdp-framework/gateway';
import { AnthropicProvider } from '@mdp-framework/ai-services';
/**
 * Run the evaluate command
 */
export async function runEvaluate(logger, options) {
    const basePath = options.basePath || '.mlang';
    // Load PR data
    let prData;
    if (options.file) {
        // Load from file
        if (!existsSync(options.file)) {
            throw new Error(`PR data file not found: ${options.file}`);
        }
        logger.info(`Loading PR data from ${options.file}`);
        const content = readFileSync(options.file, 'utf-8');
        prData = JSON.parse(content);
    }
    else if (options.pr) {
        // TODO: Fetch from GitHub API using --pr number
        throw new Error('Fetching from GitHub API not yet implemented. Use --file for now.');
    }
    else {
        throw new Error('Must specify either --pr or --file');
    }
    // Load policies - try multiple locations
    let policyDir = options.policies;
    if (!policyDir) {
        // Auto-detect policy location (convention over configuration)
        const candidates = [
            join(basePath, 'packs', 'stable'), // Default channel (most common)
            join(basePath, 'packs', 'preview'), // Preview channel
            join(basePath, 'packs', 'dev'), // Dev channel
            join(basePath, 'policies'), // Legacy location
        ];
        for (const candidate of candidates) {
            if (existsSync(candidate)) {
                const files = readdirSync(candidate).filter((f) => f.endsWith('.json'));
                if (files.length > 0) {
                    policyDir = candidate;
                    break;
                }
            }
        }
        if (!policyDir) {
            throw new Error('No compiled policies found. Run \'mlang policy build\' first, or specify --policies <dir>');
        }
    }
    logger.info(`Loading policies from ${policyDir}`);
    if (!existsSync(policyDir)) {
        throw new Error(`Policy directory not found: ${policyDir}. Run 'mlang policy build' first.`);
    }
    // Load all .json files from policy directory
    const policyFiles = readdirSync(policyDir).filter((f) => f.endsWith('.json'));
    if (policyFiles.length === 0) {
        throw new Error(`No compiled policies found in ${policyDir}`);
    }
    let policies = [];
    for (const file of policyFiles) {
        const content = readFileSync(join(policyDir, file), 'utf-8');
        const policy = JSON.parse(content);
        policies.push(policy);
        logger.debug(`Loaded policy: ${policy.id}@${policy.version}`);
    }
    // Filter by policy IDs if specified
    if (options.policyIds) {
        const requestedIds = options.policyIds.split(',').map(id => id.trim());
        const before = policies.length;
        policies = policies.filter(p => requestedIds.includes(p.id));
        if (policies.length === 0) {
            throw new Error(`None of the requested policies found: ${requestedIds.join(', ')}\n` +
                `Available policies: ${policyFiles.map(f => f.replace('.json', '')).join(', ')}`);
        }
        if (policies.length < requestedIds.length) {
            const found = policies.map(p => p.id);
            const missing = requestedIds.filter(id => !found.includes(id));
            logger.warn(`Warning: Some requested policies not found: ${missing.join(', ')}`);
        }
        logger.debug(`Filtered ${before} policies down to ${policies.length} based on --policy-ids`);
    }
    logger.info(`Loaded ${policies.length} policies`);
    // Create AI-powered evaluator registry
    const anthropicApiKey = process.env.ANTHROPIC_API_KEY;
    if (!anthropicApiKey) {
        throw new Error('ANTHROPIC_API_KEY environment variable is required for policy evaluation.\n' +
            'Set it in your .env file or export it: export ANTHROPIC_API_KEY=sk-ant-...');
    }
    const aiProvider = new AnthropicProvider({
        apiKey: anthropicApiKey,
        defaultModel: 'claude-sonnet-4-5-20250929',
    });
    const registry = createAIEvaluatorRegistry(aiProvider, {
        confidenceThreshold: Number(process.env.MLANG_AI_CONFIDENCE_THRESHOLD) || 0.7,
        temperature: Number(process.env.MLANG_AI_TEMPERATURE) || 0.1,
    });
    logger.debug('Using AI-powered evaluation (Anthropic Claude)');
    // Evaluate
    logger.info(`Evaluating PR #${prData.number}: "${prData.title}"`);
    logger.info(`Files changed: ${prData.files.length}`);
    let totalViolations = 0;
    let policiesPassed = 0;
    let policiesFailed = 0;
    const results = [];
    for (const policy of policies) {
        logger.info(`\nEvaluating against: ${policy.id}@${policy.version}`);
        const result = await registry.evaluate(policy, { pr: prData });
        results.push(result);
        if (result.status === 'pass') {
            policiesPassed++;
            logger.success(`  ✓ PASS - No violations`);
        }
        else if (result.status === 'warning') {
            policiesPassed++;
            logger.warn(`  ⚠ WARNING - ${result.violations.length} violations`);
        }
        else {
            policiesFailed++;
            logger.error(`  ✗ FAIL - ${result.violations.length} violations`);
        }
        if (result.violations.length > 0) {
            for (const violation of result.violations) {
                const location = violation.location?.file
                    ? ` (${violation.location.file}${violation.location.line ? `:${violation.location.line}` : ''})`
                    : '';
                logger.warn(`    [${violation.severity.toUpperCase()}] ${violation.message}${location}`);
            }
            totalViolations += result.violations.length;
        }
    }
    // Summary
    logger.info('\n' + '─'.repeat(80));
    logger.info('EVALUATION SUMMARY');
    logger.info('─'.repeat(80));
    logger.info(`Policies evaluated: ${policies.length}`);
    logger.info(`Passed: ${policiesPassed}`);
    logger.info(`Failed: ${policiesFailed}`);
    logger.info(`Total violations: ${totalViolations}`);
    if (totalViolations === 0) {
        logger.success(`\n✓ PR APPROVED - All policies passed`);
    }
    else {
        logger.error(`\n✗ PR BLOCKED - ${totalViolations} violations found`);
    }
    // Generate ActionPlan if there are violations
    let actionPlan = null;
    if (totalViolations > 0) {
        logger.info('\n' + '─'.repeat(80));
        logger.info('ACTION PLAN');
        logger.info('─'.repeat(80));
        // Use the first policy's ID for the action plan metadata
        // In reality, ActionPlan would come from a specific policy, but CLI aggregates all policies
        const firstPolicyId = policies[0].id;
        const firstPolicyVersion = policies[0].version;
        actionPlan = buildActionPlan(results, {
            policyId: `${firstPolicyId}@${firstPolicyVersion}`,
            triggeredBy: 'mlang-cli',
            context: {
                pr_number: prData.number,
                pr_title: prData.title,
                policies_evaluated: policies.map(p => `${p.id}@${p.version}`).join(', '),
            },
        });
        const summary = summarizeActions(actionPlan);
        const blocking = isBlocking(actionPlan);
        logger.info(`Plan ID: ${actionPlan.plan_id}`);
        logger.info(`Status: ${blocking ? 'BLOCKING' : 'NON-BLOCKING'}`);
        logger.info(`Total actions: ${summary.total}`);
        logger.info(`  Gate actions: ${summary.gates}`);
        logger.info(`  PR comments: ${summary.comments}`);
        logger.info(`  Suggested patches: ${summary.patches}`);
        if (!options.format || options.format === 'text') {
            logger.info('\nActions:');
            for (const action of actionPlan.actions) {
                if (action.verb === 'remediate.suggest.patch') {
                    const file = action.parameters.file || 'unknown';
                    const message = action.parameters.message || 'Fix suggested';
                    logger.info(`  • ${action.verb}: ${file}`);
                    logger.info(`    ${message}`);
                }
                else {
                    logger.info(`  • ${action.verb}`);
                    if (action.parameters.message) {
                        logger.info(`    ${action.parameters.message}`);
                    }
                }
            }
        }
        // Execute ActionPlan if --execute flag is provided
        if (options.execute || options.dryRun) {
            logger.info('\n' + '─'.repeat(80));
            logger.info('ACTION EXECUTION');
            logger.info('─'.repeat(80));
            // Import ActionEngine and adapter dynamically to avoid tsx issues
            const { ActionEngine } = await import('@mdp-framework/gateway');
            const { MockAdapter, GitHubAdapter } = await import('@mdp-framework/adapters');
            const mode = options.dryRun ? 'dry-run' : options.execute ? 'report' : 'dry-run';
            logger.info(`Mode: ${mode.toUpperCase()}`);
            // Choose adapter based on availability of GitHub token
            const githubToken = options.githubToken || process.env.GITHUB_TOKEN;
            let adapter;
            let adapterType = 'mock';
            if (githubToken && !options.dryRun) {
                // Use GitHub adapter if token is available and not in dry-run
                adapter = new GitHubAdapter();
                await adapter.initialize({
                    token: githubToken,
                    repo: {
                        owner: 'unknown', // TODO: infer from git remote
                        repo: 'unknown',
                        provider: 'github',
                    },
                });
                adapterType = 'github';
                logger.info(`Adapter: GitHub`);
            }
            else {
                // Use MockAdapter for dry-run or when no token
                adapter = new MockAdapter();
                await adapter.initialize({
                    repo: {
                        owner: 'test-owner',
                        repo: 'test-repo',
                        provider: 'github',
                    },
                });
                adapterType = 'mock';
                logger.info(`Adapter: Mock (${options.dryRun ? 'dry-run mode' : 'no GitHub token'})`);
            }
            const actionEngine = new ActionEngine({
                mode,
                allow_enforcement: false, // Never allow enforcement from CLI by default
                adapter,
                context: {
                    pr_number: prData.number,
                    repo: 'unknown/unknown',
                    head_sha: 'cli-evaluation',
                },
            });
            logger.info(`Executing ${actionPlan.actions.length} actions...`);
            const envelope = await actionEngine.execute(actionPlan);
            logger.success(`\n✓ Execution complete`);
            logger.info(`Envelope ID: ${envelope.id}`);
            logger.info(`Status: ${envelope.status}`);
            logger.info(`Duration: ${envelope.execution.duration_ms}ms`);
            logger.info(`Actions executed: ${envelope.actions?.length || 0}`);
            if (envelope.actions && envelope.actions.length > 0) {
                logger.info('\nAction Results:');
                for (const action of envelope.actions) {
                    const statusIcon = action.status === 'completed' ? '✓' : action.status === 'failed' ? '✗' : '○';
                    logger.info(`  ${statusIcon} ${action.type} - ${action.status}`);
                }
            }
        }
    }
    // Output JSON if requested
    if (options.format === 'json') {
        console.log(JSON.stringify({
            pr: {
                number: prData.number,
                title: prData.title,
            },
            summary: {
                policies_evaluated: policies.length,
                passed: policiesPassed,
                failed: policiesFailed,
                total_violations: totalViolations,
                approved: totalViolations === 0,
            },
            results: results.map((r) => ({
                policy_id: r.policy_id,
                policy_version: r.policy_version,
                status: r.status,
                violations: r.violations,
                metadata: r.metadata,
            })),
            action_plan: actionPlan
                ? {
                    plan_id: actionPlan.plan_id,
                    policy_id: actionPlan.policy_id,
                    actions: actionPlan.actions,
                    metadata: actionPlan.metadata,
                }
                : null,
        }, null, 2));
    }
    // Exit with error code if any violations
    if (totalViolations > 0) {
        process.exitCode = 1;
    }
}
//# sourceMappingURL=evaluate.js.map