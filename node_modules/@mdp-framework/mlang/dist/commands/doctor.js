import { execSync } from 'child_process';
import { existsSync } from 'fs';
import { resolve } from 'path';
export async function runDoctor(logger, options = {}) {
    const { ci = false, verbose = false } = options;
    logger.info('Running MLang environment checks...\n');
    const checks = [];
    // Check 1: Node.js version
    checks.push(await checkNodeVersion(logger, verbose));
    // Check 2: Git installed
    checks.push(await checkGit(logger, verbose));
    // Check 3: .mlang directory exists
    checks.push(await checkMlangDirectory(logger, verbose));
    // Check 4: Registry reachable
    checks.push(await checkRegistry(logger, verbose));
    // Check 5: Signing keys present
    checks.push(await checkSigningKeys(logger, verbose));
    // Check 6: GitHub token (CI only)
    if (ci) {
        checks.push(await checkGitHubToken(logger, verbose));
    }
    // Check 7: State store accessible
    checks.push(await checkStateStore(logger, verbose));
    // Summary
    const passed = checks.filter((c) => c.passed).length;
    const failed = checks.filter((c) => !c.passed && c.required).length;
    const warnings = checks.filter((c) => !c.passed && !c.required).length;
    logger.info('\n' + '='.repeat(60));
    logger.info(`Checks: ${checks.length} total, ${passed} passed`);
    if (failed > 0) {
        logger.error(`${failed} required check(s) failed`);
    }
    if (warnings > 0) {
        logger.warn(`${warnings} optional check(s) failed`);
    }
    if (failed === 0) {
        logger.success('\nAll required checks passed! MLang is ready to use.');
    }
    else {
        logger.error('\nSome required checks failed. Please address the issues above.');
    }
    return checks;
}
async function checkNodeVersion(logger, verbose) {
    try {
        const version = process.version;
        const major = parseInt(version.slice(1).split('.')[0], 10);
        if (major >= 20) {
            logger.success(`Node.js version: ${version}`);
            return {
                name: 'Node.js version',
                passed: true,
                message: `Node.js ${version} (>= v20 required)`,
                required: true,
            };
        }
        else {
            logger.error(`Node.js version: ${version} (v20+ required)`);
            return {
                name: 'Node.js version',
                passed: false,
                message: `Node.js ${version} is too old. Please upgrade to v20 or later.`,
                required: true,
            };
        }
    }
    catch (error) {
        logger.error('Failed to check Node.js version');
        return {
            name: 'Node.js version',
            passed: false,
            message: 'Could not determine Node.js version',
            required: true,
        };
    }
}
async function checkGit(logger, verbose) {
    try {
        const version = execSync('git --version', { encoding: 'utf-8' }).trim();
        logger.success(`Git: ${version}`);
        return {
            name: 'Git',
            passed: true,
            message: version,
            required: true,
        };
    }
    catch (error) {
        logger.error('Git: not found');
        return {
            name: 'Git',
            passed: false,
            message: 'Git is not installed or not in PATH',
            required: true,
        };
    }
}
async function checkMlangDirectory(logger, verbose) {
    const mlangDir = resolve(process.cwd(), '.mlang');
    const exists = existsSync(mlangDir);
    if (exists) {
        logger.success('.mlang directory: found');
        return {
            name: '.mlang directory',
            passed: true,
            message: `Found at ${mlangDir}`,
            required: false,
        };
    }
    else {
        logger.warn('.mlang directory: not found (run `mlang init` to create)');
        return {
            name: '.mlang directory',
            passed: false,
            message: 'Run `mlang init` to initialize the project',
            required: false,
        };
    }
}
async function checkRegistry(logger, verbose) {
    const registryPath = process.env.MLANG_REGISTRY_PATH || resolve(process.cwd(), '.mlang/packs');
    if (existsSync(registryPath)) {
        logger.success(`Registry: accessible at ${registryPath}`);
        return {
            name: 'Registry',
            passed: true,
            message: `Local registry at ${registryPath}`,
            required: false,
        };
    }
    else {
        logger.warn(`Registry: not found at ${registryPath}`);
        return {
            name: 'Registry',
            passed: false,
            message: 'Policy registry not initialized',
            required: false,
        };
    }
}
async function checkSigningKeys(logger, verbose) {
    const keysDir = resolve(process.cwd(), '.mlang/keys');
    if (existsSync(keysDir)) {
        logger.success('Signing keys directory: found');
        return {
            name: 'Signing keys',
            passed: true,
            message: `Keys directory at ${keysDir}`,
            required: false,
        };
    }
    else {
        logger.warn('Signing keys directory: not found');
        return {
            name: 'Signing keys',
            passed: false,
            message: 'No signing keys configured. Signature verification will be skipped.',
            required: false,
        };
    }
}
async function checkGitHubToken(logger, verbose) {
    const token = process.env.GITHUB_TOKEN;
    if (token && token.length > 0) {
        logger.success('GitHub token: configured');
        return {
            name: 'GitHub token',
            passed: true,
            message: 'GITHUB_TOKEN is set',
            required: true,
        };
    }
    else {
        logger.error('GitHub token: not configured');
        return {
            name: 'GitHub token',
            passed: false,
            message: 'GITHUB_TOKEN environment variable is not set',
            required: true,
        };
    }
}
async function checkStateStore(logger, verbose) {
    const dsn = process.env.MLANG_STATE_DSN || 'file://.mlang/store';
    if (dsn.startsWith('file://')) {
        const storePath = dsn.replace('file://', '');
        const fullPath = resolve(process.cwd(), storePath);
        if (existsSync(fullPath)) {
            logger.success(`State store: accessible at ${fullPath}`);
            return {
                name: 'State store',
                passed: true,
                message: `File-based store at ${fullPath}`,
                required: false,
            };
        }
        else {
            logger.warn(`State store: directory not found (will be created on first use)`);
            return {
                name: 'State store',
                passed: true,
                message: 'Will be created automatically',
                required: false,
            };
        }
    }
    else {
        // PostgreSQL or other DSN
        logger.info(`State store: ${dsn} (not checked)`);
        return {
            name: 'State store',
            passed: true,
            message: `External store: ${dsn}`,
            required: false,
        };
    }
}
//# sourceMappingURL=doctor.js.map