/**
 * AOI Commands - Architecture of Intent operations
 *
 * Stream 6: CLI AI Commands
 * See: Docs/contracts/STREAM-6-CLI-AI-COMMANDS.md
 */
// @ts-nocheck - Type mismatches between package versions, will be resolved in integration
import { existsSync, readFileSync } from 'fs';
import { join } from 'path';
import chalk from 'chalk';
// Mock createAIProvider and AOICoordinator for now (would come from ai-services and gateway)
function createAIProvider() {
    return {
        complete: async () => ({ text: 'mock response' }),
        embed: async () => [0.1, 0.2, 0.3],
    };
}
// Mock AOICoordinator class
class MockAOICoordinator {
    async processEvaluation() {
        return [];
    }
    async checkComponentExists(query, framework, threshold) {
        return {
            exists: false,
            threshold,
            matches: [],
            metadata: { query, total_candidates: 0, search_latency_ms: 0 },
        };
    }
    async generateSpec() {
        return {
            id: 'mock-spec',
            name: 'MockComponent',
            description: 'Mock description',
            framework: '',
            specification: '',
            examples: [],
            owners: [],
            metadata: {
                policy_id: '',
                policy_version: '',
                trigger_pr: 0,
                trigger_violation: { rule_id: '', message: '', severity: 'error' },
                generated_at: new Date().toISOString(),
                cost_usd: 0,
            },
        };
    }
    async routeToOwners() {
        return [];
    }
    async createCounterPR() {
        return {
            type: 'create_counter_pr',
            status: 'pending',
            target: { platform: 'github' },
            payload: {},
            metadata: { created_at: new Date().toISOString() },
        };
    }
    async createFollowupPR() {
        return {
            type: 'create_followup_pr',
            status: 'pending',
            target: { platform: 'github' },
            payload: {},
            metadata: { created_at: new Date().toISOString() },
        };
    }
    getComponentIndex() {
        return null;
    }
}
/**
 * Manually trigger AOI detection
 */
export async function runAOIGenerate(logger, options) {
    const basePath = options.basePath || '.mlang';
    // Load PR data
    const prPath = options.pr;
    if (!existsSync(prPath)) {
        throw new Error(`PR data file not found: ${prPath}`);
    }
    logger.info(`Loading PR data from ${prPath}`);
    const prData = JSON.parse(readFileSync(prPath, 'utf-8'));
    // Load policy
    let policy;
    if (options.policy) {
        const policyPath = join(basePath, 'packs', 'stable', `${options.policy}.json`);
        if (existsSync(policyPath)) {
            policy = JSON.parse(readFileSync(policyPath, 'utf-8'));
            logger.info(`Loaded policy: ${policy.id}@${policy.version}`);
        }
        else {
            throw new Error(`Policy not found: ${policyPath}`);
        }
    }
    else {
        // Use default policy (first AOI-enabled policy)
        logger.info('No policy specified, using first AOI-enabled policy');
        const policiesPath = join(basePath, 'packs', 'stable');
        if (existsSync(policiesPath)) {
            const files = require('fs').readdirSync(policiesPath).filter((f) => f.endsWith('.json'));
            for (const file of files) {
                const p = JSON.parse(readFileSync(join(policiesPath, file), 'utf-8'));
                if (p.aoi?.enabled) {
                    policy = p;
                    logger.info(`Using policy: ${policy.id}@${policy.version}`);
                    break;
                }
            }
        }
        if (!policy) {
            throw new Error('No AOI-enabled policies found');
        }
    }
    // Initialize AOI coordinator
    const aiProvider = createAIProvider();
    const coordinator = new MockAOICoordinator();
    logger.info(`Detecting AOI for PR #${prData.number}: "${prData.title}"`);
    // Create mock violation from PR
    const violation = {
        rule_id: 'manual-aoi-trigger',
        message: `Manual AOI trigger for PR #${prData.number}: ${prData.title}`,
        severity: 'error',
        location: {
            file: prData.files[0]?.path || 'unknown',
        },
    };
    // Generate AOI spec
    const startTime = Date.now();
    const spec = await coordinator.generateSpec(violation, policy, prData);
    const latencyMs = Date.now() - startTime;
    logger.success(`AOI spec generated in ${latencyMs}ms`);
    // Check component similarity
    const threshold = policy.aoi?.threshold || 0.8;
    const framework = policy.aoi?.framework || '';
    const similarityResult = await coordinator.checkComponentExists(spec.name, framework, threshold);
    // Route to owners (if applicable)
    let actions = [];
    if (!similarityResult.exists) {
        actions = await coordinator.routeToOwners(spec, policy);
        logger.info(`Generated ${actions.length} action(s)`);
    }
    else {
        logger.info(`Component exists (similarity: ${(similarityResult.closest_match.similarity_score * 100).toFixed(1)}%)`);
        logger.info('Skipping AOI generation');
    }
    // Output result
    if (options.json) {
        console.log(JSON.stringify({
            spec,
            similarity_result: similarityResult,
            actions,
            metadata: {
                latency_ms: latencyMs,
                cost_usd: spec.metadata.cost_usd,
            },
        }, null, 2));
    }
    else {
        printAOISpec(logger, spec, similarityResult, actions, options.verbose || false);
    }
}
/**
 * Check component similarity
 */
export async function runAOICheck(logger, options) {
    const basePath = options.basePath || '.mlang';
    // Load AOI config
    const config = loadAOIConfig(basePath);
    const framework = options.framework || config.frameworks[0] || '';
    const threshold = options.threshold !== undefined ? options.threshold : config.similarity_threshold;
    // Validate threshold
    if (threshold < 0 || threshold > 1) {
        throw new Error('Threshold must be between 0.0 and 1.0');
    }
    logger.info(`Checking component: "${options.component}"`);
    logger.info(`Framework: ${framework || '(none)'}`);
    logger.info(`Threshold: ${threshold}`);
    // Initialize AOI coordinator
    const aiProvider = createAIProvider();
    const coordinator = new MockAOICoordinator();
    // Check component exists
    const startTime = Date.now();
    const result = await coordinator.checkComponentExists(options.component, framework, threshold);
    const latencyMs = Date.now() - startTime;
    // Output result
    if (options.json) {
        console.log(JSON.stringify(result, null, 2));
    }
    else {
        printSimilarityResult(logger, result, latencyMs, options.verbose || false);
    }
}
/**
 * List pending AOI actions
 */
export async function runAOIActions(logger, options) {
    const basePath = options.basePath || '.mlang';
    const actionsPath = join(basePath, 'aoi', 'actions.json');
    if (!existsSync(actionsPath)) {
        logger.info('No AOI actions found.');
        return;
    }
    // Load actions
    const allActions = JSON.parse(readFileSync(actionsPath, 'utf-8'));
    // Filter by PR if specified
    let actions = allActions;
    if (options.pr) {
        actions = actions.filter((a) => a.payload?.pr?.number === parseInt(options.pr, 10));
    }
    // Filter by status if specified
    if (options.status) {
        actions = actions.filter((a) => a.status === options.status);
    }
    if (actions.length === 0) {
        logger.info('No matching AOI actions found.');
        return;
    }
    // Output actions
    if (options.json) {
        console.log(JSON.stringify(actions, null, 2));
    }
    else {
        printAOIActions(logger, actions, options.verbose || false);
    }
}
/**
 * Show AOI configuration
 */
export async function runAOIConfig(logger, options) {
    const basePath = options.basePath || '.mlang';
    const config = loadAOIConfig(basePath);
    // Output config
    if (options.json) {
        console.log(JSON.stringify(config, null, 2));
    }
    else {
        printAOIConfig(logger, config, options.verbose || false);
    }
}
// ============================================================================
// Helper Functions
// ============================================================================
/**
 * Load AOI configuration
 */
function loadAOIConfig(basePath) {
    const configPath = join(basePath, 'aoi-config.json');
    // Default config
    const defaultConfig = {
        enabled: true,
        similarity_threshold: 0.8,
        auto_create_counter_pr: false,
        auto_create_followup_pr: false,
        include_tests: true,
        frameworks: [],
        policies: {},
    };
    if (!existsSync(configPath)) {
        return defaultConfig;
    }
    const userConfig = JSON.parse(readFileSync(configPath, 'utf-8'));
    return { ...defaultConfig, ...userConfig };
}
/**
 * Print AOI spec (human-readable)
 */
function printAOISpec(logger, spec, similarityResult, actions, verbose) {
    console.log();
    console.log(chalk.bold.cyan('AOI Specification Generated'));
    console.log();
    console.log(chalk.bold('Component:'));
    console.log(`  Name: ${spec.name}`);
    console.log(`  Description: ${spec.description}`);
    console.log(`  Framework: ${spec.framework}`);
    console.log();
    console.log(chalk.bold('Specification:'));
    console.log(chalk.dim(spec.specification));
    console.log();
    if (spec.examples.length > 0) {
        console.log(chalk.bold('Code Examples:'));
        spec.examples.forEach((example, i) => {
            console.log(`  ${i + 1}. ${example.file} (${example.language})`);
            if (verbose) {
                console.log(chalk.dim(`     ${example.code.substring(0, 100)}...`));
            }
        });
        console.log();
    }
    console.log(chalk.bold('Similarity Check:'));
    console.log(`  Exists: ${similarityResult.exists ? chalk.green('Yes') : chalk.red('No')}`);
    console.log(`  Threshold: ${similarityResult.threshold}`);
    if (similarityResult.closest_match) {
        console.log(`  Closest: ${similarityResult.closest_match.component}`);
        console.log(`  Score: ${(similarityResult.closest_match.similarity_score * 100).toFixed(1)}%`);
    }
    console.log();
    if (actions.length > 0) {
        console.log(chalk.bold('Actions Generated:'));
        actions.forEach((action, i) => {
            const statusIcon = action.status === 'completed' ? '✓' : action.status === 'failed' ? '✗' : '○';
            console.log(`  ${i + 1}. ${statusIcon} ${action.type}`);
            if (action.target?.url) {
                console.log(chalk.dim(`     ${action.target.url}`));
            }
        });
        console.log();
    }
    console.log(chalk.bold('Metadata:'));
    console.log(`  ID: ${spec.id}`);
    console.log(`  Owners: ${spec.owners.join(', ') || '(none)'}`);
    console.log(`  Cost: $${spec.metadata.cost_usd.toFixed(4)}`);
    console.log(`  Generated: ${spec.metadata.generated_at}`);
    console.log();
}
/**
 * Print similarity result (human-readable)
 */
function printSimilarityResult(logger, result, latencyMs, verbose) {
    console.log();
    console.log(chalk.bold('Component Similarity Check'));
    console.log();
    console.log(chalk.bold('Query:'));
    console.log(`  "${result.metadata.query}"`);
    console.log();
    console.log(chalk.bold('Result:'));
    console.log(`  Exists: ${result.exists ? chalk.green('Yes') : chalk.red('No')}`);
    console.log(`  Threshold: ${result.threshold}`);
    console.log(`  Candidates: ${result.metadata.total_candidates}`);
    console.log(`  Latency: ${latencyMs}ms`);
    console.log();
    if (result.exists && result.closest_match) {
        console.log(chalk.bold('Closest Match:'));
        console.log(`  Component: ${result.closest_match.component}`);
        console.log(`  Similarity: ${chalk.green((result.closest_match.similarity_score * 100).toFixed(1) + '%')}`);
        if (result.closest_match.location) {
            console.log(`  Location: ${result.closest_match.location}`);
        }
        if (verbose && result.closest_match.description) {
            console.log(`  Description: ${result.closest_match.description}`);
        }
        console.log();
    }
    if (result.matches.length > 1 && verbose) {
        console.log(chalk.bold('Other Matches:'));
        result.matches.slice(1, 5).forEach((match, i) => {
            console.log(`  ${i + 1}. ${match.component}`);
            console.log(`     Similarity: ${(match.similarity_score * 100).toFixed(1)}%`);
        });
        console.log();
    }
    if (!result.exists) {
        console.log(chalk.yellow('Recommendation:'));
        console.log('  Component does not exist. Consider creating via AOI:');
        console.log(chalk.dim(`  mlang aoi generate --pr <pr-file> --policy <policy-id>`));
        console.log();
    }
    else {
        console.log(chalk.green('Recommendation:'));
        console.log(`  Use existing component: ${result.closest_match.component}`);
        console.log();
    }
}
/**
 * Print AOI actions (human-readable)
 */
function printAOIActions(logger, actions, verbose) {
    console.log();
    console.log(chalk.bold(`AOI Actions (${actions.length})`));
    console.log();
    // Group by type
    const byType = actions.reduce((acc, action) => {
        if (!acc[action.type]) {
            acc[action.type] = [];
        }
        acc[action.type].push(action);
        return acc;
    }, {});
    for (const [type, typeActions] of Object.entries(byType)) {
        console.log(chalk.bold(`${type} (${typeActions.length}):`));
        typeActions.forEach((action, i) => {
            const statusIcon = action.status === 'completed'
                ? chalk.green('✓')
                : action.status === 'failed'
                    ? chalk.red('✗')
                    : action.status === 'pending'
                        ? chalk.yellow('○')
                        : chalk.gray('○');
            console.log(`  ${i + 1}. ${statusIcon} ${action.status.toUpperCase()}`);
            if (action.target?.url) {
                console.log(chalk.dim(`     URL: ${action.target.url}`));
            }
            if (verbose && action.payload?.spec) {
                const spec = action.payload.spec;
                console.log(chalk.dim(`     Spec: ${spec.name}`));
            }
            if (action.metadata?.error) {
                console.log(chalk.red(`     Error: ${action.metadata.error}`));
            }
        });
        console.log();
    }
    // Summary
    const completed = actions.filter((a) => a.status === 'completed').length;
    const failed = actions.filter((a) => a.status === 'failed').length;
    const pending = actions.filter((a) => a.status === 'pending').length;
    console.log(chalk.bold('Summary:'));
    console.log(`  Total: ${actions.length}`);
    console.log(`  Completed: ${chalk.green(completed.toString())}`);
    console.log(`  Failed: ${chalk.red(failed.toString())}`);
    console.log(`  Pending: ${chalk.yellow(pending.toString())}`);
    console.log();
}
/**
 * Print AOI config (human-readable)
 */
function printAOIConfig(logger, config, verbose) {
    console.log();
    console.log(chalk.bold('AOI Configuration'));
    console.log();
    console.log(chalk.bold('General:'));
    console.log(`  Enabled: ${config.enabled ? chalk.green('Yes') : chalk.red('No')}`);
    console.log(`  Similarity Threshold: ${config.similarity_threshold}`);
    console.log();
    console.log(chalk.bold('Automation:'));
    console.log(`  Auto-create Counter-PR: ${config.auto_create_counter_pr ? chalk.green('Yes') : chalk.red('No')}`);
    console.log(`  Auto-create Follow-up PR: ${config.auto_create_followup_pr ? chalk.green('Yes') : chalk.red('No')}`);
    console.log(`  Include Tests: ${config.include_tests ? chalk.green('Yes') : chalk.red('No')}`);
    console.log();
    if (config.frameworks.length > 0) {
        console.log(chalk.bold('Frameworks:'));
        config.frameworks.forEach((framework, i) => {
            console.log(`  ${i + 1}. ${framework}`);
        });
        console.log();
    }
    if (verbose && Object.keys(config.policies).length > 0) {
        console.log(chalk.bold('Policy-specific Settings:'));
        for (const [policyId, settings] of Object.entries(config.policies)) {
            console.log(`  ${policyId}:`);
            console.log(chalk.dim(`    ${JSON.stringify(settings, null, 2)}`));
        }
        console.log();
    }
}
//# sourceMappingURL=aoi.js.map