/**
 * Policy Compiler - Normalize, validate, and version policy cards
 *
 * Produces canonical JSON with stable hashing for signing.
 */
import { createHash } from 'node:crypto';
import { validateConstraints, checkPolicySize } from './parser.js';
/**
 * Compile parsed policies into canonical unsigned cards
 */
export function compilePolicies(policies, options = {}) {
    const compiled = [];
    const errors = [];
    const version = options.version || generateDefaultVersion();
    for (const policy of policies) {
        try {
            const result = compilePolicy(policy, version, options);
            compiled.push(result);
            // Fail on warnings if strict mode
            if (options.strict && result.warnings.length > 0) {
                errors.push({
                    file: policy.sourcePath,
                    error: `Strict mode: ${result.warnings.join(', ')}`,
                    code: 'validation_error',
                });
            }
        }
        catch (error) {
            errors.push({
                file: policy.sourcePath,
                error: error instanceof Error ? error.message : String(error),
                code: 'configuration_error',
            });
        }
    }
    return { compiled, errors };
}
/**
 * Compile a single policy
 */
function compilePolicy(policy, version, options) {
    const warnings = [];
    // Normalize and validate constraints if present
    if (policy.card.constraints) {
        const constraintErrors = validateConstraints(policy.card.constraints);
        if (constraintErrors.length > 0) {
            throw new Error(`Invalid constraints: ${constraintErrors.join(', ')}`);
        }
    }
    // Build canonical card
    const card = {
        id: policy.card.id,
        version,
        scope: policy.card.scope,
        role: policy.card.role,
    };
    // Copy optional fields
    if (policy.card.title)
        card.title = policy.card.title;
    if (policy.card.description)
        card.description = policy.card.description;
    if (policy.card.tags)
        card.tags = policy.card.tags;
    // Normalize constraints if present
    if (policy.card.constraints) {
        card.constraints = normalizeConstraints(policy.card.constraints);
    }
    // Optional: on_violation
    if (policy.card.on_violation) {
        card.on_violation = policy.card.on_violation;
    }
    // Check size
    const { ok, size } = checkPolicySize(card);
    if (!ok) {
        throw new Error(`Policy card too large: ${size} bytes (max 64 KB). Move examples to Markdown body.`);
    }
    // Warn if approaching size limit
    if (size > 48 * 1024) {
        warnings.push(`Policy card is large (${Math.round(size / 1024)} KB). Consider simplifying.`);
    }
    return {
        card,
        warnings,
        sourcePath: policy.sourcePath,
        body: policy.body,
        structuredSections: policy.structuredSections,
    };
}
/**
 * Normalize constraints for stable hashing
 * - Sort object keys alphabetically
 * - Recursively normalize nested objects
 * - Preserve arrays as-is (order matters for semantics)
 */
function normalizeConstraints(constraints) {
    const normalized = {};
    // Sort keys alphabetically
    const keys = Object.keys(constraints).sort();
    for (const key of keys) {
        const value = constraints[key];
        if (value === null || value === undefined) {
            normalized[key] = value;
        }
        else if (Array.isArray(value)) {
            // Preserve array order
            normalized[key] = value;
        }
        else if (typeof value === 'object') {
            // Recursively normalize nested objects
            normalized[key] = normalizeConstraints(value);
        }
        else {
            // Scalars: boolean, number, string
            normalized[key] = value;
        }
    }
    return normalized;
}
/**
 * Generate default version: YYYY.MM.DD
 */
export function generateDefaultVersion() {
    const now = new Date();
    const yyyy = now.getFullYear();
    const mm = String(now.getMonth() + 1).padStart(2, '0');
    const dd = String(now.getDate()).padStart(2, '0');
    return `${yyyy}.${mm}.${dd}`;
}
/**
 * Compute stable hash of policy card for signing
 * Uses canonical JSON (sorted keys) to ensure determinism
 */
export function computePolicyHash(card) {
    // Serialize to canonical JSON
    const canonical = JSON.stringify(card, Object.keys(card).sort());
    // Compute SHA-256 hash
    const hash = createHash('sha256').update(canonical, 'utf-8').digest('hex');
    return hash;
}
/**
 * Sort all keys in an object recursively for canonical JSON
 */
function sortKeysDeep(obj) {
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    if (Array.isArray(obj)) {
        return obj.map(sortKeysDeep);
    }
    const sorted = {};
    const keys = Object.keys(obj).sort();
    for (const key of keys) {
        sorted[key] = sortKeysDeep(obj[key]);
    }
    return sorted;
}
/**
 * Prepare card for JSON serialization (canonical form)
 */
export function canonicalizeCard(card) {
    return sortKeysDeep(card);
}
//# sourceMappingURL=compiler.js.map