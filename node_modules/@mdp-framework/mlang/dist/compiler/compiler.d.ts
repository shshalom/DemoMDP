/**
 * Policy Compiler - Normalize, validate, and version policy cards
 *
 * Produces canonical JSON with stable hashing for signing.
 */
import type { PolicyCard } from '@mdp-framework/schemas/contracts';
import type { ParsedPolicy } from './parser.js';
export interface CompileOptions {
    /** Override version (default: YYYY.MM.DD) */
    version?: string;
    /** Strict validation (fail on warnings) */
    strict?: boolean;
}
export interface CompileResult {
    /** Compiled unsigned policy card */
    card: Omit<PolicyCard, 'hash' | 'signature'>;
    /** Warnings (non-fatal issues) */
    warnings: string[];
    /** Source file */
    sourcePath: string;
    /** Original markdown body */
    body: string;
    /** Structured sections */
    structuredSections?: {
        purpose?: string;
        detection?: string;
        exceptions?: string;
        examples?: string;
        remediation?: string;
        references?: string;
    };
}
export interface CompileError {
    file: string;
    error: string;
    code: 'configuration_error' | 'invalid_constraint_type' | 'oversized_card' | 'validation_error';
}
/**
 * Compile parsed policies into canonical unsigned cards
 */
export declare function compilePolicies(policies: ParsedPolicy[], options?: CompileOptions): {
    compiled: CompileResult[];
    errors: CompileError[];
};
/**
 * Generate default version: YYYY.MM.DD
 */
export declare function generateDefaultVersion(): string;
/**
 * Compute stable hash of policy card for signing
 * Uses canonical JSON (sorted keys) to ensure determinism
 */
export declare function computePolicyHash(card: Omit<PolicyCard, 'hash' | 'signature'>): string;
/**
 * Prepare card for JSON serialization (canonical form)
 */
export declare function canonicalizeCard(card: Omit<PolicyCard, 'hash' | 'signature'>): unknown;
//# sourceMappingURL=compiler.d.ts.map