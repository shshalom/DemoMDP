/**
 * Policy Signer - Ed25519 signing for policy cards
 *
 * Signs compiled policy cards with organization private keys.
 * Verification uses public keys pinned in .mlang/keys/
 */
import { readFile, writeFile } from 'node:fs/promises';
import * as ed25519 from '@noble/ed25519';
import { computePolicyHash } from './compiler.js';
/**
 * Sign a policy card with ed25519 private key
 */
export async function signPolicy(card, options) {
    // Load or use provided private key
    const privateKey = options.privateKey || (await loadPrivateKey(options.keyFile));
    // Compute hash
    const hash = computePolicyHash(card);
    // Sign hash (not the full JSON)
    const hashBytes = Buffer.from(hash, 'hex');
    const signatureBytes = await ed25519.sign(hashBytes, privateKey);
    // Encode signature as hex
    const signature = Buffer.from(signatureBytes).toString('hex');
    return {
        ...card,
        hash,
        signature,
    };
}
/**
 * Verify a signed policy card with ed25519 public key
 */
export async function verifyPolicy(card, options) {
    // Load or use provided public key
    const publicKey = options.publicKey || (await loadPublicKey(options.keyFile));
    // Extract signature and hash
    const { signature, hash, ...unsigned } = card;
    if (!signature || !hash) {
        return { ok: false, error: 'Missing signature or hash' };
    }
    // Recompute hash to verify integrity
    const computedHash = computePolicyHash(unsigned);
    if (computedHash !== hash) {
        return { ok: false, error: 'Hash mismatch: card has been modified' };
    }
    // Verify signature
    try {
        const hashBytes = Buffer.from(hash, 'hex');
        const signatureBytes = Buffer.from(signature, 'hex');
        const valid = await ed25519.verify(signatureBytes, hashBytes, publicKey);
        if (!valid) {
            return { ok: false, error: 'Invalid signature' };
        }
        return { ok: true };
    }
    catch (error) {
        return { ok: false, error: `Verification failed: ${error instanceof Error ? error.message : String(error)}` };
    }
}
/**
 * Load private key from file (hex or base64)
 */
async function loadPrivateKey(path) {
    const content = await readFile(path, 'utf-8');
    const trimmed = content.trim();
    // Try hex first (64 chars = 32 bytes)
    if (/^[0-9a-f]{64}$/i.test(trimmed)) {
        return Buffer.from(trimmed, 'hex');
    }
    // Try base64
    try {
        const decoded = Buffer.from(trimmed, 'base64');
        if (decoded.length === 32) {
            return decoded;
        }
    }
    catch {
        // Fall through
    }
    throw new Error(`Invalid private key format in ${path}. Expected 32-byte hex or base64.`);
}
/**
 * Load public key from file (hex or base64)
 */
async function loadPublicKey(path) {
    const content = await readFile(path, 'utf-8');
    const trimmed = content.trim();
    // Try hex first (64 chars = 32 bytes)
    if (/^[0-9a-f]{64}$/i.test(trimmed)) {
        return Buffer.from(trimmed, 'hex');
    }
    // Try base64
    try {
        const decoded = Buffer.from(trimmed, 'base64');
        if (decoded.length === 32) {
            return decoded;
        }
    }
    catch {
        // Fall through
    }
    throw new Error(`Invalid public key format in ${path}. Expected 32-byte hex or base64.`);
}
/**
 * Generate a new ed25519 key pair
 */
export async function generateKeyPair() {
    const privateKey = ed25519.utils.randomPrivateKey();
    const publicKey = await ed25519.getPublicKey(privateKey);
    return { privateKey, publicKey };
}
/**
 * Save key pair to files (hex format)
 */
export async function saveKeyPair(privateKey, publicKey, basePath) {
    const privateHex = Buffer.from(privateKey).toString('hex');
    const publicHex = Buffer.from(publicKey).toString('hex');
    await writeFile(`${basePath}.ed25519`, privateHex, { mode: 0o600 });
    await writeFile(`${basePath}.pub`, publicHex, { mode: 0o644 });
}
//# sourceMappingURL=signer.js.map