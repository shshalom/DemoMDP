/**
 * Policy Parser - Extract frontmatter from Markdown policy files
 *
 * Reads .md files from policies directory and parses YAML frontmatter
 * into PolicyCard structure for compilation.
 */
import { readFile, readdir } from 'node:fs/promises';
import { join } from 'node:path';
import matter from 'gray-matter';
/**
 * Parse all policy files in a directory
 */
export async function parsePolicyDir(dir) {
    const policies = [];
    const errors = [];
    try {
        const entries = await readdir(dir);
        const mdFiles = entries.filter((f) => f.endsWith('.md'));
        for (const file of mdFiles) {
            const filePath = join(dir, file);
            try {
                const parsed = await parsePolicyFile(filePath);
                policies.push(parsed);
            }
            catch (error) {
                errors.push({
                    file,
                    error: error instanceof Error ? error.message : String(error),
                });
            }
        }
    }
    catch (error) {
        errors.push({
            file: dir,
            error: `Failed to read directory: ${error instanceof Error ? error.message : String(error)}`,
        });
    }
    return { policies, errors };
}
/**
 * Extract structured sections from markdown body
 * Looks for pattern: ## SectionName\n---\ncontent\n---
 */
export function extractStructuredSections(body) {
    const sections = {};
    // Regex to match: ## SectionName\n---\ncontent\n---
    const sectionRegex = /##\s+(\w+)\s*\n---\s*\n([\s\S]*?)\n---/gi;
    let match;
    while ((match = sectionRegex.exec(body)) !== null) {
        const sectionName = match[1].toLowerCase();
        const sectionContent = match[2].trim();
        // Map to known section names
        if (['purpose', 'detection', 'exceptions', 'examples', 'remediation', 'references'].includes(sectionName)) {
            sections[sectionName] = sectionContent;
        }
    }
    // Return undefined if no structured sections found (backward compatibility)
    return Object.keys(sections).length > 0 ? sections : undefined;
}
/**
 * Parse a single policy file
 */
export async function parsePolicyFile(filePath) {
    const content = await readFile(filePath, 'utf-8');
    const { data: frontmatter, content: body } = matter(content);
    // Validate required fields
    if (!frontmatter.id) {
        throw new Error('Missing required field: id');
    }
    if (!frontmatter.scope) {
        throw new Error('Missing required field: scope');
    }
    if (!frontmatter.role) {
        throw new Error('Missing required field: role');
    }
    // Validate id format (simple check for namespace)
    if (typeof frontmatter.id !== 'string' || !frontmatter.id.includes('.')) {
        throw new Error(`Invalid id format: ${frontmatter.id} (expected namespaced format like 'eng.pr.review')`);
    }
    // Validate scope format
    const validScopes = ['repo', 'org', 'team', 'global'];
    if (!validScopes.includes(frontmatter.scope)) {
        throw new Error(`Invalid scope: ${frontmatter.scope} (expected one of: ${validScopes.join(', ')})`);
    }
    // Validate role
    if (typeof frontmatter.role !== 'string') {
        throw new Error('role must be a string');
    }
    // Build unsigned policy card
    const card = {
        id: frontmatter.id,
        version: frontmatter.version || '', // Will be set by compiler
        scope: frontmatter.scope,
        role: frontmatter.role,
    };
    // Optional fields
    if (frontmatter.title)
        card.title = frontmatter.title;
    if (frontmatter.description)
        card.description = frontmatter.description;
    if (frontmatter.tags)
        card.tags = frontmatter.tags;
    // Optional: constraints
    if (frontmatter.constraints) {
        if (typeof frontmatter.constraints !== 'object' || Array.isArray(frontmatter.constraints)) {
            throw new Error('constraints must be an object');
        }
        card.constraints = frontmatter.constraints;
    }
    // Optional: on_violation
    if (frontmatter.on_violation) {
        if (!Array.isArray(frontmatter.on_violation)) {
            throw new Error('on_violation must be an array');
        }
        card.on_violation = frontmatter.on_violation;
    }
    // Extract structured sections if present
    const structuredSections = extractStructuredSections(body.trim());
    return {
        card,
        body: body.trim(),
        sourcePath: filePath,
        structuredSections,
    };
}
/**
 * Validate constraint types (loose validation for v1)
 */
export function validateConstraints(constraints) {
    const errors = [];
    for (const [key, value] of Object.entries(constraints)) {
        // Allow scalar types and nested objects
        const type = typeof value;
        if (type === 'function' || type === 'symbol') {
            errors.push(`Invalid constraint type for '${key}': ${type}`);
        }
        // Check for oversized strings (avoid bloat)
        if (type === 'string' && value.length > 1000) {
            errors.push(`Constraint '${key}' string too long (max 1000 chars)`);
        }
        // Recursively validate nested objects
        if (type === 'object' && value !== null && !Array.isArray(value)) {
            const nested = validateConstraints(value);
            errors.push(...nested.map((e) => `${key}.${e}`));
        }
    }
    return errors;
}
/**
 * Check if policy card would be oversized when serialized
 */
export function checkPolicySize(card) {
    const json = JSON.stringify(card);
    const size = Buffer.byteLength(json, 'utf-8');
    const MAX_SIZE = 64 * 1024; // 64 KB
    return { ok: size < MAX_SIZE, size };
}
//# sourceMappingURL=parser.js.map