/**
 * Policy Resolver - Channel to version resolution at snapshot time (t₀)
 *
 * Responsibilities:
 * - Resolve channels (@stable, @preview, @dev) to versioned IDs (id@YYYY.MM.DD) at t₀
 * - Record snapshot_time in Envelope
 * - Emit resolved policy_ids in policy://org/id@YYYY.MM.DD format (NEVER channels)
 * - Handle precedence for forked PRs (PR target repo > base repo > forked repo)
 * - LKG (Last Known Good) fallback (stub with TODO for now)
 *
 * @since M2 (Team A)
 */
import { type PolicyCard, type Envelope } from '@mdp-framework/schemas/contracts';
import { PolicyRegistry } from '@mdp-framework/adapters';
/**
 * Resolver configuration
 */
export interface ResolverConfig {
    /**
     * Registry instances in precedence order (for forked PRs)
     * [0] = PR target repo (highest precedence)
     * [1] = base repo
     * [2] = forked repo (lowest precedence)
     */
    registries: PolicyRegistry[];
    /**
     * Default channel to use if not specified
     */
    defaultChannel?: 'stable' | 'preview' | 'dev';
    /**
     * Enable LKG fallback (stub for M2)
     */
    enableLKG?: boolean;
    /**
     * LKG cache path (for future implementation)
     */
    lkgCachePath?: string;
}
/**
 * Resolution context
 */
export interface ResolutionContext {
    /**
     * Role to policy ID mapping
     * e.g., { pr: "eng.pr.review", design: "ui.design.tokens" }
     */
    roles: Record<string, string>;
    /**
     * Channel to use for resolution
     */
    channel: 'stable' | 'preview' | 'dev';
    /**
     * Snapshot time (t₀) - when resolution happens
     * ISO 8601 timestamp
     */
    snapshotTime?: string;
}
/**
 * Resolution result
 */
export interface ResolutionResult {
    /**
     * Resolved policy cards
     */
    policies: PolicyCard[];
    /**
     * Resolved policy IDs in policy://org/id@YYYY.MM.DD format
     */
    policyIds: string[];
    /**
     * Snapshot time (t₀) when resolution occurred
     */
    snapshotTime: string;
    /**
     * Channel used for resolution
     */
    channel: string;
    /**
     * Whether LKG fallback was used
     */
    degraded: boolean;
    /**
     * Resolution metadata (for tracing)
     */
    metadata: {
        resolvedAt: string;
        resolvedBy: string;
        precedence: string[];
        failures?: Array<{
            id: string;
            reason: string;
        }>;
    };
}
/**
 * PolicyResolver - Resolves channels to versioned policies at t₀
 */
export declare class PolicyResolver {
    private config;
    constructor(config: ResolverConfig);
    /**
     * Resolve policies for given context at snapshot time t₀
     *
     * @param context - Resolution context (roles, channel)
     * @returns Resolved policies with metadata
     */
    resolve(context: ResolutionContext): Promise<ResolutionResult>;
    /**
     * Resolve a single policy ID using precedence order
     *
     * Precedence (per Docs/Build Steps/Step 7.1):
     * 1. PR target repo (highest)
     * 2. Base repo
     * 3. Forked repo (lowest)
     */
    private resolvePolicy;
    /**
     * Format policy ID in policy://org/id@YYYY.MM.DD format
     *
     * CRITICAL: Must NEVER output channels - golden tests will catch this
     */
    private formatPolicyId;
    /**
     * Compare two version strings (YYYY.MM.DD format)
     *
     * @returns -1 if v1 < v2, 0 if equal, 1 if v1 > v2
     */
    private compareVersions;
    /**
     * Enrich envelope with resolved policy information
     *
     * @param envelope - Envelope to enrich
     * @param resolution - Resolution result
     * @returns Enriched envelope
     */
    enrichEnvelope(envelope: Envelope, resolution: ResolutionResult): Envelope;
}
/**
 * Create a policy resolver
 *
 * @param config - Resolver configuration
 * @returns PolicyResolver instance
 */
export declare function createResolver(config: ResolverConfig): PolicyResolver;
/**
 * Resolve policies from registry paths with precedence
 *
 * Helper for common use case: forked PR with multiple .mlang directories
 *
 * @param paths - Registry paths in precedence order
 * @param context - Resolution context
 * @returns Resolution result
 */
export declare function resolveWithPrecedence(paths: string[], context: ResolutionContext): Promise<ResolutionResult>;
//# sourceMappingURL=resolver.d.ts.map