/**
 * Policy Resolver - Channel to version resolution at snapshot time (t₀)
 *
 * Responsibilities:
 * - Resolve channels (@stable, @preview, @dev) to versioned IDs (id@YYYY.MM.DD) at t₀
 * - Record snapshot_time in Envelope
 * - Emit resolved policy_ids in policy://org/id@YYYY.MM.DD format (NEVER channels)
 * - Handle precedence for forked PRs (PR target repo > base repo > forked repo)
 * - LKG (Last Known Good) fallback (stub with TODO for now)
 *
 * @since M2 (Team A)
 */
/**
 * PolicyResolver - Resolves channels to versioned policies at t₀
 */
export class PolicyResolver {
    config;
    constructor(config) {
        this.config = {
            defaultChannel: 'stable',
            enableLKG: false,
            ...config,
        };
    }
    /**
     * Resolve policies for given context at snapshot time t₀
     *
     * @param context - Resolution context (roles, channel)
     * @returns Resolved policies with metadata
     */
    async resolve(context) {
        const snapshotTime = context.snapshotTime || new Date().toISOString();
        const channel = context.channel || this.config.defaultChannel || 'stable';
        const resolvedPolicies = new Map();
        const failures = [];
        // Extract unique policy IDs from roles
        const policyIds = Array.from(new Set(Object.values(context.roles)));
        // Resolve each policy ID
        for (const policyId of policyIds) {
            const result = await this.resolvePolicy(policyId, channel);
            if (result.ok && result.data) {
                // De-duplicate: keep newest version if multiple exist
                const existing = resolvedPolicies.get(policyId);
                if (!existing || this.compareVersions(result.data.version, existing.version) > 0) {
                    resolvedPolicies.set(policyId, result.data);
                }
            }
            else {
                failures.push({
                    id: policyId,
                    reason: result.error?.message || 'Unknown error',
                });
                // TODO: M2 - LKG fallback stub
                if (this.config.enableLKG) {
                    // TODO: Implement LKG cache lookup
                    // For now, we just record that LKG would be attempted
                    failures.push({
                        id: policyId,
                        reason: 'LKG fallback not yet implemented (TODO: M2)',
                    });
                }
            }
        }
        // Convert to arrays and sort for stability
        const policies = Array.from(resolvedPolicies.values()).sort((a, b) => {
            // Sort by ID first, then by version
            if (a.id !== b.id)
                return a.id.localeCompare(b.id);
            return this.compareVersions(a.version, b.version);
        });
        // Generate versioned policy IDs in policy://org/id@YYYY.MM.DD format
        const versionedIds = policies.map((p) => this.formatPolicyId(p.id, p.version));
        return {
            policies,
            policyIds: versionedIds,
            snapshotTime,
            channel,
            degraded: failures.length > 0 && this.config.enableLKG === true,
            metadata: {
                resolvedAt: snapshotTime,
                resolvedBy: 'PolicyResolver',
                precedence: this.config.registries.map((_, i) => `registry[${i}]`),
                failures: failures.length > 0 ? failures : undefined,
            },
        };
    }
    /**
     * Resolve a single policy ID using precedence order
     *
     * Precedence (per Docs/Build Steps/Step 7.1):
     * 1. PR target repo (highest)
     * 2. Base repo
     * 3. Forked repo (lowest)
     */
    async resolvePolicy(policyId, channel) {
        // Try each registry in precedence order
        for (const registry of this.config.registries) {
            // Get channel pointer to resolve to version
            const channelResult = await registry.getChannel(policyId, channel);
            if (channelResult.ok && channelResult.data) {
                const version = channelResult.data;
                // Fetch the policy card at this version
                const cardResult = await registry.get(policyId, version);
                if (cardResult.ok && cardResult.data) {
                    return cardResult;
                }
            }
        }
        // No registry had the policy
        return {
            ok: false,
            error: {
                code: 'NOT_FOUND',
                message: `Policy not found in any registry: ${policyId}@${channel}`,
            },
        };
    }
    /**
     * Format policy ID in policy://org/id@YYYY.MM.DD format
     *
     * CRITICAL: Must NEVER output channels - golden tests will catch this
     */
    formatPolicyId(id, version) {
        // Validate version format (YYYY.MM.DD)
        if (!/^\d{4}\.\d{2}\.\d{2}$/.test(version)) {
            throw new Error(`Invalid version format: ${version}. Expected YYYY.MM.DD`);
        }
        // Return in policy://org/id@version format
        // For M2, we assume single org "org" - TODO: make configurable
        return `policy://org/${id}@${version}`;
    }
    /**
     * Compare two version strings (YYYY.MM.DD format)
     *
     * @returns -1 if v1 < v2, 0 if equal, 1 if v1 > v2
     */
    compareVersions(v1, v2) {
        const parts1 = v1.split('.').map(Number);
        const parts2 = v2.split('.').map(Number);
        for (let i = 0; i < 3; i++) {
            if (parts1[i] < parts2[i])
                return -1;
            if (parts1[i] > parts2[i])
                return 1;
        }
        return 0;
    }
    /**
     * Enrich envelope with resolved policy information
     *
     * @param envelope - Envelope to enrich
     * @param resolution - Resolution result
     * @returns Enriched envelope
     */
    enrichEnvelope(envelope, resolution) {
        return {
            ...envelope,
            policy_ids: resolution.policyIds,
            resolver: {
                snapshot_time: resolution.snapshotTime,
                channel: resolution.channel,
                degraded: resolution.degraded,
            },
        };
    }
}
/**
 * Create a policy resolver
 *
 * @param config - Resolver configuration
 * @returns PolicyResolver instance
 */
export function createResolver(config) {
    return new PolicyResolver(config);
}
/**
 * Resolve policies from registry paths with precedence
 *
 * Helper for common use case: forked PR with multiple .mlang directories
 *
 * @param paths - Registry paths in precedence order
 * @param context - Resolution context
 * @returns Resolution result
 */
export async function resolveWithPrecedence(paths, context) {
    // Create registries for each path
    const registries = paths.map((path) => {
        const { PolicyRegistry } = require('@mdp-framework/adapters');
        return new PolicyRegistry({ basePath: path });
    });
    const resolver = createResolver({ registries });
    return resolver.resolve(context);
}
//# sourceMappingURL=resolver.js.map