/**
 * Prompt Builder (Stream 2)
 *
 * Constructs prompts for AI-powered policy evaluation.
 * Optimizes for token efficiency while preserving context.
 */
import { SYSTEM_PROMPT, PR_EVALUATION_TEMPLATE, FEATURE_EVALUATION_TEMPLATE } from './templates.js';
/**
 * Maximum content size for a single file (in characters)
 * Prevents token explosion from large files
 */
const MAX_FILE_CONTENT_SIZE = 10000;
/**
 * Maximum number of files to include in prompt
 * Prevents context window overflow
 */
const MAX_FILES_IN_PROMPT = 20;
/**
 * Builds prompts for policy evaluation
 */
export class PolicyPromptBuilder {
    constructor() {
        // No initialization needed
    }
    /**
     * Simple template renderer that handles basic variable substitution
     * and Handlebars-style conditionals/loops
     */
    renderTemplate(template, data) {
        let result = template;
        // Handle {{#each array}} loops FIRST (before conditionals)
        result = result.replace(/\{\{#each\s+([^}]+)\}\}([\s\S]*?)\{\{\/each\}\}/g, (match, arrayName, itemTemplate) => {
            const array = data[arrayName.trim()];
            if (!Array.isArray(array)) {
                return '';
            }
            return array.map(item => {
                let renderedItem = itemTemplate;
                // Replace {{this.property}} with item values
                renderedItem = renderedItem.replace(/\{\{this\.([^}]+)\}\}/g, (_m, prop) => {
                    const value = item[prop.trim()];
                    return value !== undefined && value !== null ? String(value) : '';
                });
                // Handle {{#if this.property}}...{{else}}...{{/if}} conditionals within the loop
                renderedItem = renderedItem.replace(/\{\{#if\s+this\.([^}]+)\}\}([\s\S]*?)(?:\{\{else\}\}([\s\S]*?))?\{\{\/if\}\}/g, (_m, prop, ifContent, elseContent) => {
                    const value = item[prop.trim()];
                    return value ? ifContent : (elseContent || '');
                });
                return renderedItem;
            }).join('');
        });
        // Replace simple variables {{variable}}
        result = result.replace(/\{\{([^#/}][^}]*)\}\}/g, (match, key) => {
            const trimmedKey = key.trim();
            const value = data[trimmedKey];
            if (value === undefined || value === null) {
                return '';
            }
            return String(value);
        });
        // Handle {{#if variable}} conditionals (for top-level conditionals)
        result = result.replace(/\{\{#if\s+([^}]+)\}\}([\s\S]*?)\{\{\/if\}\}/g, (match, condition, content) => {
            const value = data[condition.trim()];
            return value ? content : '';
        });
        return result;
    }
    /**
     * Build prompt for PR evaluation
     */
    buildPRPrompt(context) {
        const { policy, pr } = context;
        if (!pr) {
            throw new Error('PR context required for PR evaluation');
        }
        // Extract policy information
        const policyData = this.extractPolicyData(policy);
        // Prepare file data (with size limits)
        const files = this.prepareFileData(pr.files);
        // Build user prompt from template
        const userPrompt = this.renderTemplate(PR_EVALUATION_TEMPLATE, {
            policy_id: policy.id,
            policy_title: policy.title || 'Untitled Policy',
            policy_description: policy.description || '',
            policy_rules: policyData.rules,
            policy_examples: policyData.examples,
            pr_title: pr.title,
            pr_description: pr.description || '(No description)',
            pr_author: pr.author,
            file_count: files.length,
            files,
        });
        return {
            system: SYSTEM_PROMPT,
            user: userPrompt,
        };
    }
    /**
     * Build prompt for feature evaluation
     */
    buildFeaturePrompt(context) {
        const { policy, feature } = context;
        if (!feature) {
            throw new Error('Feature context required for feature evaluation');
        }
        const policyData = this.extractPolicyData(policy);
        const files = this.prepareFeatureFiles(feature.files);
        const userPrompt = this.renderTemplate(FEATURE_EVALUATION_TEMPLATE, {
            policy_id: policy.id,
            policy_title: policy.title || 'Untitled Policy',
            policy_rules: policyData.rules,
            feature_name: feature.name,
            feature_description: feature.description || '',
            files,
        });
        return {
            system: SYSTEM_PROMPT,
            user: userPrompt,
        };
    }
    /**
     * Extract structured policy data from PolicyCard
     */
    extractPolicyData(policy) {
        // If we have source markdown, extract sections from it
        if (policy._sourceMarkdown) {
            return this.extractFromMarkdown(policy._sourceMarkdown);
        }
        // Fallback: construct from structured data
        return {
            rules: this.constructRulesFromConstraints(policy.constraints || {}),
            examples: '',
        };
    }
    /**
     * Extract rules and examples from markdown source
     */
    extractFromMarkdown(markdown) {
        // Extract Rules section if exists
        const rulesMatch = markdown.match(/##\s*Rules?\s*\n([\s\S]*?)(?=\n##|\n---|\Z)/i);
        // Extract Examples section if exists
        const examplesMatch = markdown.match(/##\s*Examples?\s*\n([\s\S]*?)(?=\n##|\n---|\Z)/i);
        // If we have BOTH rules AND examples, use them specifically
        if (rulesMatch && examplesMatch) {
            return {
                rules: rulesMatch[1].trim(),
                examples: examplesMatch[1].trim()
            };
        }
        // Otherwise, use the entire markdown as rules context
        // This allows flexible markdown structure without requiring specific section names
        // This includes policies using ## Detection, ## Purpose, etc. instead of ## Rules
        return {
            rules: markdown,
            examples: ''
        };
    }
    /**
     * Construct rules text from constraints (fallback)
     */
    constructRulesFromConstraints(constraints) {
        const rules = [];
        for (const [key, value] of Object.entries(constraints)) {
            if (typeof value === 'boolean' && value) {
                rules.push(`- ${this.formatConstraintName(key)}`);
            }
            else if (typeof value === 'number') {
                rules.push(`- ${this.formatConstraintName(key)}: ${value}`);
            }
            else if (typeof value === 'string') {
                rules.push(`- ${this.formatConstraintName(key)}: ${value}`);
            }
            else if (typeof value === 'object' && value !== null) {
                rules.push(`- ${this.formatConstraintName(key)}:`);
                const subRules = this.constructRulesFromConstraints(value);
                rules.push(subRules.split('\n').map(line => `  ${line}`).join('\n'));
            }
        }
        return rules.join('\n') || 'No specific rules defined';
    }
    /**
     * Format constraint name for display
     */
    formatConstraintName(name) {
        return name
            .replace(/_/g, ' ')
            .replace(/\b\w/g, char => char.toUpperCase());
    }
    /**
     * Prepare file data for prompt (with size limits)
     */
    prepareFileData(files) {
        // Limit number of files
        const limitedFiles = files.slice(0, MAX_FILES_IN_PROMPT);
        return limitedFiles.map((file) => {
            // Truncate content if too large
            let content = file.content;
            if (content && content.length > MAX_FILE_CONTENT_SIZE) {
                content = content.slice(0, MAX_FILE_CONTENT_SIZE) + '\n\n[... content truncated ...]';
            }
            // Truncate patch if too large
            let patch = file.patch;
            if (patch && patch.length > MAX_FILE_CONTENT_SIZE) {
                patch = patch.slice(0, MAX_FILE_CONTENT_SIZE) + '\n\n[... patch truncated ...]';
            }
            return {
                path: file.path,
                status: file.status,
                additions: file.additions,
                deletions: file.deletions,
                content,
                patch,
            };
        });
    }
    /**
     * Prepare feature files for prompt
     */
    prepareFeatureFiles(files) {
        return files.slice(0, MAX_FILES_IN_PROMPT).map(file => ({
            path: file.path,
            content: file.content.length > MAX_FILE_CONTENT_SIZE
                ? file.content.slice(0, MAX_FILE_CONTENT_SIZE) + '\n\n[... content truncated ...]'
                : file.content,
        }));
    }
}
//# sourceMappingURL=prompt-builder.js.map