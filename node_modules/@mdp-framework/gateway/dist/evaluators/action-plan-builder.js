/**
 * Action Plan Builder (M5 → ActionEngine Integration)
 *
 * Converts EvaluationResult[] from evaluators into an ActionPlan
 * for the ActionEngine to execute.
 */
import { randomUUID } from 'crypto';
/**
 * Converts evaluation results into an executable ActionPlan
 *
 * Maps violations to actions based on severity and available fixes:
 * - Error violations → ci.block + pr.comment
 * - Warning violations → ci.warn + pr.comment
 * - Info violations → pr.comment
 * - Violations with suggestedFix → suggest.patch
 *
 * @param results - Evaluation results from policy evaluators
 * @param options - Additional options for plan generation
 * @returns ActionPlan ready for ActionEngine execution
 */
export function buildActionPlan(results, options) {
    const planId = options?.planId || randomUUID();
    const policyId = options?.policyId || results[0]?.policy_id || 'unknown';
    const createdAt = new Date().toISOString();
    // Collect all violations across all results
    const allViolations = [];
    for (const result of results) {
        for (const violation of result.violations) {
            allViolations.push({ result, violation });
        }
    }
    // Build actions array
    const actions = [];
    // 1. Gate Actions (gate.ci.warn / gate.ci.block)
    //    Determine overall gate action based on highest severity
    const hasErrors = allViolations.some((v) => v.violation.severity === 'error');
    const hasWarnings = allViolations.some((v) => v.violation.severity === 'warning');
    if (hasErrors) {
        actions.push({
            verb: 'gate.ci.block',
            parameters: {
                message: 'Policy violations detected',
                violations_count: allViolations.filter((v) => v.violation.severity === 'error').length,
            },
        });
    }
    else if (hasWarnings) {
        actions.push({
            verb: 'gate.ci.warn',
            parameters: {
                message: 'Policy warnings detected',
                violations_count: allViolations.filter((v) => v.violation.severity === 'warning').length,
            },
        });
    }
    // 2. Comment Actions (notify.pr.comment)
    //    Generate PR comments for violations
    const commentsByPolicy = new Map();
    for (const { result, violation } of allViolations) {
        const policyKey = `${result.policy_id}@${result.policy_version}`;
        if (!commentsByPolicy.has(policyKey)) {
            commentsByPolicy.set(policyKey, []);
        }
        const location = violation.location?.file
            ? ` (${violation.location.file}${violation.location.line ? `:${violation.location.line}` : ''})`
            : '';
        const severityIcon = violation.severity === 'error' ? '❌' : violation.severity === 'warning' ? '⚠️' : 'ℹ️';
        commentsByPolicy.get(policyKey).push(`${severityIcon} ${violation.message}${location}`);
    }
    // Create one comment action per policy
    for (const [policyKey, messages] of commentsByPolicy) {
        actions.push({
            verb: 'notify.pr.comment',
            parameters: {
                body: `## Policy: ${policyKey}\n\n${messages.join('\n')}`,
                policy: policyKey,
            },
        });
    }
    // 3. Remediation Actions (remediate.suggest.patch)
    //    Generate patch suggestions for violations with fixes
    for (const { result, violation } of allViolations) {
        if (violation.suggestedFix) {
            actions.push({
                verb: 'remediate.suggest.patch',
                parameters: {
                    policy_id: `${result.policy_id}@${result.policy_version}`,
                    file: violation.location?.file || 'unknown',
                    line: violation.location?.line,
                    patch: violation.suggestedFix,
                    message: violation.message,
                },
            });
        }
    }
    // Build the final ActionPlan
    const plan = {
        schema_version: 'v1',
        plan_id: planId,
        policy_id: policyId,
        created_at: createdAt,
        actions,
        metadata: {
            triggered_by: options?.triggeredBy || 'evaluator',
            context: options?.context || {},
            policies_evaluated: results.length,
            total_violations: allViolations.length,
        },
    };
    return plan;
}
/**
 * Checks if an ActionPlan has any blocking actions
 */
export function isBlocking(plan) {
    return plan.actions.some((action) => action.verb === 'gate.ci.block');
}
/**
 * Gets a summary of actions in the plan
 */
export function summarizeActions(plan) {
    let gates = 0;
    let comments = 0;
    let patches = 0;
    for (const action of plan.actions) {
        if (action.verb === 'gate.ci.block' || action.verb === 'gate.ci.warn') {
            gates++;
        }
        else if (action.verb === 'notify.pr.comment') {
            comments++;
        }
        else if (action.verb === 'remediate.suggest.patch') {
            patches++;
        }
    }
    return {
        gates,
        comments,
        patches,
        total: plan.actions.length,
    };
}
//# sourceMappingURL=action-plan-builder.js.map