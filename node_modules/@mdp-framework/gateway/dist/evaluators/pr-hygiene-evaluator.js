/**
 * PR Hygiene Evaluator
 *
 * Evaluates PR hygiene policies (eng.pr.review)
 * Checks: description, file count, file sizes, title length
 */
export class PRHygieneEvaluator {
    id = 'pr-hygiene';
    supportedPolicies = ['eng.pr.review'];
    canEvaluate(policy) {
        return this.supportedPolicies.includes(policy.id);
    }
    async evaluate(context) {
        const startTime = Date.now();
        const { policy, pr } = context;
        if (!pr) {
            throw new Error('PR hygiene evaluator requires PR context');
        }
        const violations = [];
        const constraints = policy.constraints || {};
        // Check: require_description
        if (constraints.require_description === true) {
            if (!pr.description || pr.description.trim().length === 0) {
                violations.push({
                    message: 'PR must have a description',
                    severity: 'error',
                    metadata: {
                        constraint: 'require_description',
                    },
                });
            }
        }
        // Check: max_file_count
        if (typeof constraints.max_file_count === 'number') {
            const fileCount = pr.files.length;
            if (fileCount > constraints.max_file_count) {
                violations.push({
                    message: `PR modifies ${fileCount} files, exceeds maximum of ${constraints.max_file_count}`,
                    severity: 'error',
                    metadata: {
                        constraint: 'max_file_count',
                        actual: fileCount,
                        limit: constraints.max_file_count,
                    },
                });
            }
        }
        // Check: disallow_large_files_mb
        if (typeof constraints.disallow_large_files_mb === 'number') {
            const limitBytes = constraints.disallow_large_files_mb * 1024 * 1024;
            for (const file of pr.files) {
                // Estimate file size from content if available
                const sizeBytes = file.content
                    ? Buffer.byteLength(file.content, 'utf-8')
                    : file.additions * 50; // Rough estimate: 50 bytes per line
                if (sizeBytes > limitBytes) {
                    const sizeMB = (sizeBytes / 1024 / 1024).toFixed(2);
                    violations.push({
                        message: `File ${file.path} is ${sizeMB} MB, exceeds maximum of ${constraints.disallow_large_files_mb} MB`,
                        severity: 'error',
                        location: {
                            file: file.path,
                        },
                        metadata: {
                            constraint: 'disallow_large_files_mb',
                            actual_mb: parseFloat(sizeMB),
                            limit_mb: constraints.disallow_large_files_mb,
                        },
                    });
                }
            }
        }
        // Check: require_codeowners_review
        if (constraints.require_codeowners_review === true) {
            // This would require CODEOWNERS parsing and review data
            // Skipped in v1 - would need additional context
        }
        // Check: hygiene.min_title_len
        const hygiene = constraints.hygiene;
        if (hygiene && typeof hygiene.min_title_len === 'number') {
            const titleLen = pr.title.length;
            if (titleLen < hygiene.min_title_len) {
                violations.push({
                    message: `PR title is ${titleLen} characters, minimum is ${hygiene.min_title_len}`,
                    severity: 'error',
                    metadata: {
                        constraint: 'hygiene.min_title_len',
                        actual: titleLen,
                        limit: hygiene.min_title_len,
                    },
                });
            }
        }
        // Check: hygiene.require_issue_key
        if (hygiene && hygiene.require_issue_key === true) {
            // Match common issue key patterns: JIRA-123, ABC-456, #123
            const issueKeyPattern = /([A-Z]+-\d+|#\d+)/;
            const hasIssueKey = issueKeyPattern.test(pr.title) || issueKeyPattern.test(pr.description);
            if (!hasIssueKey) {
                violations.push({
                    message: 'PR title or description must contain an issue key (e.g., JIRA-123, #123)',
                    severity: 'warning',
                    metadata: {
                        constraint: 'hygiene.require_issue_key',
                    },
                });
            }
        }
        // Determine overall status
        let status = 'pass';
        if (violations.some((v) => v.severity === 'error')) {
            status = 'fail';
        }
        else if (violations.some((v) => v.severity === 'warning')) {
            status = 'warning';
        }
        return {
            policy_id: policy.id,
            policy_version: policy.version,
            status,
            violations,
            metadata: {
                duration_ms: Date.now() - startTime,
                files_checked: pr.files.length,
            },
        };
    }
}
//# sourceMappingURL=pr-hygiene-evaluator.js.map