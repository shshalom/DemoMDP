/**
 * Design Token Evaluator
 *
 * Evaluates design token policies (ui.design.tokens)
 * Checks for hardcoded colors, spacing, and other design values
 */
export class DesignTokenEvaluator {
    id = 'design-token';
    supportedPolicies = ['ui.design.tokens'];
    // Regex patterns for detection
    hexColorPattern = /#[0-9a-fA-F]{3,8}\b/g;
    hardcodedSpacingPattern = /(?:padding|margin|gap|top|right|bottom|left|width|height):\s*['"]?\d+(?:px|rem|em)['"]?/g;
    canEvaluate(policy) {
        return this.supportedPolicies.includes(policy.id);
    }
    async evaluate(context) {
        const startTime = Date.now();
        const { policy, pr } = context;
        if (!pr) {
            throw new Error('Design token evaluator requires PR context');
        }
        const violations = [];
        const constraints = policy.constraints || {};
        // Only check UI/style files
        const styleFiles = pr.files.filter((f) => /\.(tsx?|jsx?|css|scss|sass|less|styled\.)/.test(f.path));
        for (const file of styleFiles) {
            const content = file.content || file.patch || '';
            if (!content)
                continue;
            // Check: disallow_hex_colors
            if (constraints.disallow_hex_colors === true) {
                const hexMatches = [...content.matchAll(this.hexColorPattern)];
                for (const match of hexMatches) {
                    // Skip if it's in a comment or import statement
                    const line = this.getLineFromMatch(content, match.index);
                    if (this.isInComment(line) || this.isInImport(line)) {
                        continue;
                    }
                    const lineNumber = this.getLineNumber(content, match.index);
                    const hexValue = match[0];
                    violations.push({
                        message: `Hardcoded hex color '${hexValue}' found. Use design tokens instead.`,
                        severity: 'error',
                        location: {
                            file: file.path,
                            line: lineNumber,
                        },
                        suggestedFix: this.generateColorFix(line, hexValue, constraints),
                        metadata: {
                            constraint: 'disallow_hex_colors',
                            found_value: hexValue,
                        },
                    });
                }
            }
            // Check: disallow_hardcoded_spacing
            if (constraints.disallow_hardcoded_spacing === true) {
                const spacingMatches = [...content.matchAll(this.hardcodedSpacingPattern)];
                for (const match of spacingMatches) {
                    const line = this.getLineFromMatch(content, match.index);
                    if (this.isInComment(line) || this.isInImport(line)) {
                        continue;
                    }
                    const lineNumber = this.getLineNumber(content, match.index);
                    const spacingValue = match[0];
                    violations.push({
                        message: `Hardcoded spacing '${spacingValue}' found. Use design tokens instead.`,
                        severity: 'warning',
                        location: {
                            file: file.path,
                            line: lineNumber,
                        },
                        suggestedFix: this.generateSpacingFix(line, spacingValue, constraints),
                        metadata: {
                            constraint: 'disallow_hardcoded_spacing',
                            found_value: spacingValue,
                        },
                    });
                }
            }
            // Check: required_token_import
            if (typeof constraints.required_token_import === 'string') {
                const tokenImport = constraints.required_token_import;
                const hasImport = content.includes(tokenImport);
                if (!hasImport && violations.some((v) => v.location?.file === file.path)) {
                    // Only flag if there are other violations in this file
                    violations.push({
                        message: `Missing required import: '${tokenImport}'`,
                        severity: 'info',
                        location: {
                            file: file.path,
                            line: 1,
                        },
                        metadata: {
                            constraint: 'required_token_import',
                            required_import: tokenImport,
                        },
                    });
                }
            }
        }
        // Determine overall status
        let status = 'pass';
        if (violations.some((v) => v.severity === 'error')) {
            status = 'fail';
        }
        else if (violations.some((v) => v.severity === 'warning')) {
            status = 'warning';
        }
        return {
            policy_id: policy.id,
            policy_version: policy.version,
            status,
            violations,
            metadata: {
                duration_ms: Date.now() - startTime,
                files_checked: styleFiles.length,
            },
        };
    }
    // Helper methods
    getLineFromMatch(content, index) {
        const lineStart = content.lastIndexOf('\n', index) + 1;
        const lineEnd = content.indexOf('\n', index);
        return content.substring(lineStart, lineEnd === -1 ? content.length : lineEnd);
    }
    getLineNumber(content, index) {
        return content.substring(0, index).split('\n').length;
    }
    isInComment(line) {
        const trimmed = line.trim();
        return trimmed.startsWith('//') || trimmed.startsWith('/*') || trimmed.startsWith('*');
    }
    isInImport(line) {
        return line.trim().startsWith('import ');
    }
    generateColorFix(line, hexValue, constraints) {
        const autofix = constraints.autofix;
        if (!autofix?.enabled)
            return undefined;
        const replacement = String(autofix.replace_hex_with || 'tokens.color');
        const fixed = line.replace(hexValue, replacement);
        return `--- a/file\n+++ b/file\n@@ -1 +1 @@\n-${line}\n+${fixed}`;
    }
    generateSpacingFix(line, spacingValue, constraints) {
        const autofix = constraints.autofix;
        if (!autofix?.enabled)
            return undefined;
        const replacement = String(autofix.replace_px_with || 'tokens.spacing');
        const fixed = line.replace(spacingValue, spacingValue.replace(/\d+px/, replacement));
        return `--- a/file\n+++ b/file\n@@ -1 +1 @@\n-${line}\n+${fixed}`;
    }
}
//# sourceMappingURL=design-token-evaluator.js.map