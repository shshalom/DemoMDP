/**
 * Hybrid Evaluator (Stream 2)
 *
 * Combines pattern-matching evaluators with AI fallback.
 * Strategy: Fast pattern-matching first, AI for complex cases.
 *
 * Benefits:
 * - Speed: Pattern-matching is instant (<100ms)
 * - Cost: Only use AI when needed
 * - Accuracy: AI handles edge cases pattern-matching misses
 */
/**
 * Hybrid evaluator that combines pattern-matching with AI
 *
 * Evaluation strategy:
 * 1. Try pattern-matching evaluator first (if available)
 * 2. If pattern-matching succeeds, use those results
 * 3. If pattern-matching fails or unavailable, use AI
 * 4. Track which path was used in metadata
 */
export class HybridEvaluator {
    patternEvaluator;
    aiEvaluator;
    options;
    id;
    supportedPolicies;
    constructor(patternEvaluator, aiEvaluator, options = {}) {
        this.patternEvaluator = patternEvaluator;
        this.aiEvaluator = aiEvaluator;
        this.options = options;
        // Inherit ID and supported policies from pattern evaluator if available
        if (patternEvaluator) {
            this.id = `hybrid-${patternEvaluator.id}`;
            this.supportedPolicies = patternEvaluator.supportedPolicies;
        }
        else {
            this.id = 'hybrid-ai-only';
            this.supportedPolicies = aiEvaluator.supportedPolicies;
        }
    }
    /**
     * Check if this evaluator can handle a policy
     */
    canEvaluate(policy) {
        // Can evaluate if either evaluator can handle it
        return ((this.patternEvaluator?.canEvaluate(policy) ?? false) ||
            this.aiEvaluator.canEvaluate(policy));
    }
    /**
     * Evaluate policy using hybrid strategy
     */
    async evaluate(context) {
        const startTime = Date.now();
        // Check cost threshold before using AI
        if (this.options.maxCostUsd !== undefined) {
            const estimate = await this.aiEvaluator.estimateCost(context);
            if (estimate.cost_usd > this.options.maxCostUsd) {
                // Cost too high, force pattern-matching only
                if (this.patternEvaluator) {
                    return this.evaluateWithPatternMatching(context, startTime);
                }
                else {
                    // No pattern evaluator available, return error
                    return {
                        policy_id: context.policy.id,
                        policy_version: context.policy.version,
                        status: 'fail',
                        violations: [
                            {
                                message: `AI evaluation cost (${estimate.cost_usd.toFixed(4)} USD) exceeds threshold (${this.options.maxCostUsd} USD) and no pattern-matching evaluator available`,
                                severity: 'error',
                            },
                        ],
                        metadata: {
                            duration_ms: Date.now() - startTime,
                        },
                    };
                }
            }
        }
        // Strategy 1: Try pattern-matching first (if available and not forced AI)
        if (this.patternEvaluator && !this.options.alwaysUseAI) {
            try {
                const result = await this.patternEvaluator.evaluate(context);
                // Check if we should still use AI
                const shouldUseAI = this.options.alwaysUseAI ||
                    (this.options.aiOnNoViolations && result.violations.length === 0);
                if (!shouldUseAI) {
                    // Pattern-matching succeeded, use those results
                    return {
                        ...result,
                        metadata: {
                            ...result.metadata,
                            fallback_used: false,
                            evaluation_strategy: 'pattern-matching',
                            duration_ms: Date.now() - startTime,
                        },
                    };
                }
            }
            catch (error) {
                // Pattern-matching failed, fall through to AI
                console.warn(`Pattern-matching evaluation failed for ${context.policy.id}, falling back to AI:`, error);
            }
        }
        // Strategy 2: Use AI evaluation
        return this.evaluateWithAI(context, startTime);
    }
    /**
     * Estimate cost of evaluation
     * Returns pattern-matching cost (0) if available, otherwise AI cost
     */
    async estimateCost(context) {
        // If pattern-matching is available and not forcing AI, cost is zero
        if (this.patternEvaluator && !this.options.alwaysUseAI) {
            return {
                tokens: 0,
                cost_usd: 0,
                model: 'pattern-matching',
            };
        }
        // Otherwise, return AI cost estimate
        return this.aiEvaluator.estimateCost(context);
    }
    /**
     * Evaluate using pattern-matching evaluator
     */
    async evaluateWithPatternMatching(context, startTime) {
        if (!this.patternEvaluator) {
            throw new Error('Pattern evaluator not available');
        }
        const result = await this.patternEvaluator.evaluate(context);
        return {
            ...result,
            metadata: {
                ...result.metadata,
                fallback_used: false,
                evaluation_strategy: 'pattern-matching',
                duration_ms: Date.now() - startTime,
            },
        };
    }
    /**
     * Evaluate using AI evaluator
     */
    async evaluateWithAI(context, startTime) {
        const result = await this.aiEvaluator.evaluate(context);
        return {
            ...result,
            metadata: {
                ...(result.metadata || {}),
                fallback_used: this.patternEvaluator !== null, // True if we had a pattern evaluator but used AI
                evaluation_strategy: 'ai',
                duration_ms: Date.now() - startTime,
            },
        };
    }
}
/**
 * Factory function to create hybrid evaluator
 *
 * @param patternEvaluator - Optional pattern-matching evaluator
 * @param aiEvaluator - AI evaluator to use as fallback or primary
 * @param options - Hybrid evaluation options
 */
export function createHybridEvaluator(patternEvaluator, aiEvaluator, options) {
    return new HybridEvaluator(patternEvaluator, aiEvaluator, options);
}
//# sourceMappingURL=hybrid-evaluator.js.map