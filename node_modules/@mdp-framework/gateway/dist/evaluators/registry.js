/**
 * Evaluator Registry
 *
 * Central registry for managing and dispatching policy evaluators
 */
export class DefaultEvaluatorRegistry {
    evaluators = new Map();
    defaultEvaluator = null;
    /**
     * Register an evaluator
     */
    register(evaluator) {
        if (this.evaluators.has(evaluator.id)) {
            throw new Error(`Evaluator with id '${evaluator.id}' is already registered`);
        }
        this.evaluators.set(evaluator.id, evaluator);
    }
    /**
     * Register a default/fallback evaluator
     * This evaluator is used when no specific evaluator is found for a policy
     *
     * @param evaluator - The evaluator to use as default (typically UniversalAgentEvaluator)
     */
    registerDefault(evaluator) {
        this.defaultEvaluator = evaluator;
    }
    /**
     * Get evaluator for a policy
     */
    getEvaluator(policy) {
        // Try to find a specific evaluator that can handle this policy
        for (const evaluator of this.evaluators.values()) {
            if (evaluator.canEvaluate(policy)) {
                return evaluator;
            }
        }
        // Fall back to default evaluator (if registered)
        if (this.defaultEvaluator && this.defaultEvaluator.canEvaluate(policy)) {
            return this.defaultEvaluator;
        }
        return null;
    }
    /**
     * Evaluate a policy
     */
    async evaluate(policy, context) {
        const evaluator = this.getEvaluator(policy);
        if (!evaluator) {
            // No evaluator found - return pass with warning
            return {
                policy_id: policy.id,
                policy_version: policy.version,
                status: 'warning',
                violations: [
                    {
                        message: `No evaluator found for policy '${policy.id}'`,
                        severity: 'warning',
                        metadata: {
                            reason: 'no_evaluator',
                        },
                    },
                ],
                metadata: {
                    duration_ms: 0,
                    evaluator: 'none',
                },
            };
        }
        // Run evaluation
        return evaluator.evaluate({
            ...context,
            policy,
        });
    }
    /**
     * Evaluate multiple policies
     */
    async evaluateAll(policies, context) {
        const results = [];
        for (const policy of policies) {
            const result = await this.evaluate(policy, context);
            results.push(result);
        }
        return results;
    }
    /**
     * Get all registered evaluator IDs
     */
    getRegisteredEvaluators() {
        return Array.from(this.evaluators.keys());
    }
}
/**
 * Create a registry with default evaluators
 */
export function createEvaluatorRegistry() {
    return new DefaultEvaluatorRegistry();
}
//# sourceMappingURL=registry.js.map