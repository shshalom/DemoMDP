/**
 * Secret Detection Evaluator
 *
 * Evaluates secret detection policies (eng.security.secrets)
 * Checks for hardcoded secrets, API keys, passwords, tokens
 */
export class SecretDetectionEvaluator {
    id = 'secret-detection';
    supportedPolicies = ['eng.security.secrets'];
    canEvaluate(policy) {
        return this.supportedPolicies.includes(policy.id);
    }
    async evaluate(context) {
        const startTime = Date.now();
        const { policy, pr } = context;
        if (!pr) {
            throw new Error('Secret detection evaluator requires PR context');
        }
        const violations = [];
        const constraints = policy.constraints || {};
        if (constraints.disallow_secrets !== true) {
            // Policy not enabled
            return {
                policy_id: policy.id,
                policy_version: policy.version,
                status: 'pass',
                violations: [],
                metadata: {
                    duration_ms: Date.now() - startTime,
                    files_checked: 0,
                },
            };
        }
        // Get scan patterns
        const scanPatterns = constraints.scan_patterns;
        const allowlist = constraints.allowlist;
        const safePatterns = constraints.safe_patterns;
        // Compile patterns (remove unsupported (?i) flags - JS uses 'i' flag instead)
        const secretRegexes = (scanPatterns || []).map((p) => {
            // Remove (?i) inline flag - JavaScript uses 'i' flag instead
            const cleaned = p.replace(/\(\?i\)/g, '');
            return new RegExp(cleaned, 'gmi');
        });
        const safeRegexes = (safePatterns || []).map((p) => new RegExp(p, 'i'));
        let filesChecked = 0;
        for (const file of pr.files) {
            // Skip if file is in allowlist
            if (allowlist && this.matchesAnyGlob(file.path, allowlist)) {
                continue;
            }
            // Skip deleted files
            if (file.status === 'deleted') {
                continue;
            }
            const content = file.content || file.patch || '';
            if (!content)
                continue;
            filesChecked++;
            // Check each pattern
            for (const regex of secretRegexes) {
                const matches = [...content.matchAll(regex)];
                for (const match of matches) {
                    const line = this.getLineFromMatch(content, match.index);
                    const lineNumber = this.getLineNumber(content, match.index);
                    // Check if it matches a safe pattern
                    if (safeRegexes.some((safeRe) => safeRe.test(line))) {
                        continue; // Skip safe patterns (env vars, templates)
                    }
                    // Check if it's in a comment
                    if (this.isInComment(line)) {
                        continue;
                    }
                    const secretSnippet = match[0].substring(0, 50); // Truncate for safety
                    violations.push({
                        message: `Potential secret detected: ${this.getPatternName(regex)}`,
                        severity: 'error',
                        location: {
                            file: file.path,
                            line: lineNumber,
                        },
                        metadata: {
                            constraint: 'disallow_secrets',
                            pattern: regex.source,
                            snippet: secretSnippet,
                            remediation: 'Remove the secret and use environment variables or a secrets manager.',
                        },
                    });
                }
            }
        }
        // Determine overall status
        let status = 'pass';
        if (violations.length > 0) {
            status = 'fail'; // Secrets are always fail
        }
        return {
            policy_id: policy.id,
            policy_version: policy.version,
            status,
            violations,
            metadata: {
                duration_ms: Date.now() - startTime,
                files_checked: filesChecked,
                secrets_found: violations.length,
            },
        };
    }
    // Helper methods
    getLineFromMatch(content, index) {
        const lineStart = content.lastIndexOf('\n', index) + 1;
        const lineEnd = content.indexOf('\n', index);
        return content.substring(lineStart, lineEnd === -1 ? content.length : lineEnd);
    }
    getLineNumber(content, index) {
        return content.substring(0, index).split('\n').length;
    }
    isInComment(line) {
        const trimmed = line.trim();
        return (trimmed.startsWith('//') ||
            trimmed.startsWith('/*') ||
            trimmed.startsWith('*') ||
            trimmed.startsWith('#'));
    }
    matchesAnyGlob(path, patterns) {
        for (const pattern of patterns) {
            if (this.matchesGlob(path, pattern)) {
                return true;
            }
        }
        return false;
    }
    matchesGlob(path, pattern) {
        // Simple glob matching (** for any directory, * for any file)
        const regexPattern = pattern
            .replace(/\*\*/g, '.*')
            .replace(/\*/g, '[^/]*')
            .replace(/\?/g, '.');
        const regex = new RegExp(`^${regexPattern}$`);
        return regex.test(path);
    }
    getPatternName(regex) {
        const source = regex.source;
        if (source.includes('api'))
            return 'API Key';
        if (source.includes('secret'))
            return 'Secret Key';
        if (source.includes('password'))
            return 'Password';
        if (source.includes('private'))
            return 'Private Key';
        if (source.includes('token'))
            return 'Access Token';
        return 'Potential Secret';
    }
}
//# sourceMappingURL=secret-detection-evaluator.js.map