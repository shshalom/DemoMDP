/**
 * Vector Similarity Search
 *
 * Embedding-based similarity search for component detection.
 */
export class VectorSearch {
    aiProvider;
    constructor(aiProvider) {
        this.aiProvider = aiProvider;
    }
    /**
     * Search for similar components using embeddings
     */
    async search(query, candidates, threshold) {
        const startTime = Date.now();
        // 1. Generate query embedding
        const queryEmbeddings = await this.aiProvider.embed([query]);
        const queryVector = queryEmbeddings[0].vector;
        // 2. Calculate cosine similarity for all candidates
        const similarities = candidates.map((c) => ({
            component: c.name,
            description: c.description,
            location: c.location,
            similarity_score: this.cosineSimilarity(queryVector, c.embedding),
        }));
        // 3. Sort by similarity (descending)
        similarities.sort((a, b) => b.similarity_score - a.similarity_score);
        // 4. Filter by threshold
        const matches = similarities.filter((s) => s.similarity_score >= threshold);
        const searchLatency = Date.now() - startTime;
        return {
            exists: matches.length > 0,
            threshold,
            closest_match: matches[0]
                ? {
                    component: matches[0].component,
                    description: matches[0].description,
                    similarity_score: matches[0].similarity_score,
                    location: matches[0].location,
                }
                : undefined,
            matches: matches.map((m) => ({
                component: m.component,
                similarity_score: m.similarity_score,
            })),
            metadata: {
                query,
                total_candidates: candidates.length,
                search_latency_ms: searchLatency,
            },
        };
    }
    /**
     * Calculate cosine similarity between two vectors
     */
    cosineSimilarity(a, b) {
        if (a.length !== b.length) {
            throw new Error('Vectors must have the same length');
        }
        const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);
        const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
        const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));
        if (magnitudeA === 0 || magnitudeB === 0) {
            return 0;
        }
        return dotProduct / (magnitudeA * magnitudeB);
    }
}
//# sourceMappingURL=vector-search.js.map