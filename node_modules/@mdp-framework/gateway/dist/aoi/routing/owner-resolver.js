/**
 * Owner Resolver
 *
 * Resolves component owners from policy configuration and ownership policies.
 */
export class OwnerResolver {
    mcpClient;
    constructor(mcpClient) {
        this.mcpClient = mcpClient;
    }
    /**
     * Resolve owners for an AOI spec
     */
    async resolveOwners(spec, policy) {
        // 1. Check policy AOI config for explicit owners
        if (policy.aoi?.owners && policy.aoi.owners.length > 0) {
            return policy.aoi.owners;
        }
        // 2. Try to query eng.ownership policy via MCP
        if (this.mcpClient && policy.aoi?.framework) {
            try {
                const ownershipPolicy = await this.mcpClient.call('policy.get', {
                    id: 'eng.ownership',
                });
                if (ownershipPolicy.success && ownershipPolicy.data) {
                    const owners = this.matchOwnersByFramework(spec.framework, ownershipPolicy.data.constraints?.mappings || []);
                    if (owners.length > 0) {
                        return owners;
                    }
                }
            }
            catch (error) {
                console.warn('Failed to query ownership policy:', error);
            }
        }
        // 3. Fallback to default team
        return ['@default-team'];
    }
    /**
     * Match owners by framework pattern
     */
    matchOwnersByFramework(framework, mappings) {
        const allOwners = new Set();
        for (const mapping of mappings) {
            if (this.matchesPattern(framework, mapping.pattern)) {
                mapping.owners.forEach((owner) => allOwners.add(owner));
            }
        }
        return Array.from(allOwners);
    }
    /**
     * Check if framework matches pattern
     */
    matchesPattern(framework, pattern) {
        // Simple pattern matching (can be enhanced with glob patterns)
        if (pattern === '*') {
            return true;
        }
        // Exact match
        if (framework === pattern) {
            return true;
        }
        // Contains match
        if (framework.includes(pattern)) {
            return true;
        }
        // Wildcard pattern (simplified)
        const regex = new RegExp(pattern.replace(/\*/g, '.*'));
        return regex.test(framework);
    }
}
//# sourceMappingURL=owner-resolver.js.map