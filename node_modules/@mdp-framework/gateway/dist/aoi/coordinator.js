/**
 * AOI Coordinator
 *
 * Orchestrates the Architecture of Intent (AOI) workflow:
 * 1. Detect missing components via similarity search
 * 2. Generate specifications using LLM
 * 3. Route to owners
 * 4. Create counter-PRs and follow-up PRs
 */
import { VectorSearch } from './similarity/vector-search.js';
import { ComponentIndex } from './similarity/component-index.js';
import { ThresholdChecker } from './similarity/threshold-checker.js';
import { SpecGenerator } from './spec-generator.js';
import { OwnerResolver } from './routing/owner-resolver.js';
import { NotificationDispatcher } from './routing/notification-dispatcher.js';
import { CounterPRGenerator } from './counter-pr/pr-generator.js';
import { GitHubClient } from './counter-pr/github-client.js';
import { FollowupPRCreator } from './followup-pr/pr-creator.js';
export class AOICoordinator {
    vectorSearch;
    componentIndex;
    specGenerator;
    ownerResolver;
    notificationDispatcher;
    counterPRGenerator;
    followupPRCreator;
    githubClient;
    mcpClient;
    aiProvider;
    constructor(config) {
        this.aiProvider = config.aiProvider;
        this.vectorSearch = new VectorSearch(config.aiProvider);
        this.componentIndex = new ComponentIndex(config.aiProvider);
        this.specGenerator = new SpecGenerator(config.aiProvider);
        this.ownerResolver = new OwnerResolver(config.mcpClient);
        this.notificationDispatcher = new NotificationDispatcher();
        this.counterPRGenerator = new CounterPRGenerator(config.aiProvider);
        this.githubClient = new GitHubClient({ client: config.githubClient });
        this.followupPRCreator = new FollowupPRCreator(config.aiProvider, this.githubClient);
        this.mcpClient = config.mcpClient;
    }
    /**
     * Process evaluation result for AOI
     */
    async processEvaluation(result, policy, pr) {
        // Check if AOI is enabled for this policy
        if (!policy.aoi?.enabled) {
            return [];
        }
        const actions = [];
        // Process each violation
        for (const violation of result.violations) {
            try {
                // 1. Check if component exists via similarity search
                const threshold = policy.aoi.threshold || ThresholdChecker.DEFAULT_THRESHOLD;
                const similarityResult = await this.checkComponentExists(violation.message, policy.aoi.framework || '', threshold);
                // 2. Skip AOI if component exists
                if (ThresholdChecker.checkExists(similarityResult)) {
                    continue;
                }
                // 3. Generate AOI spec
                const spec = await this.generateSpec(violation, policy, pr);
                // 4. Route to owners
                const routingActions = await this.routeToOwners(spec, policy);
                actions.push(...routingActions);
                // 5. Create counter-PR if auto-enabled
                if (policy.aoi.auto_create_counter_pr) {
                    const counterPRAction = await this.createCounterPR(spec, {
                        framework_repo: policy.aoi.framework || '',
                        branch_name: `aoi-${spec.id}`,
                        title: `Add ${spec.name} component`,
                        description: spec.specification,
                        files: [],
                        include_tests: policy.aoi.include_tests || false,
                        reviewers: spec.owners,
                    });
                    actions.push(counterPRAction);
                }
            }
            catch (error) {
                console.error('Error processing violation for AOI:', error);
            }
        }
        return actions;
    }
    /**
     * Check if component exists via similarity search
     */
    async checkComponentExists(query, framework, threshold) {
        ThresholdChecker.validateThreshold(threshold);
        // Try MCP client first for framework components
        if (this.mcpClient && framework) {
            try {
                const response = await this.mcpClient.call('memory.search', {
                    query,
                    filters: { kind: 'component', framework },
                    limit: 10,
                });
                if (response.success && response.data) {
                    // Convert MCP response to SimilarityResult format
                    const matches = response.data
                        .filter((m) => m.similarity >= threshold)
                        .map((m) => ({
                        component: m.component || m.name,
                        similarity_score: m.similarity,
                    }));
                    return {
                        exists: matches.length > 0,
                        threshold,
                        closest_match: matches[0]
                            ? {
                                component: matches[0].component,
                                description: response.data[0].description || '',
                                similarity_score: matches[0].similarity_score,
                                location: response.data[0].location || '',
                            }
                            : undefined,
                        matches,
                        metadata: {
                            query,
                            total_candidates: response.data.length,
                            search_latency_ms: response.metadata?.latency_ms || 0,
                        },
                    };
                }
            }
            catch (error) {
                console.warn('MCP search failed, falling back to local index:', error);
            }
        }
        // Fallback to local component index
        const candidates = this.componentIndex.getComponents(framework);
        if (candidates.length === 0) {
            // No components indexed for this framework
            return {
                exists: false,
                threshold,
                matches: [],
                metadata: {
                    query,
                    total_candidates: 0,
                    search_latency_ms: 0,
                },
            };
        }
        return this.vectorSearch.search(query, candidates, threshold);
    }
    /**
     * Generate AOI specification
     */
    async generateSpec(violation, policy, pr) {
        // Generate spec using LLM
        const spec = await this.specGenerator.generateSpec(violation, policy, pr);
        // Resolve owners
        const owners = await this.ownerResolver.resolveOwners(spec, policy);
        spec.owners = owners;
        return spec;
    }
    /**
     * Route AOI spec to owners
     */
    async routeToOwners(spec, policy) {
        // Dispatch notifications (Jira + Slack)
        const actions = await this.notificationDispatcher.dispatch(spec, policy);
        return actions;
    }
    /**
     * Create counter-PR in framework repo
     */
    async createCounterPR(spec, config) {
        const startTime = Date.now();
        try {
            // 1. Generate implementation files
            const files = await this.counterPRGenerator.generateImplementation(spec, config.include_tests);
            // 2. Create branch
            const branch = await this.githubClient.createBranch(config.framework_repo, config.branch_name);
            // 3. Commit files
            await this.githubClient.commitFiles(branch, files, `Add ${spec.name} component\n\n${spec.description}`, config.framework_repo);
            // 4. Create PR
            const pr = await this.githubClient.createPullRequest({
                repo: config.framework_repo,
                head: branch,
                base: 'main',
                title: config.title,
                body: this.buildCounterPRDescription(spec, config),
                reviewers: config.reviewers,
            });
            return {
                type: 'create_counter_pr',
                status: 'completed',
                target: {
                    platform: 'github',
                    resource_id: pr.number.toString(),
                    url: pr.html_url,
                },
                payload: { spec, pr, files },
                metadata: {
                    created_at: new Date().toISOString(),
                    completed_at: new Date().toISOString(),
                },
            };
        }
        catch (error) {
            return {
                type: 'create_counter_pr',
                status: 'failed',
                target: {
                    platform: 'github',
                },
                payload: { spec },
                metadata: {
                    created_at: new Date().toISOString(),
                    error: error instanceof Error ? error.message : String(error),
                },
            };
        }
    }
    /**
     * Build counter-PR description
     */
    buildCounterPRDescription(spec, config) {
        return `## AOI Component: ${spec.name}

${spec.description}

### Specification

${spec.specification}

### Trigger

- **Policy**: ${spec.metadata.policy_id}
- **Pull Request**: ${spec.metadata.trigger_pr}
- **Violation**: ${spec.metadata.trigger_violation.message}

### Code Examples

${spec.examples.map((ex) => `
#### ${ex.file}
\`\`\`${ex.language}
${ex.code}
\`\`\`
${ex.context ? `_${ex.context}_` : ''}
`).join('\n')}

### Files Changed

${config.files.map((f) => `- ${f.operation} \`${f.path}\``).join('\n')}

---

This PR was automatically generated by the AOI Coordinator.
Cost: $${spec.metadata.cost_usd.toFixed(4)}
Generated at: ${spec.metadata.generated_at}
`;
    }
    /**
     * Create follow-up PR to migrate original code
     */
    async createFollowupPR(original_pr, counter_pr, spec) {
        return this.followupPRCreator.createFollowupPR(original_pr, counter_pr, spec);
    }
    /**
     * Get component index (for testing/seeding)
     */
    getComponentIndex() {
        return this.componentIndex;
    }
}
//# sourceMappingURL=coordinator.js.map