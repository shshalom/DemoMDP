/**
 * AOI Spec Generator
 *
 * Generates Architecture of Intent specifications using LLM.
 */
import { createHash } from 'crypto';
export class SpecGenerator {
    aiProvider;
    constructor(aiProvider) {
        this.aiProvider = aiProvider;
    }
    /**
     * Generate AOI specification from violation
     */
    async generateSpec(violation, policy, pr) {
        const startTime = Date.now();
        // 1. Build prompt for spec generation
        const prompt = this.buildSpecPrompt(violation, policy, pr);
        // 2. Generate spec using LLM
        const response = await this.aiProvider.complete({
            prompt,
            temperature: 0.7,
            max_tokens: 2000,
            schema: this.getSpecSchema(),
        });
        // 3. Parse structured response
        const spec = response.structured;
        // 4. Extract code examples
        const examples = this.extractCodeExamples(violation, pr);
        // 5. Build AOI spec
        const aoiSpec = {
            id: this.generateSpecId(spec.name, policy.id),
            name: spec.name,
            description: spec.description,
            framework: policy.aoi?.framework || '',
            specification: spec.specification,
            examples,
            owners: [], // Will be filled by routing
            metadata: {
                policy_id: policy.id,
                trigger_pr: `gh://${pr.base.repo.full_name}/PR/${pr.number}`,
                trigger_violation: violation,
                similarity_checked: false,
                generated_at: new Date().toISOString(),
                cost_usd: response.usage.cost_usd,
            },
        };
        return aoiSpec;
    }
    /**
     * Build prompt for spec generation
     */
    buildSpecPrompt(violation, policy, pr) {
        return `You are a framework architect generating a component specification.

Policy Violation:
${violation.message}

File: ${violation.file}${violation.line ? `:${violation.line}` : ''}

Policy Context:
Title: ${policy.title || policy.id}
Description: ${policy.description || 'No description provided'}

Pull Request Context:
Title: ${pr.title}
Description: ${pr.body || 'No description provided'}

Task:
Generate a component specification for the framework that would prevent this violation.
Include:
1. Component name (following framework conventions, use PascalCase for classes/components)
2. Description (2-3 sentences explaining what the component does)
3. Specification (detailed requirements, API design, usage guidelines in Markdown)
4. Examples (code examples showing how to use the component)

The specification should be clear, actionable, and follow best practices for the framework.

Output JSON with fields:
- name: string (component name in PascalCase)
- description: string (2-3 sentence description)
- specification: string (full specification in Markdown)
- examples: array of {description?: string, code: string}`;
    }
    /**
     * Get JSON schema for spec generation
     */
    getSpecSchema() {
        return {
            type: 'object',
            properties: {
                name: {
                    type: 'string',
                    description: 'Component name in PascalCase',
                },
                description: {
                    type: 'string',
                    description: '2-3 sentence description',
                },
                specification: {
                    type: 'string',
                    description: 'Full specification in Markdown',
                },
                examples: {
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            description: { type: 'string' },
                            code: { type: 'string' },
                        },
                        required: ['code'],
                    },
                },
            },
            required: ['name', 'description', 'specification', 'examples'],
        };
    }
    /**
     * Extract code examples from violation
     */
    extractCodeExamples(violation, pr) {
        const examples = [];
        // Add violation context as example
        if (violation.suggested_fix) {
            examples.push({
                file: violation.file,
                language: this.inferLanguage(violation.file),
                code: violation.suggested_fix,
                context: `Suggested fix for: ${violation.message}`,
            });
        }
        else {
            // Add violation location as example
            examples.push({
                file: violation.file,
                language: this.inferLanguage(violation.file),
                code: `// See ${violation.file}${violation.line ? `:${violation.line}` : ''}`,
                context: violation.message,
            });
        }
        return examples;
    }
    /**
     * Infer programming language from file extension
     */
    inferLanguage(file) {
        const ext = file.split('.').pop()?.toLowerCase();
        const languageMap = {
            swift: 'swift',
            ts: 'typescript',
            tsx: 'typescript',
            js: 'javascript',
            jsx: 'javascript',
            py: 'python',
            java: 'java',
            kt: 'kotlin',
            go: 'go',
            rs: 'rust',
            rb: 'ruby',
            cpp: 'cpp',
            c: 'c',
            h: 'c',
            hpp: 'cpp',
            cs: 'csharp',
            php: 'php',
        };
        return languageMap[ext || ''] || 'text';
    }
    /**
     * Generate spec ID
     */
    generateSpecId(name, policyId) {
        const hash = createHash('sha256')
            .update(`${name}-${policyId}-${Date.now()}`)
            .digest('hex')
            .substring(0, 8);
        return `aoi-${hash}`;
    }
}
//# sourceMappingURL=spec-generator.js.map