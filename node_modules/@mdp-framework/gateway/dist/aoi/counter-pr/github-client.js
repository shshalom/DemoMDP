/**
 * GitHub Client
 *
 * Wrapper for GitHub API operations (branch creation, commits, PRs).
 */
export class GitHubClient {
    client;
    constructor(config) {
        this.client = config?.client;
    }
    /**
     * Create a new branch
     */
    async createBranch(repo, branchName, baseBranch = 'main') {
        if (!this.client) {
            // Simulated branch creation
            console.log(`[Simulated] Creating branch ${branchName} in ${repo}`);
            return branchName;
        }
        // Real implementation would use Octokit
        const [owner, repoName] = repo.split('/');
        const { data: ref } = await this.client.git.getRef({
            owner,
            repo: repoName,
            ref: `heads/${baseBranch}`,
        });
        await this.client.git.createRef({
            owner,
            repo: repoName,
            ref: `refs/heads/${branchName}`,
            sha: ref.object.sha,
        });
        return branchName;
    }
    /**
     * Commit files to a branch
     */
    async commitFiles(branchName, files, commitMessage, repo) {
        if (!this.client || !repo) {
            // Simulated commit
            console.log(`[Simulated] Committing ${files.length} files to ${branchName}`);
            files.forEach((f) => {
                console.log(`  - ${f.operation} ${f.path}`);
            });
            return;
        }
        // Real implementation would use Octokit
        const [owner, repoName] = repo.split('/');
        // Get current commit SHA
        const { data: ref } = await this.client.git.getRef({
            owner,
            repo: repoName,
            ref: `heads/${branchName}`,
        });
        const currentCommitSha = ref.object.sha;
        // Create blobs for each file
        const blobs = await Promise.all(files.map(async (file) => {
            const { data: blob } = await this.client.git.createBlob({
                owner,
                repo: repoName,
                content: Buffer.from(file.content).toString('base64'),
                encoding: 'base64',
            });
            return { path: file.path, sha: blob.sha, mode: '100644' };
        }));
        // Create tree
        const { data: tree } = await this.client.git.createTree({
            owner,
            repo: repoName,
            base_tree: currentCommitSha,
            tree: blobs,
        });
        // Create commit
        const { data: commit } = await this.client.git.createCommit({
            owner,
            repo: repoName,
            message: commitMessage,
            tree: tree.sha,
            parents: [currentCommitSha],
        });
        // Update reference
        await this.client.git.updateRef({
            owner,
            repo: repoName,
            ref: `heads/${branchName}`,
            sha: commit.sha,
        });
    }
    /**
     * Create a pull request
     */
    async createPullRequest(config) {
        if (!this.client) {
            // Simulated PR creation
            const simulatedPR = {
                number: Math.floor(Math.random() * 10000),
                title: config.title,
                body: config.body,
                html_url: `https://github.com/${config.repo}/pull/${Math.floor(Math.random() * 10000)}`,
                head: {
                    ref: config.head,
                    sha: 'abc123',
                    repo: {
                        full_name: config.repo,
                    },
                },
                base: {
                    ref: config.base,
                },
            };
            console.log(`[Simulated] Created PR #${simulatedPR.number}: ${config.title}`);
            console.log(`  URL: ${simulatedPR.html_url}`);
            if (config.reviewers && config.reviewers.length > 0) {
                console.log(`  Reviewers: ${config.reviewers.join(', ')}`);
            }
            return simulatedPR;
        }
        // Real implementation would use Octokit
        const [owner, repoName] = config.repo.split('/');
        const { data: pr } = await this.client.pulls.create({
            owner,
            repo: repoName,
            head: config.head,
            base: config.base,
            title: config.title,
            body: config.body,
        });
        // Add reviewers if specified
        if (config.reviewers && config.reviewers.length > 0) {
            await this.client.pulls.requestReviewers({
                owner,
                repo: repoName,
                pull_number: pr.number,
                reviewers: config.reviewers.map((r) => r.replace('@', '')),
            });
        }
        return {
            number: pr.number,
            title: pr.title,
            body: pr.body || '',
            html_url: pr.html_url,
            head: {
                ref: pr.head.ref,
                sha: pr.head.sha,
                repo: {
                    full_name: pr.head.repo.full_name,
                },
            },
            base: {
                ref: pr.base.ref,
            },
        };
    }
    /**
     * Check if client is configured
     */
    isConfigured() {
        return this.client !== undefined;
    }
}
//# sourceMappingURL=github-client.js.map