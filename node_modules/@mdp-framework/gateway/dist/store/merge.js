/**
 * Capsule Merge Semantics
 *
 * Implements Build Step 5 merge rules:
 * - Scalars/objects: last-write-wins (JSON Merge Patch)
 * - Arrays: append-only + deduplication
 *   - decisions[]: dedupe by full object equality
 *   - artifacts[]: dedupe by id field
 *   - evidence[]: dedupe by string value
 * - Auto-update timestamps.updated
 */
/**
 * Maximum capsule size (64 KB)
 */
export const MAX_CAPSULE_SIZE = 64 * 1024;
/**
 * Merge patch into capsule using Build Step 5 semantics
 */
export function mergeCapsule(base, patch) {
    // Deep clone base to avoid mutation
    const merged = JSON.parse(JSON.stringify(base));
    // Apply scalar/object fields (last-write-wins)
    for (const [key, value] of Object.entries(patch)) {
        if (value === undefined) {
            continue; // Skip undefined values
        }
        // Special handling for array fields
        if (key === 'decisions') {
            if (Array.isArray(value)) {
                merged.decisions = mergeDecisions(merged.decisions, value);
            }
        }
        else if (key === 'artifacts') {
            if (value && typeof value === 'object' && !Array.isArray(value)) {
                // artifacts is an object, merge it
                merged.artifacts = { ...merged.artifacts, ...value };
            }
        }
        else if (key === 'evidence') {
            if (Array.isArray(value)) {
                merged.evidence = mergeEvidence(merged.evidence, value);
            }
        }
        else if (key === 'policy_ids') {
            if (Array.isArray(value)) {
                // policy_ids are append-only + dedupe
                merged.policy_ids = mergePolicyIds(merged.policy_ids, value);
            }
        }
        else if (key === 'timestamps') {
            // Don't allow overwriting timestamps - we manage them
            continue;
        }
        else {
            // Standard merge patch: last write wins
            merged[key] = value;
        }
    }
    // Auto-update timestamps.updated
    if (!merged.updated_at) {
        merged.updated_at = new Date().toISOString();
    }
    else {
        merged.updated_at = new Date().toISOString();
    }
    // Increment version for optimistic concurrency
    if (typeof merged.version === 'number') {
        merged.version += 1;
    }
    return merged;
}
/**
 * Merge decisions array (append-only + dedupe by full object equality)
 */
function mergeDecisions(base, incoming) {
    if (!base)
        return incoming || [];
    if (!incoming || incoming.length === 0)
        return base;
    const merged = [...base];
    for (const newDecision of incoming) {
        // Check if this exact decision already exists
        const exists = merged.some((existing) => JSON.stringify(existing) === JSON.stringify(newDecision));
        if (!exists) {
            merged.push(newDecision);
        }
    }
    return merged;
}
/**
 * Merge evidence array (append-only + dedupe by string value)
 */
function mergeEvidence(base, incoming) {
    if (!base)
        return incoming;
    if (!incoming || incoming.length === 0)
        return base;
    // Use Map for efficient deduplication by ref
    const evidenceMap = new Map();
    // Add base evidence
    for (const item of base) {
        evidenceMap.set(item.ref, item);
    }
    // Add incoming evidence (last write wins for same ref)
    for (const item of incoming) {
        evidenceMap.set(item.ref, item);
    }
    return Array.from(evidenceMap.values());
}
/**
 * Merge policy_ids array (append-only + dedupe)
 */
function mergePolicyIds(base, incoming) {
    if (!base)
        return incoming;
    if (!incoming || incoming.length === 0)
        return base;
    const policySet = new Set(base);
    for (const policyId of incoming) {
        policySet.add(policyId);
    }
    return Array.from(policySet);
}
/**
 * Validate capsule size doesn't exceed 64 KB
 */
export function validateCapsuleSize(capsule) {
    const json = JSON.stringify(capsule);
    const size = Buffer.byteLength(json, 'utf8');
    return {
        ok: size <= MAX_CAPSULE_SIZE,
        size,
    };
}
/**
 * Check if capsule ID is valid format
 */
export function validateCapsuleId(id) {
    // capsule://proj/TEAM/kind/slug
    const pattern = /^capsule:\/\/[a-z0-9_-]+\/[A-Z0-9_-]+\/[a-z0-9_-]+\/[a-z0-9_-]+$/;
    return pattern.test(id);
}
//# sourceMappingURL=merge.js.map