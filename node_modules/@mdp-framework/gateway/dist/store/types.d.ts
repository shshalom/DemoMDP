/**
 * CapsuleStore Types
 *
 * Persistence layer for StateCapsules with dual backend support (file/postgres)
 * Implements Build Step 5 requirements:
 * - JSON Merge Patch semantics
 * - Append-only arrays with deduplication
 * - Optimistic concurrency (CAS)
 * - Retention policies
 */
import { type StateCapsule } from '@mdp-framework/schemas/contracts';
/**
 * Store operation result (Railway-oriented)
 */
export type StoreResult<T> = StoreSuccess<T> | StoreFailure;
export interface StoreSuccess<T> {
    ok: true;
    data: T;
}
export interface StoreFailure {
    ok: false;
    error: StoreError;
}
/**
 * Store error codes
 */
export interface StoreError {
    code: 'NOT_FOUND' | 'CONFLICT' | 'TOO_LARGE' | 'INVALID_ID' | 'CONNECTION_ERROR' | 'VALIDATION_ERROR' | 'PERMISSION_DENIED';
    message: string;
    details?: Record<string, unknown>;
}
/**
 * Store configuration
 */
export interface CapsuleStoreConfig {
    backend: 'file' | 'postgres';
    baseDir?: string;
    dsn?: string;
    retention?: RetentionConfig;
}
export interface RetentionConfig {
    localDays?: number;
    sharedDays?: number;
    protectOpen?: boolean;
    checkLinks?: boolean;
    protectSla?: boolean;
    protectReferenced?: boolean;
    pins?: string[];
}
/**
 * Prune result
 */
export interface PruneResult {
    candidates: PruneCandidate[];
    deleted: string[];
    errors: Array<{
        id: string;
        error: StoreError;
    }>;
}
export interface PruneCandidate {
    id: string;
    updatedAt: string;
    status?: string;
    reasons: PruneReason[];
}
export type PruneReason = 'aged_out' | 'closed' | 'no_links' | 'not_pinned' | 'not_protected';
/**
 * Export format (NDJSON)
 */
export interface ExportEntry {
    type: 'capsule' | 'envelope';
    doc: StateCapsule | unknown;
}
/**
 * List/query options
 */
export interface ListOptions {
    kind?: 'feature' | 'issue' | 'pr' | 'investigation' | 'custom';
    prefix?: string;
    status?: string;
    limit?: number;
    offset?: number;
}
/**
 * CapsuleStore interface
 *
 * Core persistence operations for StateCapsules
 */
export interface CapsuleStore {
    /**
     * Get capsule by ID
     */
    get(id: string): Promise<StoreResult<StateCapsule>>;
    /**
     * Put (create or replace) capsule
     * Uses optimistic concurrency if capsule has version field
     */
    put(capsule: StateCapsule): Promise<StoreResult<void>>;
    /**
     * Merge patch into existing capsule
     * Implements JSON Merge Patch + append-only arrays
     * Retries on conflict (up to 3x)
     */
    merge(id: string, patch: Partial<StateCapsule>): Promise<StoreResult<StateCapsule>>;
    /**
     * Delete capsule by ID
     */
    delete(id: string): Promise<StoreResult<void>>;
    /**
     * List capsules matching criteria
     */
    list(options?: ListOptions): Promise<StoreResult<string[]>>;
    /**
     * Check if capsule exists
     */
    exists(id: string): Promise<boolean>;
    /**
     * Get multiple capsules by IDs (batch operation)
     */
    getMany(ids: string[]): Promise<StoreResult<Map<string, StateCapsule>>>;
    /**
     * Prune expired capsules based on retention policy
     * Returns candidates + actually deleted IDs
     */
    prune(dryRun?: boolean): Promise<StoreResult<PruneResult>>;
    /**
     * Export capsules to NDJSON
     */
    export(options?: ListOptions): AsyncIterable<ExportEntry>;
    /**
     * Import capsules from NDJSON entries
     */
    import(entries: AsyncIterable<ExportEntry>, overwrite?: boolean): Promise<StoreResult<{
        imported: number;
        skipped: number;
        errors: Array<{
            entry: ExportEntry;
            error: StoreError;
        }>;
    }>>;
    /**
     * Close store and cleanup resources
     */
    close(): Promise<void>;
}
/**
 * Factory function type
 */
export type CreateCapsuleStore = (config: CapsuleStoreConfig) => Promise<CapsuleStore>;
//# sourceMappingURL=types.d.ts.map