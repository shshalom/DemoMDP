/**
 * FileCapsuleStore
 *
 * File-based backend for local development and IDE usage
 * Storage layout: .mlang/state/capsules/proj-TEAM/kind/slug.json
 */
import { readFile, writeFile, unlink, readdir, mkdir } from 'node:fs/promises';
import { join, dirname } from 'node:path';
import { existsSync } from 'node:fs';
import { mergeCapsule, validateCapsuleSize, validateCapsuleId, MAX_CAPSULE_SIZE, } from './merge.js';
/**
 * FileCapsuleStore implementation
 */
export class FileCapsuleStore {
    baseDir;
    retention;
    constructor(config) {
        this.baseDir = config.baseDir || join(process.cwd(), '.mlang/state/capsules');
        this.retention = {
            localDays: config.retention?.localDays ?? 14,
            sharedDays: config.retention?.sharedDays ?? 60,
            protectOpen: config.retention?.protectOpen ?? true,
            checkLinks: config.retention?.checkLinks ?? false,
            protectSla: config.retention?.protectSla ?? false,
            protectReferenced: config.retention?.protectReferenced ?? false,
            pins: config.retention?.pins ?? [],
        };
    }
    async get(id) {
        if (!validateCapsuleId(id)) {
            return {
                ok: false,
                error: { code: 'INVALID_ID', message: `Invalid capsule ID format: ${id}` },
            };
        }
        const path = this.getFilePath(id);
        try {
            if (!existsSync(path)) {
                return {
                    ok: false,
                    error: { code: 'NOT_FOUND', message: `Capsule not found: ${id}` },
                };
            }
            const content = await readFile(path, 'utf-8');
            const capsule = JSON.parse(content);
            return { ok: true, data: capsule };
        }
        catch (error) {
            return {
                ok: false,
                error: {
                    code: 'CONNECTION_ERROR',
                    message: `Failed to read capsule: ${error.message}`,
                },
            };
        }
    }
    async put(capsule) {
        if (!validateCapsuleId(capsule.id)) {
            return {
                ok: false,
                error: { code: 'INVALID_ID', message: `Invalid capsule ID format: ${capsule.id}` },
            };
        }
        // Validate size
        const sizeCheck = validateCapsuleSize(capsule);
        if (!sizeCheck.ok) {
            return {
                ok: false,
                error: {
                    code: 'TOO_LARGE',
                    message: `Capsule exceeds ${MAX_CAPSULE_SIZE} bytes (${sizeCheck.size} bytes)`,
                    details: { size: sizeCheck.size, limit: MAX_CAPSULE_SIZE },
                },
            };
        }
        const path = this.getFilePath(capsule.id);
        try {
            // Ensure directory exists
            await mkdir(dirname(path), { recursive: true });
            // Write capsule
            const content = JSON.stringify(capsule, null, 2);
            await writeFile(path, content, 'utf-8');
            return { ok: true, data: undefined };
        }
        catch (error) {
            return {
                ok: false,
                error: {
                    code: 'CONNECTION_ERROR',
                    message: `Failed to write capsule: ${error.message}`,
                },
            };
        }
    }
    async merge(id, patch) {
        // Retry up to 3 times on conflict
        const maxRetries = 3;
        for (let attempt = 0; attempt < maxRetries; attempt++) {
            // Read current capsule
            const getResult = await this.get(id);
            if (!getResult.ok) {
                return getResult;
            }
            const base = getResult.data;
            // Apply merge
            const merged = mergeCapsule(base, patch);
            // Validate size
            const sizeCheck = validateCapsuleSize(merged);
            if (!sizeCheck.ok) {
                return {
                    ok: false,
                    error: {
                        code: 'TOO_LARGE',
                        message: `Merged capsule exceeds ${MAX_CAPSULE_SIZE} bytes (${sizeCheck.size} bytes)`,
                        details: { size: sizeCheck.size, limit: MAX_CAPSULE_SIZE },
                    },
                };
            }
            // Write back
            const putResult = await this.put(merged);
            if (!putResult.ok) {
                if (putResult.error.code === 'CONFLICT' && attempt < maxRetries - 1) {
                    // Retry on conflict
                    continue;
                }
                return putResult;
            }
            return { ok: true, data: merged };
        }
        // Max retries exceeded
        return {
            ok: false,
            error: {
                code: 'CONFLICT',
                message: `Failed to merge after ${maxRetries} retries`,
            },
        };
    }
    async delete(id) {
        if (!validateCapsuleId(id)) {
            return {
                ok: false,
                error: { code: 'INVALID_ID', message: `Invalid capsule ID format: ${id}` },
            };
        }
        const path = this.getFilePath(id);
        try {
            if (!existsSync(path)) {
                return {
                    ok: false,
                    error: { code: 'NOT_FOUND', message: `Capsule not found: ${id}` },
                };
            }
            await unlink(path);
            return { ok: true, data: undefined };
        }
        catch (error) {
            return {
                ok: false,
                error: {
                    code: 'CONNECTION_ERROR',
                    message: `Failed to delete capsule: ${error.message}`,
                },
            };
        }
    }
    async list(options) {
        try {
            const ids = [];
            // Walk directory tree
            await this.walkDir(this.baseDir, async (path) => {
                if (path.endsWith('.json')) {
                    try {
                        const content = await readFile(path, 'utf-8');
                        const capsule = JSON.parse(content);
                        // Apply filters
                        if (options?.kind && capsule.kind !== options.kind)
                            return;
                        if (options?.status && capsule.metadata?.status !== options.status)
                            return;
                        if (options?.prefix && !capsule.id.startsWith(options.prefix))
                            return;
                        ids.push(capsule.id);
                    }
                    catch {
                        // Skip invalid files
                    }
                }
            });
            // Apply pagination
            let result = ids;
            if (options?.offset) {
                result = result.slice(options.offset);
            }
            if (options?.limit) {
                result = result.slice(0, options.limit);
            }
            return { ok: true, data: result };
        }
        catch (error) {
            return {
                ok: false,
                error: {
                    code: 'CONNECTION_ERROR',
                    message: `Failed to list capsules: ${error.message}`,
                },
            };
        }
    }
    async exists(id) {
        const path = this.getFilePath(id);
        return existsSync(path);
    }
    async getMany(ids) {
        const map = new Map();
        for (const id of ids) {
            const result = await this.get(id);
            if (result.ok) {
                map.set(id, result.data);
            }
        }
        return { ok: true, data: map };
    }
    async prune(dryRun = true) {
        try {
            const candidates = [];
            const deleted = [];
            const errors = [];
            const listResult = await this.list();
            if (!listResult.ok) {
                return listResult;
            }
            const now = Date.now();
            const retentionMs = this.retention.localDays * 24 * 60 * 60 * 1000;
            for (const id of listResult.data) {
                const getResult = await this.get(id);
                if (!getResult.ok) {
                    errors.push({ id, error: getResult.error });
                    continue;
                }
                const capsule = getResult.data;
                const reasons = this.getPruneReasons(capsule, now, retentionMs);
                if (reasons.length > 0) {
                    candidates.push({
                        id: capsule.id,
                        updatedAt: capsule.updated_at || capsule.created_at,
                        status: capsule.metadata?.status,
                        reasons,
                    });
                    if (!dryRun) {
                        const deleteResult = await this.delete(id);
                        if (deleteResult.ok) {
                            deleted.push(id);
                        }
                        else {
                            errors.push({ id, error: deleteResult.error });
                        }
                    }
                }
            }
            return {
                ok: true,
                data: { candidates, deleted, errors },
            };
        }
        catch (error) {
            return {
                ok: false,
                error: {
                    code: 'CONNECTION_ERROR',
                    message: `Prune failed: ${error.message}`,
                },
            };
        }
    }
    async *export(options) {
        const listResult = await this.list(options);
        if (!listResult.ok) {
            return;
        }
        for (const id of listResult.data) {
            const getResult = await this.get(id);
            if (getResult.ok) {
                yield {
                    type: 'capsule',
                    doc: getResult.data,
                };
            }
        }
    }
    async import(entries, overwrite = false) {
        let imported = 0;
        let skipped = 0;
        const errors = [];
        try {
            for await (const entry of entries) {
                if (entry.type !== 'capsule') {
                    skipped++;
                    continue;
                }
                const capsule = entry.doc;
                if (!overwrite) {
                    // Merge mode
                    const exists = await this.exists(capsule.id);
                    if (exists) {
                        const mergeResult = await this.merge(capsule.id, capsule);
                        if (mergeResult.ok) {
                            imported++;
                        }
                        else {
                            errors.push({ entry, error: mergeResult.error });
                        }
                    }
                    else {
                        const putResult = await this.put(capsule);
                        if (putResult.ok) {
                            imported++;
                        }
                        else {
                            errors.push({ entry, error: putResult.error });
                        }
                    }
                }
                else {
                    // Overwrite mode
                    const putResult = await this.put(capsule);
                    if (putResult.ok) {
                        imported++;
                    }
                    else {
                        errors.push({ entry, error: putResult.error });
                    }
                }
            }
            return { ok: true, data: { imported, skipped, errors } };
        }
        catch (error) {
            return {
                ok: false,
                error: {
                    code: 'CONNECTION_ERROR',
                    message: `Import failed: ${error.message}`,
                },
            };
        }
    }
    async close() {
        // Nothing to cleanup for file backend
    }
    /**
     * Get file system path for capsule ID
     * capsule://proj/TEAM/kind/slug -> proj-TEAM/kind/slug.json
     */
    getFilePath(id) {
        // Parse: capsule://proj/TEAM/kind/slug
        const match = id.match(/^capsule:\/\/([^/]+)\/([^/]+)\/([^/]+)\/([^/]+)$/);
        if (!match) {
            throw new Error(`Invalid capsule ID: ${id}`);
        }
        const [, proj, team, kind, slug] = match;
        return join(this.baseDir, `${proj}-${team}`, kind, `${slug}.json`);
    }
    /**
     * Recursively walk directory
     */
    async walkDir(dir, callback) {
        if (!existsSync(dir))
            return;
        const entries = await readdir(dir, { withFileTypes: true });
        for (const entry of entries) {
            const path = join(dir, entry.name);
            if (entry.isDirectory()) {
                await this.walkDir(path, callback);
            }
            else {
                await callback(path);
            }
        }
    }
    /**
     * Determine prune reasons for a capsule
     */
    getPruneReasons(capsule, now, retentionMs) {
        const reasons = [];
        // Check if pinned
        if (this.retention.pins.includes(capsule.id)) {
            return []; // Pinned capsules are never pruned
        }
        // Check age
        const timestamp = capsule.updated_at ?? capsule.created_at;
        const updatedAt = new Date(timestamp).getTime();
        const age = now - updatedAt;
        if (age > retentionMs) {
            reasons.push('aged_out');
        }
        // Check status protection
        const status = capsule.metadata?.status;
        const protectedStatuses = ['in_progress', 'in_review', 'blocked'];
        if (this.retention.protectOpen && status && protectedStatuses.includes(status)) {
            return []; // Protected by open status
        }
        if (status === 'closed' || status === 'done') {
            reasons.push('closed');
        }
        // Only prune if we have reasons
        return reasons.length > 0 ? reasons : [];
    }
}
/**
 * Create FileCapsuleStore instance
 */
export function createFileStore(config) {
    return new FileCapsuleStore(config);
}
//# sourceMappingURL=file-store.js.map