/**
 * PostgresCapsuleStore
 *
 * Postgres-based backend for team/org shared state
 * Table: mdp_capsules with JSONB document storage
 */
import pkg from 'pg';
const { Pool } = pkg;
import { mergeCapsule, validateCapsuleSize, validateCapsuleId, MAX_CAPSULE_SIZE, } from './merge.js';
/**
 * PostgresCapsuleStore implementation
 */
export class PostgresCapsuleStore {
    pool;
    retention;
    initialized = false;
    constructor(config) {
        if (!config.dsn) {
            throw new Error('PostgresCapsuleStore requires dsn configuration');
        }
        this.pool = new Pool({
            connectionString: config.dsn,
            max: 10,
            idleTimeoutMillis: 30000,
            connectionTimeoutMillis: 2000,
        });
        this.retention = {
            localDays: config.retention?.localDays ?? 14,
            sharedDays: config.retention?.sharedDays ?? 60,
            protectOpen: config.retention?.protectOpen ?? true,
            checkLinks: config.retention?.checkLinks ?? false,
            protectSla: config.retention?.protectSla ?? false,
            protectReferenced: config.retention?.protectReferenced ?? false,
            pins: config.retention?.pins ?? [],
        };
    }
    /**
     * Initialize schema (idempotent)
     */
    async ensureSchema() {
        if (this.initialized)
            return;
        const client = await this.pool.connect();
        try {
            await client.query(`
        CREATE TABLE IF NOT EXISTS mdp_capsules (
          id TEXT PRIMARY KEY,
          doc JSONB NOT NULL,
          version INT NOT NULL DEFAULT 1,
          updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
        );

        CREATE INDEX IF NOT EXISTS idx_capsules_updated_at ON mdp_capsules(updated_at);
        CREATE INDEX IF NOT EXISTS idx_capsules_kind ON mdp_capsules((doc->>'kind'));
        CREATE INDEX IF NOT EXISTS idx_capsules_status ON mdp_capsules((doc->'metadata'->>'status'));
      `);
            this.initialized = true;
        }
        finally {
            client.release();
        }
    }
    async get(id) {
        if (!validateCapsuleId(id)) {
            return {
                ok: false,
                error: {
                    code: 'INVALID_ID',
                    message: `Invalid capsule ID format: ${id}`,
                },
            };
        }
        await this.ensureSchema();
        try {
            const result = await this.pool.query('SELECT doc, version FROM mdp_capsules WHERE id = $1', [id]);
            if (result.rows.length === 0) {
                return {
                    ok: false,
                    error: {
                        code: 'NOT_FOUND',
                        message: `Capsule not found: ${id}`,
                    },
                };
            }
            const capsule = result.rows[0].doc;
            return { ok: true, data: capsule };
        }
        catch (error) {
            return {
                ok: false,
                error: {
                    code: 'CONNECTION_ERROR',
                    message: `Database error: ${error instanceof Error ? error.message : String(error)}`,
                },
            };
        }
    }
    async put(capsule) {
        if (!validateCapsuleId(capsule.id)) {
            return {
                ok: false,
                error: {
                    code: 'INVALID_ID',
                    message: `Invalid capsule ID format: ${capsule.id}`,
                },
            };
        }
        const sizeCheck = validateCapsuleSize(capsule);
        if (!sizeCheck.ok) {
            return {
                ok: false,
                error: {
                    code: 'TOO_LARGE',
                    message: `Capsule exceeds maximum size of ${MAX_CAPSULE_SIZE} bytes (${sizeCheck.size} bytes)`,
                    details: { size: sizeCheck.size, limit: MAX_CAPSULE_SIZE },
                },
            };
        }
        await this.ensureSchema();
        try {
            await this.pool.query(`INSERT INTO mdp_capsules (id, doc, version, updated_at)
         VALUES ($1, $2, $3, $4)
         ON CONFLICT (id) DO UPDATE SET
           doc = $2,
           version = $3,
           updated_at = $4`, [capsule.id, capsule, capsule.version || 1, new Date()]);
            return { ok: true, data: undefined };
        }
        catch (error) {
            return {
                ok: false,
                error: {
                    code: 'CONNECTION_ERROR',
                    message: `Database error: ${error instanceof Error ? error.message : String(error)}`,
                },
            };
        }
    }
    async merge(id, patch) {
        if (!validateCapsuleId(id)) {
            return {
                ok: false,
                error: {
                    code: 'INVALID_ID',
                    message: `Invalid capsule ID format: ${id}`,
                },
            };
        }
        await this.ensureSchema();
        // Retry loop for optimistic concurrency
        const maxRetries = 3;
        for (let attempt = 0; attempt < maxRetries; attempt++) {
            const client = await this.pool.connect();
            try {
                await client.query('BEGIN');
                // Read current version
                const getResult = await client.query('SELECT doc, version FROM mdp_capsules WHERE id = $1 FOR UPDATE', [id]);
                if (getResult.rows.length === 0) {
                    await client.query('ROLLBACK');
                    return {
                        ok: false,
                        error: {
                            code: 'NOT_FOUND',
                            message: `Capsule not found: ${id}`,
                        },
                    };
                }
                const currentCapsule = getResult.rows[0].doc;
                const currentVersion = getResult.rows[0].version;
                // Merge
                const merged = mergeCapsule(currentCapsule, patch);
                // Validate size
                const sizeCheck = validateCapsuleSize(merged);
                if (!sizeCheck.ok) {
                    await client.query('ROLLBACK');
                    return {
                        ok: false,
                        error: {
                            code: 'TOO_LARGE',
                            message: `Capsule exceeds maximum size of ${MAX_CAPSULE_SIZE} bytes (${sizeCheck.size} bytes)`,
                            details: { size: sizeCheck.size, limit: MAX_CAPSULE_SIZE },
                        },
                    };
                }
                // Update with CAS
                const updateResult = await client.query(`UPDATE mdp_capsules
           SET doc = $1, version = version + 1, updated_at = $2
           WHERE id = $3 AND version = $4
           RETURNING doc, version`, [merged, new Date(), id, currentVersion]);
                if (updateResult.rows.length === 0) {
                    // Version conflict - retry
                    await client.query('ROLLBACK');
                    if (attempt < maxRetries - 1) {
                        continue;
                    }
                    return {
                        ok: false,
                        error: {
                            code: 'CONFLICT',
                            message: `Concurrent modification detected after ${maxRetries} retries`,
                        },
                    };
                }
                await client.query('COMMIT');
                return { ok: true, data: updateResult.rows[0].doc };
            }
            catch (error) {
                await client.query('ROLLBACK');
                if (attempt === maxRetries - 1) {
                    return {
                        ok: false,
                        error: {
                            code: 'CONNECTION_ERROR',
                            message: `Database error: ${error instanceof Error ? error.message : String(error)}`,
                        },
                    };
                }
            }
            finally {
                client.release();
            }
        }
        return {
            ok: false,
            error: {
                code: 'CONFLICT',
                message: `Failed to merge after ${maxRetries} retries`,
            },
        };
    }
    async delete(id) {
        if (!validateCapsuleId(id)) {
            return {
                ok: false,
                error: {
                    code: 'INVALID_ID',
                    message: `Invalid capsule ID format: ${id}`,
                },
            };
        }
        await this.ensureSchema();
        try {
            const result = await this.pool.query('DELETE FROM mdp_capsules WHERE id = $1', [id]);
            if (result.rowCount === 0) {
                return {
                    ok: false,
                    error: {
                        code: 'NOT_FOUND',
                        message: `Capsule not found: ${id}`,
                    },
                };
            }
            return { ok: true, data: undefined };
        }
        catch (error) {
            return {
                ok: false,
                error: {
                    code: 'CONNECTION_ERROR',
                    message: `Database error: ${error instanceof Error ? error.message : String(error)}`,
                },
            };
        }
    }
    async exists(id) {
        await this.ensureSchema();
        try {
            const result = await this.pool.query('SELECT 1 FROM mdp_capsules WHERE id = $1 LIMIT 1', [id]);
            return result.rows.length > 0;
        }
        catch {
            return false;
        }
    }
    async list(options = {}) {
        await this.ensureSchema();
        try {
            let query = 'SELECT id FROM mdp_capsules WHERE 1=1';
            const params = [];
            let paramIndex = 1;
            if (options.kind) {
                query += ` AND doc->>'kind' = $${paramIndex}`;
                params.push(options.kind);
                paramIndex++;
            }
            if (options.prefix) {
                query += ` AND id LIKE $${paramIndex}`;
                params.push(`${options.prefix}%`);
                paramIndex++;
            }
            if (options.status) {
                query += ` AND doc->'metadata'->>'status' = $${paramIndex}`;
                params.push(options.status);
                paramIndex++;
            }
            query += ' ORDER BY updated_at DESC';
            if (options.limit) {
                query += ` LIMIT $${paramIndex}`;
                params.push(options.limit);
                paramIndex++;
            }
            if (options.offset) {
                query += ` OFFSET $${paramIndex}`;
                params.push(options.offset);
            }
            const result = await this.pool.query(query, params);
            const ids = result.rows.map((row) => row.id);
            return { ok: true, data: ids };
        }
        catch (error) {
            return {
                ok: false,
                error: {
                    code: 'CONNECTION_ERROR',
                    message: `Database error: ${error instanceof Error ? error.message : String(error)}`,
                },
            };
        }
    }
    async getMany(ids) {
        if (ids.length === 0) {
            return { ok: true, data: new Map() };
        }
        await this.ensureSchema();
        try {
            const result = await this.pool.query('SELECT id, doc FROM mdp_capsules WHERE id = ANY($1)', [ids]);
            const capsules = new Map();
            for (const row of result.rows) {
                capsules.set(row.id, row.doc);
            }
            return { ok: true, data: capsules };
        }
        catch (error) {
            return {
                ok: false,
                error: {
                    code: 'CONNECTION_ERROR',
                    message: `Database error: ${error instanceof Error ? error.message : String(error)}`,
                },
            };
        }
    }
    async prune(dryRun = false) {
        await this.ensureSchema();
        try {
            const candidates = [];
            const deleted = [];
            const errors = [];
            const now = Date.now();
            const retentionMs = this.retention.sharedDays * 24 * 60 * 60 * 1000;
            // Get all capsules with metadata
            const result = await this.pool.query('SELECT id, doc, updated_at FROM mdp_capsules ORDER BY updated_at DESC');
            for (const row of result.rows) {
                const id = row.id;
                const capsule = row.doc;
                const updatedAt = new Date(row.updated_at).getTime();
                const age = now - updatedAt;
                const reasons = this.getPruneReasons(capsule, age, retentionMs);
                if (reasons.length > 0) {
                    candidates.push({
                        id,
                        updatedAt: new Date(updatedAt).toISOString(),
                        status: capsule.metadata?.status,
                        reasons,
                    });
                    if (!dryRun) {
                        try {
                            await this.pool.query('DELETE FROM mdp_capsules WHERE id = $1', [id]);
                            deleted.push(id);
                        }
                        catch (error) {
                            errors.push({
                                id,
                                error: {
                                    code: 'CONNECTION_ERROR',
                                    message: `Failed to delete: ${error instanceof Error ? error.message : String(error)}`,
                                },
                            });
                        }
                    }
                    else {
                        deleted.push(id);
                    }
                }
            }
            return {
                ok: true,
                data: {
                    candidates,
                    deleted,
                    errors,
                },
            };
        }
        catch (error) {
            return {
                ok: false,
                error: {
                    code: 'CONNECTION_ERROR',
                    message: `Prune failed: ${error instanceof Error ? error.message : String(error)}`,
                },
            };
        }
    }
    getPruneReasons(capsule, age, retentionMs) {
        const reasons = [];
        // Check if pinned
        if (this.retention.pins.includes(capsule.id)) {
            return []; // Pinned capsules are never pruned
        }
        // Check age
        if (age > retentionMs) {
            reasons.push('aged_out');
        }
        // Check status protection
        const status = capsule.metadata?.status;
        const protectedStatuses = ['in_progress', 'in_review', 'blocked'];
        if (this.retention.protectOpen && status && protectedStatuses.includes(status)) {
            return []; // Protected by open status
        }
        if (status === 'closed' || status === 'done') {
            reasons.push('closed');
        }
        // Only prune if there are reasons
        return reasons.length > 0 ? reasons : [];
    }
    async *export(options = {}) {
        await this.ensureSchema();
        const listResult = await this.list(options);
        if (!listResult.ok) {
            return;
        }
        for (const id of listResult.data) {
            const getResult = await this.get(id);
            if (getResult.ok) {
                yield {
                    type: 'capsule',
                    doc: getResult.data,
                };
            }
        }
    }
    async import(entries, overwrite = false) {
        await this.ensureSchema();
        let imported = 0;
        let skipped = 0;
        const errors = [];
        for await (const entry of entries) {
            if (entry.type !== 'capsule') {
                continue;
            }
            const capsule = entry.doc;
            if (!overwrite) {
                const exists = await this.exists(capsule.id);
                if (exists) {
                    skipped++;
                    continue;
                }
            }
            const putResult = await this.put(capsule);
            if (putResult.ok) {
                imported++;
            }
            else {
                errors.push({ entry, error: putResult.error });
            }
        }
        return {
            ok: true,
            data: { imported, skipped, errors },
        };
    }
    async close() {
        await this.pool.end();
    }
}
/**
 * Factory function for PostgresCapsuleStore
 */
export async function createPostgresStore(config) {
    const store = new PostgresCapsuleStore(config);
    // Ensure schema on creation
    await store.ensureSchema();
    return store;
}
//# sourceMappingURL=postgres-store.js.map