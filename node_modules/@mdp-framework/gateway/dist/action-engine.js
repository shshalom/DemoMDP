/**
 * Action Engine (M5 - Team B)
 *
 * Executes ActionPlan with frozen verbs:
 * - gate.ci.warn, gate.ci.block
 * - remediate.suggest.patch, remediate.apply.patch, remediate.open.counter_pr
 * - notify.pr.comment, notify.slack, notify.trace
 *
 * Features:
 * - Idempotency via action keys
 * - Respects allow_enforcement flag
 * - Emits Envelopes with versioned policy_ids
 * - Error handling with ProviderError taxonomy
 */
import { ProviderError } from '@mdp-framework/adapters';
import { enforceNoChannels } from '@mdp-framework/schemas/contracts';
import { renderCommentTemplate } from './templates/index.js';
// ============================================================================
// ACTION ENGINE
// ============================================================================
export class ActionEngine {
    config;
    executedKeys = new Set();
    constructor(config) {
        this.config = config;
    }
    /**
     * Execute an ActionPlan and emit an Envelope
     */
    async execute(plan, options) {
        const startTime = Date.now();
        // Validate policy_id is versioned (no channels)
        enforceNoChannels([plan.policy_id]);
        const context = {
            config: this.config,
            plan,
            policy: options?.policy,
            capsule: options?.capsule,
            executedKeys: this.executedKeys,
        };
        const results = [];
        let overallStatus = 'success';
        // Execute actions in order
        for (const action of plan.actions) {
            try {
                // Check idempotency
                const actionKey = this.computeActionKey(plan, action);
                if (this.executedKeys.has(actionKey)) {
                    results.push({
                        action,
                        status: 'skipped',
                        metadata: { reason: 'Already executed (idempotency)' },
                    });
                    continue;
                }
                // Evaluate condition if present
                if (action.condition && !this.evaluateCondition(action.condition, context)) {
                    results.push({
                        action,
                        status: 'skipped',
                        metadata: { reason: `Condition not met: ${action.condition}` },
                    });
                    continue;
                }
                // Execute action
                const result = await this.executeAction(action, context);
                results.push(result);
                // Mark as executed
                this.executedKeys.add(actionKey);
                // Update overall status
                if (result.status === 'failed') {
                    overallStatus = 'error';
                }
                else if (result.status === 'completed' && action.verb.includes('warn')) {
                    if (overallStatus === 'success') {
                        overallStatus = 'warning';
                    }
                }
            }
            catch (error) {
                results.push({
                    action,
                    status: 'failed',
                    error: error instanceof Error ? error.message : String(error),
                });
                overallStatus = 'error';
            }
        }
        // Build envelope
        const envelope = {
            id: `envelope://${this.config.context.repo || 'unknown'}/${Date.now()}`,
            version: 'v1',
            timestamp: new Date().toISOString(),
            status: overallStatus,
            execution: {
                mode: this.config.mode,
                duration_ms: Date.now() - startTime,
                host: process.env.HOSTNAME,
                triggered_by: this.config.context.initiator,
            },
            capsule_id: options?.capsule?.id,
            policy_ids: [plan.policy_id],
            evidence_ids: options?.capsule?.evidence?.map((e) => e.ref) || [],
            actions: results.map((r) => ({
                type: this.mapVerbToActionType(r.action.verb),
                status: r.status === 'completed' ? 'completed' : r.status === 'failed' ? 'failed' : 'pending',
                ref: r.ref,
                metadata: r.metadata,
            })),
            observability: {
                trace_id: this.generateTraceId(),
                events: [],
            },
        };
        return envelope;
    }
    /**
     * Execute a single action
     */
    async executeAction(action, context) {
        const { verb, parameters } = action;
        // Check enforcement flag
        if (!this.config.allow_enforcement && this.requiresEnforcement(verb)) {
            return {
                action,
                status: 'skipped',
                metadata: {
                    reason: 'Enforcement disabled (allow_enforcement=false)',
                },
            };
        }
        // Dry-run mode
        if (this.config.mode === 'dry-run') {
            return {
                action,
                status: 'completed',
                metadata: { dry_run: true },
            };
        }
        // Execute based on verb
        try {
            switch (verb) {
                case 'gate.ci.warn':
                    return await this.executeGateWarn(parameters, context);
                case 'gate.ci.block':
                    return await this.executeGateBlock(parameters, context);
                case 'remediate.suggest.patch':
                    return await this.executeSuggestPatch(parameters, context);
                case 'remediate.apply.patch':
                    return await this.executeApplyPatch(parameters, context);
                case 'remediate.open.counter_pr':
                    return await this.executeOpenCounterPr(parameters, context);
                case 'notify.pr.comment':
                    return await this.executeNotifyComment(parameters, context);
                case 'notify.slack':
                    return await this.executeNotifySlack(parameters, context);
                case 'notify.jira.issue':
                    return await this.executeJiraIssue(parameters, context);
                case 'notify.trace':
                    return await this.executeNotifyTrace(parameters, context);
                case 'evidence.attach':
                    return await this.executeEvidenceAttach(parameters, context);
                default:
                    throw new Error(`Unknown verb: ${verb}`);
            }
        }
        catch (error) {
            if (error instanceof ProviderError) {
                return {
                    action,
                    status: 'failed',
                    error: `${error.code}: ${error.message}`,
                    metadata: {
                        provider_error: error.code,
                        retryable: error.isRetryable,
                    },
                };
            }
            throw error;
        }
    }
    // -------------------------------------------------------------------------
    // VERB IMPLEMENTATIONS
    // -------------------------------------------------------------------------
    async executeGateWarn(params, context) {
        const { pr_number, head_sha } = this.config.context;
        if (!head_sha) {
            throw new Error('head_sha required for gate.ci.warn');
        }
        const check = await this.config.adapter.createCheck({
            name: 'MDP Policy Gate',
            head_sha,
            status: 'completed',
            conclusion: 'neutral',
            title: String(params.title || 'Policy Warning'),
            summary: String(params.summary || 'One or more policies reported warnings'),
        });
        return {
            action: { verb: 'gate.ci.warn', parameters: params },
            status: 'completed',
            ref: check.name,
            metadata: { check_name: check.name },
        };
    }
    async executeGateBlock(params, context) {
        const { pr_number, head_sha } = this.config.context;
        if (!head_sha) {
            throw new Error('head_sha required for gate.ci.block');
        }
        const check = await this.config.adapter.createCheck({
            name: 'MDP Policy Gate',
            head_sha,
            status: 'completed',
            conclusion: 'failure',
            title: String(params.title || 'Policy Violation'),
            summary: String(params.summary || 'One or more policies failed'),
        });
        return {
            action: { verb: 'gate.ci.block', parameters: params },
            status: 'completed',
            ref: check.name,
            metadata: { check_name: check.name },
        };
    }
    async executeSuggestPatch(params, context) {
        const { pr_number } = this.config.context;
        if (!pr_number) {
            throw new Error('pr_number required for remediate.suggest.patch');
        }
        // Render comment with patch suggestion
        const body = renderCommentTemplate('suggest-patch', {
            policy: context.policy,
            violations: params.violations,
            patch: params.patch,
            evidence: context.capsule?.evidence,
        });
        const comment = await this.config.adapter.createComment(pr_number, body);
        return {
            action: { verb: 'remediate.suggest.patch', parameters: params },
            status: 'completed',
            ref: comment.url,
            metadata: { comment_id: comment.id },
        };
    }
    async executeApplyPatch(params, context) {
        // Apply patch requires more complex implementation
        // For now, return not implemented
        return {
            action: { verb: 'remediate.apply.patch', parameters: params },
            status: 'failed',
            error: 'remediate.apply.patch not yet implemented (requires commit API)',
        };
    }
    async executeOpenCounterPr(params, context) {
        // Opening counter PRs requires more complex implementation
        // For now, return not implemented
        return {
            action: { verb: 'remediate.open.counter_pr', parameters: params },
            status: 'failed',
            error: 'remediate.open.counter_pr not yet implemented (requires PR creation API)',
        };
    }
    async executeNotifyComment(params, context) {
        const { pr_number } = this.config.context;
        if (!pr_number) {
            throw new Error('pr_number required for notify.pr.comment');
        }
        // Render comment template
        const body = renderCommentTemplate('notification', {
            policy: context.policy,
            violations: params.violations,
            evidence: context.capsule?.evidence,
            message: params.message,
        });
        const comment = await this.config.adapter.createComment(pr_number, body);
        return {
            action: { verb: 'notify.pr.comment', parameters: params },
            status: 'completed',
            ref: comment.url,
            metadata: { comment_id: comment.id },
        };
    }
    async executeNotifySlack(params, context) {
        // Slack notifications require separate adapter
        // For now, log and skip
        console.log('Slack notification:', params);
        return {
            action: { verb: 'notify.slack', parameters: params },
            status: 'skipped',
            metadata: { reason: 'Slack adapter not yet implemented' },
        };
    }
    async executeNotifyTrace(params, context) {
        // Trace notifications just log
        console.log('Trace notification:', params);
        return {
            action: { verb: 'notify.trace', parameters: params },
            status: 'completed',
            metadata: { logged: true },
        };
    }
    async executeJiraIssue(params, context) {
        // Jira integration not yet implemented
        return {
            action: { verb: 'notify.jira.issue', parameters: params },
            status: 'skipped',
            metadata: { reason: 'Jira adapter not yet implemented' },
        };
    }
    async executeEvidenceAttach(params, context) {
        // Evidence attachment handled at capsule level
        return {
            action: { verb: 'evidence.attach', parameters: params },
            status: 'completed',
            metadata: { attached_at: 'capsule' },
        };
    }
    // -------------------------------------------------------------------------
    // HELPERS
    // -------------------------------------------------------------------------
    computeActionKey(plan, action) {
        // Create idempotency key from plan + action
        const key = `${plan.plan_id}:${action.verb}:${JSON.stringify(action.parameters)}`;
        return key;
    }
    evaluateCondition(condition, context) {
        // Simple condition evaluation
        // In production, would use a proper expression evaluator
        // For now, just return true
        return true;
    }
    requiresEnforcement(verb) {
        // Check if verb requires enforcement flag
        const enforcementVerbs = [
            'gate.ci.block',
            'remediate.apply.patch',
            'remediate.open.counter_pr',
        ];
        return enforcementVerbs.includes(verb);
    }
    mapVerbToActionType(verb) {
        if (verb.includes('gate'))
            return 'check';
        if (verb.includes('patch'))
            return 'patch';
        if (verb.includes('comment'))
            return 'comment';
        if (verb.includes('notify'))
            return 'notify';
        if (verb.includes('block'))
            return 'block';
        return 'notify';
    }
    generateTraceId() {
        return `trace-${Date.now()}-${Math.random().toString(36).substring(7)}`;
    }
}
/**
 * Create an ActionEngine instance
 */
export function createActionEngine(config) {
    return new ActionEngine(config);
}
//# sourceMappingURL=action-engine.js.map