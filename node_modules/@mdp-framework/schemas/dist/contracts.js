/**
 * @mdp-framework/schemas/contracts
 *
 * FROZEN CONTRACT EXPORTS for cross-team coordination.
 *
 * This module provides stable type definitions and schemas for Team A (M2) and Team B (M5)
 * to depend on during parallel development. Changes to these contracts require:
 *
 * 1. Major version bump
 * 2. Cross-team notification
 * 3. Migration guide in CONTRACTS.md
 *
 * Teams MUST NOT import from index.ts directly - use this contracts module instead.
 *
 * @since M1.5 (Contract Hardening)
 */
import Ajv from 'ajv';
import addFormats from 'ajv-formats';
// Import JSON schemas (Node.js v20.10+ uses 'with' instead of 'assert')
import policyCardSchema from './policy-card.schema.json' with { type: 'json' };
import stateCapsuleSchema from './state-capsule.schema.json' with { type: 'json' };
import envelopeSchema from './envelope.schema.json' with { type: 'json' };
import aoiSpecSchema from './aoi-spec.schema.json' with { type: 'json' };
import actionPlanSchema from './action-plan.schema.json' with { type: 'json' };
// ============================================================================
// VALIDATORS (FROZEN)
// ============================================================================
const ajv = new Ajv({
    allErrors: true,
    verbose: true,
    strict: false,
});
addFormats(ajv);
const validatePolicyCard = ajv.compile(policyCardSchema);
const validateStateCapsule = ajv.compile(stateCapsuleSchema);
const validateEnvelope = ajv.compile(envelopeSchema);
const validateAOISpec = ajv.compile(aoiSpecSchema);
const validateActionPlan = ajv.compile(actionPlanSchema);
function formatErrors(validate) {
    if (!validate.errors)
        return [];
    return validate.errors.map((err) => ({
        path: err.instancePath || '/',
        message: err.message || 'Validation failed',
        keyword: err.keyword,
        params: err.params,
    }));
}
export const validators = {
    policyCard: {
        validate: (data) => {
            return validatePolicyCard(data);
        },
        errors: () => formatErrors(validatePolicyCard),
    },
    stateCapsule: {
        validate: (data) => {
            return validateStateCapsule(data);
        },
        errors: () => formatErrors(validateStateCapsule),
    },
    envelope: {
        validate: (data) => {
            return validateEnvelope(data);
        },
        errors: () => formatErrors(validateEnvelope),
    },
    aoiSpec: {
        validate: (data) => {
            return validateAOISpec(data);
        },
        errors: () => formatErrors(validateAOISpec),
    },
    actionPlan: {
        validate: (data) => {
            return validateActionPlan(data);
        },
        errors: () => formatErrors(validateActionPlan),
    },
};
// ============================================================================
// SCHEMAS (FROZEN)
// ============================================================================
export const schemas = {
    policyCard: policyCardSchema,
    stateCapsule: stateCapsuleSchema,
    envelope: envelopeSchema,
    aoiSpec: aoiSpecSchema,
    actionPlan: actionPlanSchema,
};
// ============================================================================
// CONTRACT ENFORCEMENT HELPERS
// ============================================================================
/**
 * Validates that a policy_id is versioned (not a channel)
 *
 * Valid:   eng.security-review@2025.01.10
 * Invalid: eng.latest
 * Invalid: eng.security-review
 */
export function isPolicyVersioned(policyId) {
    return /^[a-z][a-z0-9-]*(?:\.[a-z][a-z0-9-]*)+@[0-9]{4}\.[0-9]{2}\.[0-9]{2}$/.test(policyId);
}
/**
 * Validates that all policy_ids in an array are versioned
 * Throws if any channel references are found
 */
export function enforceNoChannels(policyIds) {
    const channels = policyIds.filter((id) => !isPolicyVersioned(id));
    if (channels.length > 0) {
        throw new Error(`Channel references are forbidden in policy_ids. Found: ${channels.join(', ')}. ` +
            `All policy_ids must be versioned (id@YYYY.MM.DD).`);
    }
}
/**
 * Extracts the version date from a versioned policy_id
 * Returns null if policy_id is not versioned
 */
export function extractPolicyVersion(policyId) {
    const match = policyId.match(/@([0-9]{4}\.[0-9]{2}\.[0-9]{2})$/);
    return match ? match[1] : null;
}
//# sourceMappingURL=contracts.js.map