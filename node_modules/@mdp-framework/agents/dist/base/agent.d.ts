/**
 * @mdp-framework/agents - Agent Base Class
 *
 * Implements the core Agent interface from STREAM-5-MULTI-AGENT.md (FROZEN)
 *
 * Contract: Agent interface is FROZEN - changes require major version bump
 */
import type { StateCapsule, AgentHandoff } from '@mdp-framework/schemas';
/**
 * Decision made by an agent
 */
export interface Decision {
    question: string;
    answer: string;
    reasoning?: string;
    confidence?: number;
    agent?: string;
}
/**
 * Artifact produced by an agent
 */
export interface Artifact {
    uri: string;
    type: string;
    description?: string;
}
/**
 * Result of agent execution
 */
export interface AgentResult {
    /**
     * Agent name
     */
    agent: string;
    /**
     * Decisions made
     */
    decisions: Decision[];
    /**
     * Artifacts produced
     */
    artifacts: Artifact[];
    /**
     * Execution time
     */
    execution_time_ms: number;
    /**
     * Can this agent hand off to another?
     */
    can_handoff: boolean;
    /**
     * Suggested next agent (optional)
     */
    next_agent?: string;
}
/**
 * Agent interface for multi-agent orchestration
 *
 * CONTRACT: FROZEN - changes require major version bump
 */
export interface Agent {
    /**
     * Agent identifier
     */
    readonly name: string;
    /**
     * Agent role
     */
    readonly role: 'pm' | 'architect' | 'engineer' | 'designer';
    /**
     * Execute agent logic
     */
    execute(capsule: StateCapsule): Promise<AgentResult>;
    /**
     * Can this agent hand off to another agent?
     */
    canHandoffTo(agent: Agent): boolean;
    /**
     * Prepare handoff context for next agent
     */
    prepareHandoff(capsule: StateCapsule, result: AgentResult): Promise<AgentHandoff>;
}
/**
 * Base abstract class implementing common agent functionality
 *
 * Subclasses must implement:
 * - executeImpl(): Core agent logic
 * - getNextAgentRole(): Determine next agent in workflow
 */
export declare abstract class BaseAgent implements Agent {
    readonly name: string;
    readonly role: 'pm' | 'architect' | 'engineer' | 'designer';
    /**
     * Default handoff rules: PM -> Architect -> Engineer -> Designer
     */
    private static readonly DEFAULT_HANDOFF_SEQUENCE;
    constructor(name: string, role: 'pm' | 'architect' | 'engineer' | 'designer');
    /**
     * Execute agent logic with timing and error handling
     */
    execute(capsule: StateCapsule): Promise<AgentResult>;
    /**
     * Check if this agent can hand off to another agent
     *
     * Uses default sequence unless overridden
     */
    canHandoffTo(agent: Agent): boolean;
    /**
     * Prepare handoff context for next agent
     */
    prepareHandoff(capsule: StateCapsule, result: AgentResult): Promise<AgentHandoff>;
    /**
     * Execute agent-specific logic
     *
     * Subclasses implement their core agent behavior here
     */
    protected abstract executeImpl(capsule: StateCapsule): Promise<Omit<AgentResult, 'agent' | 'execution_time_ms'>>;
    /**
     * Get the next agent role in the workflow
     *
     * Returns null if this is the last agent
     */
    protected abstract getNextAgentRole(): string | null;
    /**
     * Build context summary from agent result
     */
    private buildContextSummary;
}
/**
 * Error thrown during agent execution
 */
export declare class AgentExecutionError extends Error {
    readonly agent: string;
    readonly execution_time_ms: number;
    readonly recoverable: boolean;
    constructor(agent: string, message: string, execution_time_ms: number, recoverable?: boolean);
}
//# sourceMappingURL=agent.d.ts.map