/**
 * @mdp-framework/agents - Agent Base Class
 *
 * Implements the core Agent interface from STREAM-5-MULTI-AGENT.md (FROZEN)
 *
 * Contract: Agent interface is FROZEN - changes require major version bump
 */
// ============================================================================
// Base Agent Implementation
// ============================================================================
/**
 * Base abstract class implementing common agent functionality
 *
 * Subclasses must implement:
 * - executeImpl(): Core agent logic
 * - getNextAgentRole(): Determine next agent in workflow
 */
export class BaseAgent {
    name;
    role;
    /**
     * Default handoff rules: PM -> Architect -> Engineer -> Designer
     */
    static DEFAULT_HANDOFF_SEQUENCE = {
        pm: ['architect', 'engineer'],
        architect: ['engineer', 'designer'],
        engineer: ['designer'],
        designer: [],
    };
    constructor(name, role) {
        this.name = name;
        this.role = role;
    }
    /**
     * Execute agent logic with timing and error handling
     */
    async execute(capsule) {
        const startTime = Date.now();
        try {
            // Execute agent-specific logic
            const result = await this.executeImpl(capsule);
            // Calculate execution time
            const execution_time_ms = Date.now() - startTime;
            return {
                ...result,
                agent: this.name,
                execution_time_ms,
            };
        }
        catch (error) {
            const execution_time_ms = Date.now() - startTime;
            // Convert error to agent result with error information
            throw new AgentExecutionError(this.name, error instanceof Error ? error.message : 'Unknown error', execution_time_ms);
        }
    }
    /**
     * Check if this agent can hand off to another agent
     *
     * Uses default sequence unless overridden
     */
    canHandoffTo(agent) {
        const allowedRoles = BaseAgent.DEFAULT_HANDOFF_SEQUENCE[this.role] || [];
        return allowedRoles.includes(agent.role);
    }
    /**
     * Prepare handoff context for next agent
     */
    async prepareHandoff(capsule, result) {
        const nextAgent = result.next_agent || this.getNextAgentRole();
        if (!nextAgent) {
            throw new Error(`Agent ${this.name} cannot determine next agent for handoff`);
        }
        // Build context summary from decisions
        const context_summary = this.buildContextSummary(result);
        return {
            from: this.name,
            to: nextAgent,
            decisions: result.decisions.map((d) => ({
                question: d.question,
                answer: String(d.answer),
                reasoning: d.reasoning,
                confidence: d.confidence,
            })),
            artifacts: result.artifacts,
            context_summary,
            timestamp: new Date().toISOString(),
            metadata: {
                role: this.role,
                execution_time_ms: result.execution_time_ms,
            },
        };
    }
    // ============================================================================
    // Helper methods
    // ============================================================================
    /**
     * Build context summary from agent result
     */
    buildContextSummary(result) {
        const parts = [];
        // Add role context
        parts.push(`Agent: ${this.name} (${this.role})`);
        // Add decision summary
        if (result.decisions.length > 0) {
            parts.push(`\nDecisions made: ${result.decisions.length}`);
            parts.push('Key decisions:');
            result.decisions.slice(0, 3).forEach((d) => {
                parts.push(`- ${d.question}: ${d.answer}`);
            });
        }
        // Add artifact summary
        if (result.artifacts.length > 0) {
            parts.push(`\nArtifacts produced: ${result.artifacts.length}`);
            result.artifacts.forEach((a) => {
                parts.push(`- ${a.type}: ${a.uri}`);
            });
        }
        return parts.join('\n');
    }
}
// ============================================================================
// Error Types
// ============================================================================
/**
 * Error thrown during agent execution
 */
export class AgentExecutionError extends Error {
    agent;
    execution_time_ms;
    recoverable;
    constructor(agent, message, execution_time_ms, recoverable = true) {
        super(`Agent ${agent} failed: ${message}`);
        this.agent = agent;
        this.execution_time_ms = execution_time_ms;
        this.recoverable = recoverable;
        this.name = 'AgentExecutionError';
    }
}
//# sourceMappingURL=agent.js.map