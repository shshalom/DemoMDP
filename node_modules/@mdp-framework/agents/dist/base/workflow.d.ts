/**
 * @mdp-framework/agents - Agent Workflow
 *
 * Implements multi-agent workflow orchestration
 *
 * Contract: AgentWorkflow interface is FROZEN per STREAM-5-MULTI-AGENT.md
 */
import type { StateCapsule, WorkflowResult } from '@mdp-framework/schemas';
import type { Agent } from './agent.js';
import { type Blackboard } from './blackboard.js';
import { HandoffManager } from './handoff.js';
export interface WorkflowStatus {
    state: 'idle' | 'running' | 'completed' | 'failed';
    currentAgent?: string;
    agentsCompleted: string[];
    startTime?: number;
    endTime?: number;
}
/**
 * AgentWorkflow interface for orchestrating multi-agent execution
 *
 * CONTRACT: FROZEN - changes require major version bump
 */
export interface AgentWorkflow {
    /**
     * Execute workflow with agents in sequence
     */
    execute(capsule: StateCapsule, agents: Agent[]): Promise<WorkflowResult>;
    /**
     * Add agent to workflow
     */
    addAgent(agent: Agent, position?: number): void;
    /**
     * Remove agent from workflow
     */
    removeAgent(agentName: string): void;
    /**
     * Get workflow status
     */
    getStatus(): WorkflowStatus;
}
export interface WorkflowConfig {
    /**
     * Maximum execution time per agent (ms)
     */
    maxAgentTimeoutMs?: number;
    /**
     * Maximum total workflow execution time (ms)
     */
    maxWorkflowTimeoutMs?: number;
    /**
     * Whether to continue on agent failure
     */
    continueOnError?: boolean;
    /**
     * Maximum number of retries per agent
     */
    maxRetries?: number;
    /**
     * Custom blackboard implementation
     */
    blackboard?: Blackboard;
}
/**
 * Sequential workflow orchestrator for multi-agent execution
 *
 * Coordinates agent execution, handoffs, and shared state
 */
export declare class SequentialAgentWorkflow implements AgentWorkflow {
    private agents;
    private status;
    private config;
    private blackboard;
    private handoffManager;
    private contextBuilder;
    constructor(config?: WorkflowConfig);
    /**
     * Add agent to workflow
     */
    addAgent(agent: Agent, position?: number): void;
    /**
     * Remove agent from workflow
     */
    removeAgent(agentName: string): void;
    /**
     * Get workflow status
     */
    getStatus(): WorkflowStatus;
    /**
     * Execute workflow with agents in sequence
     */
    execute(capsule: StateCapsule, agents?: Agent[]): Promise<WorkflowResult>;
    /**
     * Execute agent with retry logic
     */
    private executeAgentWithRetry;
    /**
     * Execute agent with timeout
     */
    private executeAgentWithTimeout;
    /**
     * Update capsule with decisions from agent
     */
    private updateCapsuleWithDecisions;
    /**
     * Reset workflow state (useful for reuse)
     */
    reset(): void;
    /**
     * Get blackboard instance (for testing/debugging)
     */
    getBlackboard(): Blackboard;
    /**
     * Get handoff manager (for testing/debugging)
     */
    getHandoffManager(): HandoffManager;
}
/**
 * Error thrown during workflow execution
 */
export declare class WorkflowError extends Error {
    readonly recoverable: boolean;
    constructor(message: string, recoverable?: boolean);
}
//# sourceMappingURL=workflow.d.ts.map