/**
 * @mdp-framework/agents - Agent Workflow
 *
 * Implements multi-agent workflow orchestration
 *
 * Contract: AgentWorkflow interface is FROZEN per STREAM-5-MULTI-AGENT.md
 */
import { InMemoryBlackboard } from './blackboard.js';
import { HandoffManager, ContextBuilder } from './handoff.js';
const DEFAULT_CONFIG = {
    maxAgentTimeoutMs: 60_000, // 60 seconds per agent
    maxWorkflowTimeoutMs: 300_000, // 5 minutes total
    continueOnError: false,
    maxRetries: 1,
};
// ============================================================================
// AgentWorkflow Implementation
// ============================================================================
/**
 * Sequential workflow orchestrator for multi-agent execution
 *
 * Coordinates agent execution, handoffs, and shared state
 */
export class SequentialAgentWorkflow {
    agents = [];
    status = {
        state: 'idle',
        agentsCompleted: [],
    };
    config;
    blackboard;
    handoffManager;
    contextBuilder;
    constructor(config = {}) {
        this.config = { ...DEFAULT_CONFIG, ...config };
        this.blackboard = config.blackboard || new InMemoryBlackboard();
        this.handoffManager = new HandoffManager(this.blackboard);
        this.contextBuilder = new ContextBuilder(this.blackboard);
    }
    /**
     * Add agent to workflow
     */
    addAgent(agent, position) {
        if (position !== undefined && position >= 0 && position <= this.agents.length) {
            this.agents.splice(position, 0, agent);
        }
        else {
            this.agents.push(agent);
        }
    }
    /**
     * Remove agent from workflow
     */
    removeAgent(agentName) {
        const index = this.agents.findIndex((a) => a.name === agentName);
        if (index !== -1) {
            this.agents.splice(index, 1);
        }
    }
    /**
     * Get workflow status
     */
    getStatus() {
        return { ...this.status };
    }
    /**
     * Execute workflow with agents in sequence
     */
    async execute(capsule, agents) {
        const workflowStartTime = Date.now();
        const agentsToExecute = agents || this.agents;
        if (agentsToExecute.length === 0) {
            throw new WorkflowError('No agents to execute', false);
        }
        // Initialize workflow state
        this.status = {
            state: 'running',
            agentsCompleted: [],
            startTime: workflowStartTime,
        };
        const agentsInvoked = [];
        const allHandoffs = [];
        let lastResult = null;
        let workflowError;
        try {
            // Execute agents sequentially
            for (let i = 0; i < agentsToExecute.length; i++) {
                const agent = agentsToExecute[i];
                const nextAgent = agentsToExecute[i + 1];
                // Check workflow timeout
                if (Date.now() - workflowStartTime > this.config.maxWorkflowTimeoutMs) {
                    throw new WorkflowError(`Workflow timeout exceeded (${this.config.maxWorkflowTimeoutMs}ms)`, false);
                }
                // Update status
                this.status.currentAgent = agent.name;
                try {
                    // Execute agent with retry logic
                    const result = await this.executeAgentWithRetry(agent, capsule);
                    lastResult = result;
                    agentsInvoked.push(agent.name);
                    this.status.agentsCompleted.push(agent.name);
                    // Write decisions and artifacts to blackboard
                    result.decisions.forEach((decision) => {
                        this.blackboard.writeDecision(agent.name, decision);
                    });
                    result.artifacts.forEach((artifact) => {
                        this.blackboard.writeArtifact(agent.name, artifact);
                    });
                    // Update capsule with decisions
                    this.updateCapsuleWithDecisions(capsule, result.decisions);
                    // Perform handoff if there's a next agent
                    if (nextAgent && result.can_handoff) {
                        const handoff = await this.handoffManager.executeHandoff(agent, nextAgent, capsule, result);
                        allHandoffs.push(handoff);
                    }
                }
                catch (error) {
                    agentsInvoked.push(agent.name);
                    workflowError = {
                        agent: agent.name,
                        message: error instanceof Error ? error.message : 'Unknown error',
                        recoverable: error instanceof WorkflowError ? error.recoverable : true,
                    };
                    // Continue on error if configured
                    if (!this.config.continueOnError) {
                        throw error;
                    }
                    break;
                }
            }
            // Mark workflow as completed
            this.status.state = workflowError ? 'failed' : 'completed';
            this.status.endTime = Date.now();
            // Aggregate final decisions from blackboard
            const finalDecisions = this.blackboard.readDecisions();
            return {
                capsule_id: capsule.id,
                agents_invoked: agentsInvoked,
                handoffs: allHandoffs,
                final_decisions: finalDecisions,
                execution_time_ms: Date.now() - workflowStartTime,
                status: workflowError ? 'failed' : 'success',
                error: workflowError,
            };
        }
        catch (error) {
            this.status.state = 'failed';
            this.status.endTime = Date.now();
            // Create error result
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            const recoverable = error instanceof WorkflowError ? error.recoverable : true;
            return {
                capsule_id: capsule.id,
                agents_invoked: agentsInvoked,
                handoffs: allHandoffs,
                final_decisions: this.blackboard.readDecisions(),
                execution_time_ms: Date.now() - workflowStartTime,
                status: 'failed',
                error: {
                    agent: this.status.currentAgent || 'unknown',
                    message: errorMessage,
                    recoverable,
                },
            };
        }
    }
    /**
     * Execute agent with retry logic
     */
    async executeAgentWithRetry(agent, capsule, attempt = 0) {
        try {
            // Execute with timeout
            const result = await this.executeAgentWithTimeout(agent, capsule);
            return result;
        }
        catch (error) {
            // Retry if configured
            if (attempt < this.config.maxRetries) {
                return this.executeAgentWithRetry(agent, capsule, attempt + 1);
            }
            throw error;
        }
    }
    /**
     * Execute agent with timeout
     */
    async executeAgentWithTimeout(agent, capsule) {
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new WorkflowError(`Agent ${agent.name} exceeded timeout (${this.config.maxAgentTimeoutMs}ms)`, true));
            }, this.config.maxAgentTimeoutMs);
            agent
                .execute(capsule)
                .then((result) => {
                clearTimeout(timeout);
                resolve(result);
            })
                .catch((error) => {
                clearTimeout(timeout);
                reject(error);
            });
        });
    }
    /**
     * Update capsule with decisions from agent
     */
    updateCapsuleWithDecisions(capsule, decisions) {
        if (!capsule.decisions) {
            capsule.decisions = [];
        }
        decisions.forEach((decision) => {
            capsule.decisions.push({
                question: decision.question,
                answer: decision.answer,
                timestamp: new Date().toISOString(),
                source: 'agent',
            });
        });
        capsule.updated_at = new Date().toISOString();
        capsule.version++;
    }
    /**
     * Reset workflow state (useful for reuse)
     */
    reset() {
        this.status = {
            state: 'idle',
            agentsCompleted: [],
        };
        this.handoffManager.clear();
        this.blackboard.clear();
    }
    /**
     * Get blackboard instance (for testing/debugging)
     */
    getBlackboard() {
        return this.blackboard;
    }
    /**
     * Get handoff manager (for testing/debugging)
     */
    getHandoffManager() {
        return this.handoffManager;
    }
}
// ============================================================================
// Error Types
// ============================================================================
/**
 * Error thrown during workflow execution
 */
export class WorkflowError extends Error {
    recoverable;
    constructor(message, recoverable = false) {
        super(message);
        this.recoverable = recoverable;
        this.name = 'WorkflowError';
    }
}
//# sourceMappingURL=workflow.js.map