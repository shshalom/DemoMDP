/**
 * @mdp-framework/agents - Handoff Protocol
 *
 * Implements agent-to-agent handoff mechanism
 *
 * Contract: Handoff protocol is FROZEN per STREAM-5-MULTI-AGENT.md
 */
// ============================================================================
// Handoff Manager
// ============================================================================
/**
 * Manages handoffs between agents
 *
 * Coordinates the transfer of context, decisions, and artifacts
 */
export class HandoffManager {
    blackboard;
    handoffs = [];
    constructor(blackboard) {
        this.blackboard = blackboard;
    }
    /**
     * Execute handoff from one agent to another
     *
     * @param fromAgent - Agent performing the handoff
     * @param toAgent - Agent receiving the handoff
     * @param capsule - Current state capsule
     * @param result - Result from the 'from' agent
     * @returns Updated handoff record
     */
    async executeHandoff(fromAgent, toAgent, capsule, result) {
        const startTime = Date.now();
        // Validate handoff
        this.validateHandoff(fromAgent, toAgent, result);
        // Prepare handoff context
        const handoff = await fromAgent.prepareHandoff(capsule, result);
        // Note: Decisions and artifacts are written to blackboard by the workflow
        // to ensure they're captured even when there's no handoff
        // Update handoff metadata
        const handoffTime = Date.now() - startTime;
        handoff.metadata = {
            ...handoff.metadata,
            handoff_time_ms: handoffTime,
            blackboard_decisions: this.blackboard.readDecisions().length,
            blackboard_artifacts: this.blackboard.readArtifacts().length,
        };
        // Record handoff
        this.handoffs.push(handoff);
        return handoff;
    }
    /**
     * Validate that handoff is allowed
     */
    validateHandoff(fromAgent, toAgent, result) {
        // Check if agent can hand off
        if (!result.can_handoff) {
            throw new HandoffError(fromAgent.name, toAgent.name, 'Agent cannot perform handoff', false);
        }
        // Check if handoff is allowed by agent rules
        if (!fromAgent.canHandoffTo(toAgent)) {
            throw new HandoffError(fromAgent.name, toAgent.name, `Handoff from ${fromAgent.role} to ${toAgent.role} is not allowed`, false);
        }
        // Check for circular handoffs
        const recentHandoffs = this.handoffs.slice(-10); // Check last 10 handoffs
        const circularCheck = recentHandoffs.filter((h) => h.from === fromAgent.name && h.to === toAgent.name);
        if (circularCheck.length >= 2) {
            throw new HandoffError(fromAgent.name, toAgent.name, 'Circular handoff detected', false);
        }
    }
    /**
     * Get all handoffs
     */
    getHandoffs() {
        return [...this.handoffs];
    }
    /**
     * Get handoffs involving a specific agent
     */
    getHandoffsForAgent(agentName) {
        return this.handoffs.filter((h) => h.from === agentName || h.to === agentName);
    }
    /**
     * Get the last handoff
     */
    getLastHandoff() {
        return this.handoffs.length > 0 ? this.handoffs[this.handoffs.length - 1] : null;
    }
    /**
     * Get handoff chain (sequence of handoffs)
     */
    getHandoffChain() {
        const chain = [];
        if (this.handoffs.length === 0)
            return chain;
        // Start with the first agent
        chain.push(this.handoffs[0].from);
        // Add all subsequent agents
        this.handoffs.forEach((h) => {
            chain.push(h.to);
        });
        return chain;
    }
    /**
     * Get handoff statistics
     */
    getStats() {
        const totalHandoffs = this.handoffs.length;
        // Calculate average handoff time
        let totalTime = 0;
        this.handoffs.forEach((h) => {
            if (h.metadata?.handoff_time_ms) {
                totalTime += h.metadata.handoff_time_ms;
            }
        });
        const averageHandoffTimeMs = totalHandoffs > 0 ? totalTime / totalHandoffs : 0;
        return {
            totalHandoffs,
            averageHandoffTimeMs,
            handoffChain: this.getHandoffChain(),
        };
    }
    /**
     * Clear all handoffs (useful for testing)
     */
    clear() {
        this.handoffs = [];
    }
}
// ============================================================================
// Context Builder
// ============================================================================
/**
 * Builds rich context for agent execution
 */
export class ContextBuilder {
    blackboard;
    constructor(blackboard) {
        this.blackboard = blackboard;
    }
    /**
     * Build context for an agent
     *
     * Combines capsule data with blackboard state
     */
    buildContext(agent, capsule, handoff) {
        const parts = [];
        // Add agent header
        parts.push(`# Context for ${agent.name} (${agent.role})`);
        parts.push('');
        // Add capsule context
        if (capsule.context) {
            parts.push('## Capsule Context');
            parts.push(`- ID: ${capsule.id}`);
            parts.push(`- Kind: ${capsule.kind}`);
            if (capsule.context.repo)
                parts.push(`- Repository: ${capsule.context.repo}`);
            if (capsule.context.branch)
                parts.push(`- Branch: ${capsule.context.branch}`);
            if (capsule.context.pr_number)
                parts.push(`- PR: #${capsule.context.pr_number}`);
            parts.push('');
        }
        // Add handoff context if provided
        if (handoff) {
            parts.push('## Handoff Context');
            parts.push(`From: ${handoff.from}`);
            parts.push(`Summary: ${handoff.context_summary}`);
            parts.push('');
        }
        // Add blackboard context
        const blackboardContext = this.blackboard.getContextFor(agent);
        if (blackboardContext) {
            parts.push('## Shared State');
            parts.push(blackboardContext);
            parts.push('');
        }
        return parts.join('\n');
    }
    /**
     * Build minimal context (for token optimization)
     */
    buildMinimalContext(agent, capsule) {
        const parts = [];
        parts.push(`${agent.name} (${agent.role})`);
        parts.push(`Capsule: ${capsule.id} (${capsule.kind})`);
        // Add only the most recent decisions
        const decisions = this.blackboard.readDecisions();
        if (decisions.length > 0) {
            parts.push(`Previous decisions: ${decisions.length}`);
            const recent = decisions.slice(-3);
            recent.forEach((d) => {
                parts.push(`- ${d.question}: ${d.answer}`);
            });
        }
        return parts.join('\n');
    }
}
// ============================================================================
// Error Types
// ============================================================================
/**
 * Error thrown during handoff
 */
export class HandoffError extends Error {
    fromAgent;
    toAgent;
    recoverable;
    constructor(fromAgent, toAgent, message, recoverable = false) {
        super(`Handoff ${fromAgent} -> ${toAgent} failed: ${message}`);
        this.fromAgent = fromAgent;
        this.toAgent = toAgent;
        this.recoverable = recoverable;
        this.name = 'HandoffError';
    }
}
//# sourceMappingURL=handoff.js.map