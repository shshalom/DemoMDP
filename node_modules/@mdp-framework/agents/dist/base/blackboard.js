/**
 * @mdp-framework/agents - Blackboard Pattern
 *
 * Implements shared state coordination for multi-agent systems
 *
 * Contract: Blackboard interface is FROZEN per STREAM-5-MULTI-AGENT.md
 */
// ============================================================================
// Blackboard Implementation
// ============================================================================
/**
 * In-memory implementation of the Blackboard pattern
 *
 * Provides thread-safe coordination for multi-agent workflows
 */
export class InMemoryBlackboard {
    decisions = [];
    artifacts = [];
    /**
     * Write decision to shared state
     */
    writeDecision(agent, decision) {
        this.decisions.push({
            agent,
            decision: {
                ...decision,
                agent: agent, // Ensure agent is set
            },
            timestamp: new Date().toISOString(),
        });
    }
    /**
     * Read all decisions
     */
    readDecisions() {
        return this.decisions.map((entry) => entry.decision);
    }
    /**
     * Get decisions by agent
     */
    getDecisionsByAgent(agentName) {
        return this.decisions
            .filter((entry) => entry.agent === agentName)
            .map((entry) => entry.decision);
    }
    /**
     * Write artifact to shared state
     */
    writeArtifact(agent, artifact) {
        this.artifacts.push({
            agent,
            artifact,
            timestamp: new Date().toISOString(),
        });
    }
    /**
     * Read all artifacts
     */
    readArtifacts() {
        return this.artifacts.map((entry) => entry.artifact);
    }
    /**
     * Get artifacts by agent
     */
    getArtifactsByAgent(agentName) {
        return this.artifacts
            .filter((entry) => entry.agent === agentName)
            .map((entry) => entry.artifact);
    }
    /**
     * Get context summary for agent
     *
     * Provides a formatted summary of relevant decisions and artifacts
     */
    getContextFor(agent) {
        const parts = [];
        // Add header
        parts.push(`Context for ${agent.name} (${agent.role})`);
        parts.push('='.repeat(50));
        // Add decisions from previous agents
        const previousDecisions = this.decisions.filter((entry) => entry.agent !== agent.name);
        if (previousDecisions.length > 0) {
            parts.push('\n## Previous Decisions:');
            previousDecisions.forEach((entry, index) => {
                parts.push(`\n${index + 1}. [${entry.agent}] ${entry.decision.question}`);
                parts.push(`   Answer: ${entry.decision.answer}`);
                if (entry.decision.reasoning) {
                    parts.push(`   Reasoning: ${entry.decision.reasoning}`);
                }
            });
        }
        // Add artifacts from previous agents
        const previousArtifacts = this.artifacts.filter((entry) => entry.agent !== agent.name);
        if (previousArtifacts.length > 0) {
            parts.push('\n## Previous Artifacts:');
            previousArtifacts.forEach((entry, index) => {
                parts.push(`\n${index + 1}. [${entry.agent}] ${entry.artifact.type}: ${entry.artifact.uri}`);
                if (entry.artifact.description) {
                    parts.push(`   Description: ${entry.artifact.description}`);
                }
            });
        }
        // Add role-specific context
        const roleContext = this.getRoleSpecificContext(agent.role);
        if (roleContext) {
            parts.push('\n## Role-Specific Context:');
            parts.push(roleContext);
        }
        return parts.join('\n');
    }
    /**
     * Get role-specific context hints
     */
    getRoleSpecificContext(role) {
        switch (role) {
            case 'pm':
                return 'Focus on: Requirements, scope, priorities, stakeholder needs';
            case 'architect':
                return 'Focus on: System design, component interactions, technical decisions, scalability';
            case 'engineer':
                return 'Focus on: Implementation details, code structure, technical feasibility, testing';
            case 'designer':
                return 'Focus on: UI/UX, accessibility, design system, user flows';
            default:
                return '';
        }
    }
    /**
     * Clear all data (useful for testing)
     */
    clear() {
        this.decisions = [];
        this.artifacts = [];
    }
    /**
     * Get statistics about the blackboard
     */
    getStats() {
        const agentCounts = {};
        // Count decisions per agent
        this.decisions.forEach((entry) => {
            if (!agentCounts[entry.agent]) {
                agentCounts[entry.agent] = { decisions: 0, artifacts: 0 };
            }
            agentCounts[entry.agent].decisions++;
        });
        // Count artifacts per agent
        this.artifacts.forEach((entry) => {
            if (!agentCounts[entry.agent]) {
                agentCounts[entry.agent] = { decisions: 0, artifacts: 0 };
            }
            agentCounts[entry.agent].artifacts++;
        });
        return {
            totalDecisions: this.decisions.length,
            totalArtifacts: this.artifacts.length,
            agentCounts,
        };
    }
}
//# sourceMappingURL=blackboard.js.map