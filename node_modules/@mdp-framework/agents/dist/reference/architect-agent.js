/**
 * @mdp-framework/agents - Architect Agent
 *
 * Architect agent for technical architecture design and decisions
 */
import { BaseAgent } from '../base/agent.js';
import { ARCHITECT_SYSTEM_PROMPT, ARCHITECT_ANALYSIS_PROMPT, } from './prompts/architect-prompts.js';
import architectDecisionSchema from './schemas/architect-decision.schema.json' with { type: 'json' };
/**
 * Architect Agent
 *
 * Reviews PM requirements, applies architecture policies,
 * designs components, and makes architectural decisions.
 */
export class ArchitectAgent extends BaseAgent {
    aiProvider;
    mcpClient;
    model;
    temperature;
    maxTokens;
    constructor(config) {
        super('architect', 'architect');
        this.aiProvider = config.aiProvider;
        this.mcpClient = config.mcpClient;
        this.model = config.model || 'claude-sonnet-4.5';
        this.temperature = config.temperature ?? 0.1;
        this.maxTokens = config.maxTokens || 6000;
    }
    /**
     * Execute architecture design
     */
    async executeImpl(capsule) {
        // Extract context from capsule and previous decisions
        const context = await this.extractContext(capsule);
        // Query architecture policies (if MCP client available)
        const policies = await this.queryPolicies(capsule);
        context.policies = policies;
        // Build prompt with context
        const analysisPrompt = this.buildAnalysisPrompt(context);
        // Call LLM for architecture design
        const completion = await this.aiProvider.complete({
            model: this.model,
            prompt: `${ARCHITECT_SYSTEM_PROMPT}\n\n${analysisPrompt}`,
            temperature: this.temperature,
            max_tokens: this.maxTokens,
            schema: architectDecisionSchema,
        });
        // Parse structured output
        const architectDecision = JSON.parse(completion.content);
        // Convert to agent decisions
        const decisions = this.convertToDecisions(architectDecision);
        // Create artifacts
        const artifacts = this.createArtifacts(architectDecision, capsule);
        return {
            decisions,
            artifacts,
            can_handoff: true,
            next_agent: 'engineer',
        };
    }
    /**
     * Get next agent role (Engineer)
     */
    getNextAgentRole() {
        return 'engineer';
    }
    /**
     * Extract context from capsule and PM decisions
     */
    async extractContext(capsule) {
        const context = {
            pm_summary: '',
            pm_requirements: '',
            pm_decisions: '',
            repo: 'unknown',
            tech_stack: 'unknown',
            arch_pattern: 'unknown',
            components: '',
            policies: '',
        };
        // Extract PM context from previous decisions
        if (capsule.decisions && capsule.decisions.length > 0) {
            const pmDecisions = capsule.decisions.filter((d) => d.source === 'agent' || !d.source);
            if (pmDecisions.length > 0) {
                // Create PM summary
                context.pm_summary = `PM identified ${pmDecisions.length} key decisions and requirements.`;
                // Extract requirements
                const requirements = pmDecisions
                    .filter((d) => String(d.question).startsWith('Requirement:'))
                    .map((d) => `- ${d.answer}`)
                    .join('\n');
                context.pm_requirements = requirements || 'No specific requirements captured';
                // Extract decisions
                const decisions = pmDecisions
                    .filter((d) => !String(d.question).startsWith('Requirement:'))
                    .map((d) => `Q: ${d.question}\nA: ${d.answer}`)
                    .join('\n\n');
                context.pm_decisions = decisions || 'No specific decisions captured';
            }
        }
        // Extract repo
        if (capsule.context?.repo) {
            context.repo = String(capsule.context.repo);
        }
        // Extract tech stack
        if (capsule.metadata?.tech_stack) {
            context.tech_stack = String(capsule.metadata.tech_stack);
        }
        // Extract architecture pattern
        if (capsule.metadata?.arch_pattern) {
            context.arch_pattern = String(capsule.metadata.arch_pattern);
        }
        // Extract components
        if (capsule.metadata?.components) {
            const components = capsule.metadata.components;
            if (Array.isArray(components)) {
                context.components = components.join(', ');
            }
            else {
                context.components = String(components);
            }
        }
        return context;
    }
    /**
     * Query architecture policies via MCP
     * TODO: Integrate with Stream 3 MCP Server
     */
    async queryPolicies(capsule) {
        if (!this.mcpClient) {
            return 'No architecture policies available (MCP client not configured)';
        }
        try {
            // TODO: Query MCP for architecture policies
            // const policies = await this.mcpClient.call('policy.search', {
            //   tags: ['architecture', capsule.metadata?.tech_stack],
            //   scope: 'repo'
            // });
            // return JSON.stringify(policies, null, 2);
            return 'MCP policy integration pending (Stream 3)';
        }
        catch (error) {
            return `Policy query failed: ${error instanceof Error ? error.message : 'Unknown error'}`;
        }
    }
    /**
     * Build analysis prompt with context
     */
    buildAnalysisPrompt(context) {
        let prompt = ARCHITECT_ANALYSIS_PROMPT;
        // Simple template replacement
        for (const [key, value] of Object.entries(context)) {
            const regex = new RegExp(`{{${key}}}`, 'g');
            prompt = prompt.replace(regex, value);
        }
        // Handle conditionals
        if (context.policies && context.policies !== 'No architecture policies available') {
            prompt = prompt.replace(/{{#if policies}}[\s\S]*?{{else}}[\s\S]*?{{\/if}}/g, (match) => {
                return match
                    .split('{{else}}')[0]
                    .replace('{{#if policies}}', '')
                    .replace('{{policies}}', context.policies);
            });
        }
        else {
            prompt = prompt.replace(/{{#if policies}}[\s\S]*?{{else}}([\s\S]*?){{\/if}}/g, '$1');
        }
        if (context.components) {
            prompt = prompt.replace(/{{#if components}}[\s\S]*?{{\/if}}/g, (match) => {
                return match
                    .replace('{{#if components}}', '')
                    .replace('{{/if}}', '')
                    .replace('{{components}}', context.components);
            });
        }
        else {
            prompt = prompt.replace(/{{#if components}}[\s\S]*?{{\/if}}/g, '');
        }
        return prompt;
    }
    /**
     * Convert architect decision to agent decisions
     */
    convertToDecisions(architectDecision) {
        const decisions = [];
        // Add component decisions
        architectDecision.components.forEach((component) => {
            decisions.push({
                question: `Component: ${component.name}`,
                answer: `[${component.type}] ${component.purpose}`,
                reasoning: component.rationale,
                confidence: 0.85,
            });
        });
        // Add architecture decisions
        architectDecision.architecture_decisions.forEach((decision) => {
            decisions.push({
                question: decision.question,
                answer: decision.answer,
                reasoning: decision.reasoning,
                confidence: decision.confidence || 0.8,
            });
        });
        return decisions;
    }
    /**
     * Create artifacts from architect decision
     */
    createArtifacts(architectDecision, capsule) {
        const artifacts = [];
        // Create architecture design artifact
        artifacts.push({
            uri: `artifact://architect/${capsule.id}/architecture.json`,
            type: 'architecture_design',
            description: 'Component architecture and design decisions',
        });
        // Create data model artifact if present
        if (architectDecision.data_models && architectDecision.data_models.length > 0) {
            artifacts.push({
                uri: `artifact://architect/${capsule.id}/data-models.json`,
                type: 'data_models',
                description: 'Data model specifications',
            });
        }
        // Create integration points artifact if present
        if (architectDecision.integration_points && architectDecision.integration_points.length > 0) {
            artifacts.push({
                uri: `artifact://architect/${capsule.id}/integration-points.json`,
                type: 'integration_specs',
                description: 'Component integration specifications',
            });
        }
        return artifacts;
    }
}
//# sourceMappingURL=architect-agent.js.map