/**
 * @mdp-framework/agents - PM Agent
 *
 * Product Manager agent for feature analysis and requirements gathering
 */
import { BaseAgent } from '../base/agent.js';
import { PM_SYSTEM_PROMPT, PM_ANALYSIS_PROMPT } from './prompts/pm-prompts.js';
import pmDecisionSchema from './schemas/pm-decision.schema.json' with { type: 'json' };
/**
 * Product Manager Agent
 *
 * Analyzes feature requests, identifies requirements, assesses scope,
 * and makes initial product decisions.
 */
export class PMAgent extends BaseAgent {
    aiProvider;
    model;
    temperature;
    maxTokens;
    constructor(config) {
        super('pm', 'pm');
        this.aiProvider = config.aiProvider;
        this.model = config.model || 'claude-sonnet-4.5';
        this.temperature = config.temperature ?? 0.1;
        this.maxTokens = config.maxTokens || 4000;
    }
    /**
     * Execute PM analysis
     */
    async executeImpl(capsule) {
        // Extract context from capsule
        const context = this.extractContext(capsule);
        // Build prompt with context
        const analysisPrompt = this.buildAnalysisPrompt(context);
        // Call LLM for analysis
        const completion = await this.aiProvider.complete({
            model: this.model,
            prompt: `${PM_SYSTEM_PROMPT}\n\n${analysisPrompt}`,
            temperature: this.temperature,
            max_tokens: this.maxTokens,
            schema: pmDecisionSchema,
        });
        // Parse structured output
        const pmDecision = JSON.parse(completion.content);
        // Convert to agent decisions
        const decisions = this.convertToDecisions(pmDecision);
        // Create artifacts
        const artifacts = this.createArtifacts(pmDecision, capsule);
        return {
            decisions,
            artifacts,
            can_handoff: true,
            next_agent: 'architect',
        };
    }
    /**
     * Get next agent role (Architect)
     */
    getNextAgentRole() {
        return 'architect';
    }
    /**
     * Extract context from capsule
     */
    extractContext(capsule) {
        const context = {
            feature_description: '',
            team: 'unknown',
            tech_stack: 'unknown',
            repo: 'unknown',
            existing_components: '',
        };
        // Extract feature description from capsule metadata or context
        if (capsule.metadata?.feature_description) {
            context.feature_description = String(capsule.metadata.feature_description);
        }
        else if (capsule.context?.description) {
            context.feature_description = String(capsule.context.description);
        }
        // Extract team info
        if (capsule.context?.team) {
            context.team = String(capsule.context.team);
        }
        // Extract tech stack
        if (capsule.metadata?.tech_stack) {
            context.tech_stack = String(capsule.metadata.tech_stack);
        }
        // Extract repo
        if (capsule.context?.repo) {
            context.repo = String(capsule.context.repo);
        }
        // Extract existing components
        if (capsule.metadata?.existing_components) {
            const components = capsule.metadata.existing_components;
            if (Array.isArray(components)) {
                context.existing_components = components.join(', ');
            }
            else {
                context.existing_components = String(components);
            }
        }
        return context;
    }
    /**
     * Build analysis prompt with context
     */
    buildAnalysisPrompt(context) {
        let prompt = PM_ANALYSIS_PROMPT;
        // Simple template replacement
        for (const [key, value] of Object.entries(context)) {
            const regex = new RegExp(`{{${key}}}`, 'g');
            prompt = prompt.replace(regex, value);
        }
        // Handle conditionals (simple implementation)
        if (context.existing_components) {
            prompt = prompt.replace(/{{#if existing_components}}[\s\S]*?{{\/if}}/g, (match) => {
                return match
                    .replace('{{#if existing_components}}', '')
                    .replace('{{/if}}', '')
                    .replace('{{existing_components}}', context.existing_components);
            });
        }
        else {
            prompt = prompt.replace(/{{#if existing_components}}[\s\S]*?{{\/if}}/g, '');
        }
        return prompt;
    }
    /**
     * Convert PM decision to agent decisions
     */
    convertToDecisions(pmDecision) {
        const decisions = [];
        // Add scope decision
        decisions.push({
            question: 'What is the scope of this feature?',
            answer: `${pmDecision.scope} - ${pmDecision.scope_rationale}`,
            reasoning: pmDecision.scope_rationale,
            confidence: 0.9,
        });
        // Add requirement decisions
        pmDecision.requirements.forEach((req) => {
            decisions.push({
                question: `Requirement: ${req.id}`,
                answer: `[${req.priority}] ${req.description}`,
                reasoning: req.rationale || 'Requirement identified from feature analysis',
                confidence: 0.8,
            });
        });
        // Add PM decisions
        pmDecision.decisions.forEach((decision) => {
            decisions.push({
                question: decision.question,
                answer: decision.answer,
                reasoning: decision.reasoning,
                confidence: decision.confidence || 0.8,
            });
        });
        return decisions;
    }
    /**
     * Create artifacts from PM decision
     */
    createArtifacts(pmDecision, capsule) {
        const artifacts = [];
        // Create requirements document artifact
        artifacts.push({
            uri: `artifact://pm/${capsule.id}/requirements.json`,
            type: 'requirements',
            description: 'Feature requirements and scope analysis',
        });
        // Create risks artifact if present
        if (pmDecision.risks && pmDecision.risks.length > 0) {
            artifacts.push({
                uri: `artifact://pm/${capsule.id}/risks.json`,
                type: 'risk_assessment',
                description: 'Identified risks and mitigation strategies',
            });
        }
        // Create acceptance criteria artifact if present
        if (pmDecision.acceptance_criteria && pmDecision.acceptance_criteria.length > 0) {
            artifacts.push({
                uri: `artifact://pm/${capsule.id}/acceptance-criteria.json`,
                type: 'acceptance_criteria',
                description: 'Feature acceptance criteria',
            });
        }
        return artifacts;
    }
}
//# sourceMappingURL=pm-agent.js.map