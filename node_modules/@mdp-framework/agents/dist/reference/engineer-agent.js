/**
 * @mdp-framework/agents - Engineer Agent
 *
 * Engineer agent for implementation planning and technical execution
 */
import { BaseAgent } from '../base/agent.js';
import { ENGINEER_SYSTEM_PROMPT, ENGINEER_ANALYSIS_PROMPT, } from './prompts/engineer-prompts.js';
import engineerDecisionSchema from './schemas/engineer-decision.schema.json' with { type: 'json' };
/**
 * Engineer Agent
 *
 * Reviews architecture design, assesses implementation complexity,
 * plans tasks, and makes implementation-level decisions.
 */
export class EngineerAgent extends BaseAgent {
    aiProvider;
    mcpClient;
    model;
    temperature;
    maxTokens;
    constructor(config) {
        super('engineer', 'engineer');
        this.aiProvider = config.aiProvider;
        this.mcpClient = config.mcpClient;
        this.model = config.model || 'claude-sonnet-4.5';
        this.temperature = config.temperature ?? 0.1;
        this.maxTokens = config.maxTokens || 6000;
    }
    /**
     * Execute implementation planning
     */
    async executeImpl(capsule) {
        // Extract context from capsule and previous decisions
        const context = await this.extractContext(capsule);
        // Build prompt with context
        const analysisPrompt = this.buildAnalysisPrompt(context);
        // Call LLM for implementation planning
        const completion = await this.aiProvider.complete({
            model: this.model,
            prompt: `${ENGINEER_SYSTEM_PROMPT}\n\n${analysisPrompt}`,
            temperature: this.temperature,
            max_tokens: this.maxTokens,
            schema: engineerDecisionSchema,
        });
        // Parse structured output
        const engineerDecision = JSON.parse(completion.content);
        // Convert to agent decisions
        const decisions = this.convertToDecisions(engineerDecision);
        // Create artifacts
        const artifacts = this.createArtifacts(engineerDecision, capsule);
        return {
            decisions,
            artifacts,
            can_handoff: true,
            next_agent: 'designer', // Can optionally hand off to designer
        };
    }
    /**
     * Get next agent role (Designer, optional)
     */
    getNextAgentRole() {
        return 'designer';
    }
    /**
     * Extract context from capsule and previous agent decisions
     */
    async extractContext(capsule) {
        const context = {
            architect_summary: '',
            architecture_components: '',
            architecture_decisions: '',
            pm_requirements: '',
            repo: 'unknown',
            tech_stack: 'unknown',
            code_style: 'standard',
            test_framework: '',
        };
        // Extract architect and PM context from previous decisions
        if (capsule.decisions && capsule.decisions.length > 0) {
            const allDecisions = capsule.decisions.filter((d) => d.source === 'agent' || !d.source);
            // Separate architect and PM decisions
            const architectDecisions = allDecisions.filter((d) => String(d.question).toLowerCase().includes('component'));
            const pmDecisions = allDecisions.filter((d) => String(d.question).toLowerCase().includes('requirement'));
            // Create architect summary
            if (architectDecisions.length > 0) {
                context.architect_summary = `Architect defined ${architectDecisions.length} components and made key architectural decisions.`;
                // Extract components
                const components = architectDecisions
                    .filter((d) => String(d.question).startsWith('Component:'))
                    .map((d) => `- ${d.answer}`)
                    .join('\n');
                context.architecture_components = components || 'No specific components defined';
                // Extract decisions
                const decisions = architectDecisions
                    .filter((d) => !String(d.question).startsWith('Component:'))
                    .map((d) => `Q: ${d.question}\nA: ${d.answer}`)
                    .join('\n\n');
                context.architecture_decisions = decisions || 'No specific decisions captured';
            }
            // Extract PM requirements
            if (pmDecisions.length > 0) {
                const requirements = pmDecisions
                    .map((d) => `- ${d.answer}`)
                    .join('\n');
                context.pm_requirements = requirements;
            }
        }
        // Extract repo
        if (capsule.context?.repo) {
            context.repo = String(capsule.context.repo);
        }
        // Extract tech stack
        if (capsule.metadata?.tech_stack) {
            context.tech_stack = String(capsule.metadata.tech_stack);
        }
        // Extract code style
        if (capsule.metadata?.code_style) {
            context.code_style = String(capsule.metadata.code_style);
        }
        // Extract test framework
        if (capsule.metadata?.test_framework) {
            context.test_framework = String(capsule.metadata.test_framework);
        }
        return context;
    }
    /**
     * Build analysis prompt with context
     */
    buildAnalysisPrompt(context) {
        let prompt = ENGINEER_ANALYSIS_PROMPT;
        // Simple template replacement
        for (const [key, value] of Object.entries(context)) {
            const regex = new RegExp(`{{${key}}}`, 'g');
            prompt = prompt.replace(regex, value);
        }
        // Handle conditionals
        if (context.test_framework) {
            prompt = prompt.replace(/{{#if test_framework}}[\s\S]*?{{\/if}}/g, (match) => {
                return match
                    .replace('{{#if test_framework}}', '')
                    .replace('{{/if}}', '')
                    .replace('{{test_framework}}', context.test_framework);
            });
        }
        else {
            prompt = prompt.replace(/{{#if test_framework}}[\s\S]*?{{\/if}}/g, '');
        }
        return prompt;
    }
    /**
     * Convert engineer decision to agent decisions
     */
    convertToDecisions(engineerDecision) {
        const decisions = [];
        // Add feasibility assessment
        decisions.push({
            question: 'What is the implementation feasibility?',
            answer: `${engineerDecision.implementation_assessment.feasibility} - Effort: ${engineerDecision.implementation_assessment.effort_estimate}`,
            reasoning: engineerDecision.implementation_assessment.recommendations ||
                'Based on architecture review and complexity analysis',
            confidence: 0.85,
        });
        // Add task breakdown summary
        if (engineerDecision.tasks.length > 0) {
            decisions.push({
                question: 'How should implementation be broken down?',
                answer: `${engineerDecision.tasks.length} tasks identified: ${engineerDecision.tasks.map((t) => t.title).join(', ')}`,
                reasoning: 'Task breakdown based on component analysis',
                confidence: 0.8,
            });
        }
        // Add implementation decisions
        engineerDecision.implementation_decisions.forEach((decision) => {
            decisions.push({
                question: decision.question,
                answer: decision.answer,
                reasoning: decision.reasoning,
                confidence: decision.confidence || 0.8,
            });
        });
        return decisions;
    }
    /**
     * Create artifacts from engineer decision
     */
    createArtifacts(engineerDecision, capsule) {
        const artifacts = [];
        // Create implementation plan artifact
        artifacts.push({
            uri: `artifact://engineer/${capsule.id}/implementation-plan.json`,
            type: 'implementation_plan',
            description: 'Implementation task breakdown and planning',
        });
        // Create code structure artifact if present
        if (engineerDecision.code_structure && engineerDecision.code_structure.length > 0) {
            artifacts.push({
                uri: `artifact://engineer/${capsule.id}/code-structure.json`,
                type: 'code_structure',
                description: 'Planned code file structure',
            });
        }
        // Create testing strategy artifact if present
        if (engineerDecision.testing_strategy) {
            artifacts.push({
                uri: `artifact://engineer/${capsule.id}/testing-strategy.json`,
                type: 'testing_strategy',
                description: 'Testing approach and test cases',
            });
        }
        return artifacts;
    }
}
//# sourceMappingURL=engineer-agent.js.map