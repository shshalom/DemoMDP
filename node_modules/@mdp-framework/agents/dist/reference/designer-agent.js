/**
 * @mdp-framework/agents - Designer Agent
 *
 * Designer agent for UI/UX design and user experience decisions
 */
import { BaseAgent } from '../base/agent.js';
import { DESIGNER_SYSTEM_PROMPT, DESIGNER_ANALYSIS_PROMPT, } from './prompts/designer-prompts.js';
import designerDecisionSchema from './schemas/designer-decision.schema.json' with { type: 'json' };
/**
 * Designer Agent
 *
 * Reviews requirements, applies design system policies,
 * designs user interfaces, and makes UX decisions.
 */
export class DesignerAgent extends BaseAgent {
    aiProvider;
    mcpClient;
    model;
    temperature;
    maxTokens;
    constructor(config) {
        super('designer', 'designer');
        this.aiProvider = config.aiProvider;
        this.mcpClient = config.mcpClient;
        this.model = config.model || 'claude-sonnet-4.5';
        this.temperature = config.temperature ?? 0.1;
        this.maxTokens = config.maxTokens || 6000;
    }
    /**
     * Execute UI/UX design
     */
    async executeImpl(capsule) {
        // Extract context from capsule and previous decisions
        const context = await this.extractContext(capsule);
        // Query design system policies (if MCP client available)
        const designPolicies = await this.queryDesignPolicies(capsule);
        context.design_policies = designPolicies;
        // Build prompt with context
        const analysisPrompt = this.buildAnalysisPrompt(context);
        // Call LLM for design work
        const completion = await this.aiProvider.complete({
            model: this.model,
            prompt: `${DESIGNER_SYSTEM_PROMPT}\n\n${analysisPrompt}`,
            temperature: this.temperature,
            max_tokens: this.maxTokens,
            schema: designerDecisionSchema,
        });
        // Parse structured output
        const designerDecision = JSON.parse(completion.content);
        // Convert to agent decisions
        const decisions = this.convertToDecisions(designerDecision);
        // Create artifacts
        const artifacts = this.createArtifacts(designerDecision, capsule);
        return {
            decisions,
            artifacts,
            can_handoff: false, // Designer is typically the last agent
            next_agent: undefined,
        };
    }
    /**
     * Get next agent role (none - designer is typically last)
     */
    getNextAgentRole() {
        return null;
    }
    /**
     * Extract context from capsule and previous agent decisions
     */
    async extractContext(capsule) {
        const context = {
            pm_summary: '',
            pm_requirements: '',
            architect_summary: '',
            product_type: 'web application',
            target_users: 'general users',
            platform: 'web',
            existing_designs: '',
            design_policies: '',
        };
        // Extract PM and Architect context from previous decisions
        if (capsule.decisions && capsule.decisions.length > 0) {
            const allDecisions = capsule.decisions.filter((d) => d.source === 'agent' || !d.source);
            // Extract PM context
            const pmDecisions = allDecisions.filter((d) => String(d.question).toLowerCase().includes('requirement'));
            if (pmDecisions.length > 0) {
                context.pm_summary = `PM identified ${pmDecisions.length} requirements and assessed project scope.`;
                const requirements = pmDecisions
                    .map((d) => `- ${d.answer}`)
                    .join('\n');
                context.pm_requirements = requirements;
            }
            // Extract Architect context
            const architectDecisions = allDecisions.filter((d) => String(d.question).toLowerCase().includes('component'));
            if (architectDecisions.length > 0) {
                context.architect_summary = `Architect designed ${architectDecisions.length} components with clear interfaces.`;
            }
        }
        // Extract product context
        if (capsule.metadata?.product_type) {
            context.product_type = String(capsule.metadata.product_type);
        }
        if (capsule.metadata?.target_users) {
            context.target_users = String(capsule.metadata.target_users);
        }
        if (capsule.metadata?.platform) {
            context.platform = String(capsule.metadata.platform);
        }
        if (capsule.metadata?.existing_designs) {
            context.existing_designs = String(capsule.metadata.existing_designs);
        }
        return context;
    }
    /**
     * Query design system policies via MCP
     * TODO: Integrate with Stream 3 MCP Server
     */
    async queryDesignPolicies(capsule) {
        if (!this.mcpClient) {
            return 'No design system policies available (MCP client not configured)';
        }
        try {
            // TODO: Query MCP for design system policies
            // const policies = await this.mcpClient.call('policy.search', {
            //   tags: ['design-system', 'ui', 'ux'],
            //   scope: 'org'
            // });
            // return JSON.stringify(policies, null, 2);
            return 'MCP design policy integration pending (Stream 3)';
        }
        catch (error) {
            return `Design policy query failed: ${error instanceof Error ? error.message : 'Unknown error'}`;
        }
    }
    /**
     * Build analysis prompt with context
     */
    buildAnalysisPrompt(context) {
        let prompt = DESIGNER_ANALYSIS_PROMPT;
        // Simple template replacement
        for (const [key, value] of Object.entries(context)) {
            const regex = new RegExp(`{{${key}}}`, 'g');
            prompt = prompt.replace(regex, value);
        }
        // Handle conditionals
        if (context.architect_summary && context.architect_summary.trim()) {
            prompt = prompt.replace(/{{#if architect_summary}}[\s\S]*?{{\/if}}/g, (match) => {
                return match
                    .replace('{{#if architect_summary}}', '')
                    .replace('{{/if}}', '')
                    .replace('{{architect_summary}}', context.architect_summary);
            });
        }
        else {
            prompt = prompt.replace(/{{#if architect_summary}}[\s\S]*?{{\/if}}/g, '');
        }
        if (context.design_policies && !context.design_policies.includes('not configured')) {
            prompt = prompt.replace(/{{#if design_policies}}[\s\S]*?{{else}}[\s\S]*?{{\/if}}/g, (match) => {
                return match
                    .split('{{else}}')[0]
                    .replace('{{#if design_policies}}', '')
                    .replace('{{design_policies}}', context.design_policies);
            });
        }
        else {
            prompt = prompt.replace(/{{#if design_policies}}[\s\S]*?{{else}}([\s\S]*?){{\/if}}/g, '$1');
        }
        if (context.existing_designs) {
            prompt = prompt.replace(/{{#if existing_designs}}[\s\S]*?{{\/if}}/g, (match) => {
                return match
                    .replace('{{#if existing_designs}}', '')
                    .replace('{{/if}}', '')
                    .replace('{{existing_designs}}', context.existing_designs);
            });
        }
        else {
            prompt = prompt.replace(/{{#if existing_designs}}[\s\S]*?{{\/if}}/g, '');
        }
        return prompt;
    }
    /**
     * Convert designer decision to agent decisions
     */
    convertToDecisions(designerDecision) {
        const decisions = [];
        // Add accessibility decision
        if (designerDecision.accessibility) {
            decisions.push({
                question: 'What accessibility level should be targeted?',
                answer: `WCAG ${designerDecision.accessibility.wcag_level} compliance with full keyboard navigation and screen reader support`,
                reasoning: 'Ensuring inclusive design for all users',
                confidence: 0.9,
            });
        }
        // Add user flow decisions
        if (designerDecision.user_flows && designerDecision.user_flows.length > 0) {
            decisions.push({
                question: 'What are the primary user flows?',
                answer: `${designerDecision.user_flows.length} user flows defined: ${designerDecision.user_flows.map((f) => f.name).join(', ')}`,
                reasoning: 'User flow mapping based on feature requirements',
                confidence: 0.85,
            });
        }
        // Add component decisions
        designerDecision.components.forEach((component) => {
            decisions.push({
                question: `UI Component: ${component.name}`,
                answer: `[${component.type}] ${component.purpose}`,
                reasoning: component.accessibility_notes || 'Component selected for user experience',
                confidence: 0.8,
            });
        });
        // Add design decisions
        designerDecision.design_decisions.forEach((decision) => {
            decisions.push({
                question: decision.question,
                answer: decision.answer,
                reasoning: decision.reasoning,
                confidence: decision.confidence || 0.8,
            });
        });
        return decisions;
    }
    /**
     * Create artifacts from designer decision
     */
    createArtifacts(designerDecision, capsule) {
        const artifacts = [];
        // Create design specification artifact
        artifacts.push({
            uri: `artifact://designer/${capsule.id}/design-spec.json`,
            type: 'design_specification',
            description: 'UI/UX design specifications and component definitions',
        });
        // Create user flow artifact
        if (designerDecision.user_flows && designerDecision.user_flows.length > 0) {
            artifacts.push({
                uri: `artifact://designer/${capsule.id}/user-flows.json`,
                type: 'user_flows',
                description: 'User journey and interaction flows',
            });
        }
        // Create accessibility artifact
        if (designerDecision.accessibility) {
            artifacts.push({
                uri: `artifact://designer/${capsule.id}/accessibility.json`,
                type: 'accessibility_specs',
                description: 'Accessibility requirements and guidelines',
            });
        }
        // Create design artifacts from decision
        if (designerDecision.design_artifacts && designerDecision.design_artifacts.length > 0) {
            designerDecision.design_artifacts.forEach((artifact) => {
                artifacts.push({
                    uri: artifact.location || `artifact://designer/${capsule.id}/${artifact.type}-${artifact.name}`,
                    type: artifact.type,
                    description: artifact.description,
                });
            });
        }
        return artifacts;
    }
}
//# sourceMappingURL=designer-agent.js.map