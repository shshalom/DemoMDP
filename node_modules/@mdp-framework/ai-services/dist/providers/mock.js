/**
 * Mock Provider Implementation
 *
 * Implements AIProvider interface for deterministic testing.
 * Provides configurable responses for golden tests and CI.
 */
import { AIProviderError } from '../contracts/index.js';
export class MockProvider {
    name = 'mock';
    models = ['mock-model-v1', 'mock-model-v2'];
    responses;
    defaultResponse;
    latency;
    strict;
    healthy;
    embeddings;
    embeddingDimension;
    callCount = 0;
    callHistory = [];
    constructor(options = {}) {
        this.responses = new Map(Object.entries(options.responses || {}));
        this.defaultResponse = options.defaultResponse || {
            content: 'Mock response',
            stop_reason: 'complete',
            usage: {
                input_tokens: 10,
                output_tokens: 10,
                total_tokens: 20,
                cost_usd: 0.0,
            },
            model: 'mock-model-v1',
            latency_ms: 0,
        };
        this.latency = options.latency || 0;
        this.strict = options.strict || false;
        this.healthy = options.healthy !== false;
        this.embeddings = new Map(Object.entries(options.embeddings || {}));
        this.embeddingDimension = options.embeddingDimension || 1536;
    }
    async complete(request) {
        this.callCount++;
        this.callHistory.push(request);
        // Simulate latency
        if (this.latency > 0) {
            await new Promise((resolve) => setTimeout(resolve, this.latency));
        }
        const startTime = Date.now();
        // Find matching response
        const response = this.responses.get(request.prompt);
        if (!response) {
            if (this.strict) {
                throw new AIProviderError(`No mock response configured for prompt: "${request.prompt}"`, 'MOCK_NOT_FOUND', this.name, false);
            }
            // Use default response
            return this.buildResponse(this.defaultResponse, request, startTime);
        }
        return this.buildResponse(response, request, startTime);
    }
    async embed(texts) {
        // Simulate latency
        if (this.latency > 0) {
            await new Promise((resolve) => setTimeout(resolve, this.latency));
        }
        return texts.map((text) => {
            // Use custom embedding if configured
            const customVector = this.embeddings.get(text);
            const vector = customVector || this.generateDeterministicVector(text);
            return {
                text,
                vector,
                model: 'mock-embedding-model',
                tokens: Math.ceil(text.length / 4),
            };
        });
    }
    estimateTokens(prompt) {
        // Simple estimation: ~4 characters per token
        const tokens = Math.ceil(prompt.length / 4);
        return {
            tokens,
            cost_usd: 0.0, // Mock provider is free
            model: 'mock-model-v1',
        };
    }
    async healthCheck() {
        // Simulate latency
        if (this.latency > 0) {
            await new Promise((resolve) => setTimeout(resolve, this.latency));
        }
        const startTime = Date.now();
        if (!this.healthy) {
            return {
                healthy: false,
                provider: this.name,
                latency_ms: Date.now() - startTime,
                error: {
                    code: 'MOCK_UNHEALTHY',
                    message: 'Mock provider configured as unhealthy',
                },
            };
        }
        return {
            healthy: true,
            provider: this.name,
            latency_ms: Date.now() - startTime,
        };
    }
    /**
     * Add a response for a specific prompt
     */
    addResponse(prompt, response) {
        this.responses.set(prompt, response);
    }
    /**
     * Clear all configured responses
     */
    clearResponses() {
        this.responses.clear();
    }
    /**
     * Get call count for testing
     */
    getCallCount() {
        return this.callCount;
    }
    /**
     * Get call history for testing
     */
    getCallHistory() {
        return [...this.callHistory];
    }
    /**
     * Reset call tracking
     */
    resetCallTracking() {
        this.callCount = 0;
        this.callHistory = [];
    }
    /**
     * Set health status
     */
    setHealthy(healthy) {
        this.healthy = healthy;
    }
    buildResponse(partial, request, startTime) {
        return {
            content: partial.content || 'Mock response',
            structured: partial.structured,
            stop_reason: partial.stop_reason || 'complete',
            usage: {
                input_tokens: partial.usage?.input_tokens || 10,
                output_tokens: partial.usage?.output_tokens || 10,
                total_tokens: partial.usage?.total_tokens || 20,
                cost_usd: partial.usage?.cost_usd || 0.0,
            },
            model: request.model || partial.model || 'mock-model-v1',
            latency_ms: partial.latency_ms !== undefined ? partial.latency_ms : Date.now() - startTime,
        };
    }
    generateDeterministicVector(text) {
        // Generate deterministic vector based on text content
        const vector = [];
        let seed = 0;
        // Simple hash-based seeding
        for (let i = 0; i < text.length; i++) {
            seed = (seed * 31 + text.charCodeAt(i)) % 1000000;
        }
        // Generate vector with deterministic pseudo-random values
        for (let i = 0; i < this.embeddingDimension; i++) {
            // Linear congruential generator for deterministic randomness
            seed = (seed * 1103515245 + 12345) % 2147483648;
            vector.push((seed / 2147483648) * 2 - 1); // Normalize to [-1, 1]
        }
        return vector;
    }
}
//# sourceMappingURL=mock.js.map