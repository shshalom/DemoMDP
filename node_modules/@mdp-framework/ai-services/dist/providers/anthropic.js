/**
 * Anthropic Provider Implementation
 *
 * Implements AIProvider interface for Anthropic Claude models.
 * Primary provider for MDP Framework.
 */
import Anthropic from '@anthropic-ai/sdk';
import { AIProviderError } from '../contracts/index.js';
/**
 * Anthropic pricing (as of Jan 2025)
 * Claude Sonnet 4.5: $3.00/M input, $15.00/M output
 * Claude Haiku 4.5: $0.80/M input, $4.00/M output
 * Claude Opus 4.1: $15.00/M input, $75.00/M output
 */
const PRICING = {
    'claude-sonnet-4-5-20250929': { input: 3.0 / 1_000_000, output: 15.0 / 1_000_000 },
    'claude-sonnet-4-5': { input: 3.0 / 1_000_000, output: 15.0 / 1_000_000 },
    'claude-haiku-4-5-20251001': { input: 0.8 / 1_000_000, output: 4.0 / 1_000_000 },
    'claude-haiku-4-5': { input: 0.8 / 1_000_000, output: 4.0 / 1_000_000 },
    'claude-opus-4-1-20250805': { input: 15.0 / 1_000_000, output: 75.0 / 1_000_000 },
    'claude-opus-4-1': { input: 15.0 / 1_000_000, output: 75.0 / 1_000_000 },
};
export class AnthropicProvider {
    name = 'anthropic';
    models = [
        'claude-sonnet-4-5-20250929',
        'claude-sonnet-4-5',
        'claude-haiku-4-5-20251001',
        'claude-haiku-4-5',
        'claude-opus-4-1-20250805',
        'claude-opus-4-1',
    ];
    client;
    defaultModel;
    constructor(options) {
        this.client = new Anthropic({
            apiKey: options.apiKey,
            baseURL: options.baseURL,
        });
        this.defaultModel = options.defaultModel || 'claude-sonnet-4-5-20250929';
    }
    async complete(request) {
        const startTime = Date.now();
        const model = request.model || this.defaultModel;
        try {
            // Build messages
            const messages = [
                {
                    role: 'user',
                    content: request.prompt,
                },
            ];
            // Prepare API request
            const params = {
                model,
                messages,
                max_tokens: request.max_tokens || 4096,
                temperature: request.temperature ?? 1.0,
                stop_sequences: request.stop_sequences,
            };
            // Handle structured output (JSON mode)
            let response;
            let structured;
            if (request.schema) {
                // Use tool call for structured output
                response = await this.client.messages.create({
                    ...params,
                    tools: [
                        {
                            name: 'structured_output',
                            description: 'Output structured data matching the provided schema',
                            input_schema: {
                                type: 'object',
                                ...request.schema,
                            },
                        },
                    ],
                    tool_choice: { type: 'tool', name: 'structured_output' },
                });
                // Extract structured output from tool use
                const toolUse = response.content.find((c) => c.type === 'tool_use');
                if (toolUse && toolUse.type === 'tool_use') {
                    structured = toolUse.input;
                }
            }
            else {
                // Standard text completion
                response = await this.client.messages.create(params);
            }
            // Extract content
            const textContent = response.content
                .filter((c) => c.type === 'text')
                .map((c) => (c.type === 'text' ? c.text : ''))
                .join('\n');
            // Calculate cost
            const pricing = PRICING[model] || PRICING['claude-sonnet-4-5-20250929'];
            const cost_usd = response.usage.input_tokens * pricing.input +
                response.usage.output_tokens * pricing.output;
            return {
                content: textContent,
                structured,
                stop_reason: this.mapStopReason(response.stop_reason),
                usage: {
                    input_tokens: response.usage.input_tokens,
                    output_tokens: response.usage.output_tokens,
                    total_tokens: response.usage.input_tokens + response.usage.output_tokens,
                    cost_usd,
                },
                model: response.model,
                latency_ms: Date.now() - startTime,
            };
        }
        catch (error) {
            if (this.isAPIError(error)) {
                throw this.createProviderError(error);
            }
            throw error;
        }
    }
    async embed(texts) {
        // Anthropic doesn't have a native embeddings API
        // For now, we'll throw an error with a clear message
        // In Stream 1 Part 3, we'll implement embeddings via Voyage AI or similar
        throw new Error('Anthropic provider does not support embeddings. Use a dedicated embeddings provider or implement via Voyage AI in Part 3.');
    }
    estimateTokens(prompt) {
        // Rough estimation: ~4 characters per token (Claude's tokenizer)
        // This is a simple heuristic; actual tokenization may vary
        const estimatedTokens = Math.ceil(prompt.length / 4);
        const model = this.defaultModel;
        const pricing = PRICING[model] || PRICING['claude-sonnet-4-5-20250929'];
        return {
            tokens: estimatedTokens,
            cost_usd: estimatedTokens * pricing.input,
            model,
        };
    }
    async healthCheck() {
        const startTime = Date.now();
        try {
            // Simple health check: call with minimal prompt
            await this.client.messages.create({
                model: this.defaultModel,
                messages: [{ role: 'user', content: 'ping' }],
                max_tokens: 10,
            });
            return {
                healthy: true,
                provider: this.name,
                latency_ms: Date.now() - startTime,
            };
        }
        catch (error) {
            return {
                healthy: false,
                provider: this.name,
                latency_ms: Date.now() - startTime,
                error: {
                    code: this.isAPIError(error) ? error.status?.toString() || 'UNKNOWN' : 'UNKNOWN',
                    message: error instanceof Error ? error.message : 'Unknown error',
                },
            };
        }
    }
    mapStopReason(reason) {
        switch (reason) {
            case 'end_turn':
                return 'complete';
            case 'max_tokens':
                return 'length';
            case 'stop_sequence':
                return 'stop_sequence';
            default:
                return 'error';
        }
    }
    isAPIError(error) {
        // Check if error is an APIError by checking its properties and constructor name
        // This handles both real API errors and mocked ones
        if (!error || typeof error !== 'object') {
            return false;
        }
        try {
            // Check if it's an instance of Anthropic.APIError (when SDK is available)
            if (error instanceof Anthropic.APIError) {
                return true;
            }
        }
        catch (e) {
            // instanceof check may fail in test/mock environments
        }
        // Fallback: check if it has the structure of an API error
        return (error instanceof Error &&
            (error.constructor.name === 'APIError' || error.name === 'APIError') &&
            'status' in error);
    }
    createProviderError(error) {
        const code = error.status?.toString() || 'UNKNOWN';
        const recoverable = error.status === 429 || error.status === 503;
        return new AIProviderError(error.message, code, this.name, recoverable);
    }
}
//# sourceMappingURL=anthropic.js.map