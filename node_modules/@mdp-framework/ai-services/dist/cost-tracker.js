/**
 * Cost Tracking Utilities
 *
 * Track and aggregate AI API costs across providers.
 * Enables budget enforcement and cost optimization.
 */
export class CostTracker {
    entries = [];
    budget;
    alertCallbacks = [];
    constructor(budget = {}) {
        this.budget = {
            alert_threshold_pct: 80,
            ...budget,
        };
    }
    /**
     * Record a cost entry
     */
    recordCost(entry) {
        const fullEntry = {
            ...entry,
            timestamp: new Date(),
        };
        this.entries.push(fullEntry);
        // Check budgets
        this.checkBudgets(fullEntry);
    }
    /**
     * Get cost summary for a time period
     */
    getSummary(options = {}) {
        const filtered = this.filterEntries(options);
        const summary = {
            total_cost_usd: 0,
            total_tokens: 0,
            total_calls: 0,
            by_provider: {},
            by_model: {},
        };
        for (const entry of filtered) {
            summary.total_cost_usd += entry.cost_usd;
            summary.total_tokens += entry.total_tokens;
            summary.total_calls++;
            // By provider
            if (!summary.by_provider[entry.provider]) {
                summary.by_provider[entry.provider] = {
                    cost_usd: 0,
                    tokens: 0,
                    calls: 0,
                };
            }
            summary.by_provider[entry.provider].cost_usd += entry.cost_usd;
            summary.by_provider[entry.provider].tokens += entry.total_tokens;
            summary.by_provider[entry.provider].calls++;
            // By model
            if (!summary.by_model[entry.model]) {
                summary.by_model[entry.model] = {
                    cost_usd: 0,
                    tokens: 0,
                    calls: 0,
                };
            }
            summary.by_model[entry.model].cost_usd += entry.cost_usd;
            summary.by_model[entry.model].tokens += entry.total_tokens;
            summary.by_model[entry.model].calls++;
        }
        return summary;
    }
    /**
     * Get today's costs
     */
    getTodayCost() {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const summary = this.getSummary({ startDate: today });
        return summary.total_cost_usd;
    }
    /**
     * Get this month's costs
     */
    getMonthCost() {
        const startOfMonth = new Date();
        startOfMonth.setDate(1);
        startOfMonth.setHours(0, 0, 0, 0);
        const summary = this.getSummary({ startDate: startOfMonth });
        return summary.total_cost_usd;
    }
    /**
     * Check if a call would exceed budget
     */
    wouldExceedBudget(estimatedCost) {
        // Check per-call budget
        if (this.budget.max_cost_per_call !== undefined) {
            if (estimatedCost > this.budget.max_cost_per_call) {
                return {
                    exceeded: true,
                    reason: 'per_call',
                    currentCost: estimatedCost,
                    limit: this.budget.max_cost_per_call,
                };
            }
        }
        // Check daily budget
        if (this.budget.max_cost_per_day !== undefined) {
            const todayCost = this.getTodayCost();
            if (todayCost + estimatedCost > this.budget.max_cost_per_day) {
                return {
                    exceeded: true,
                    reason: 'daily',
                    currentCost: todayCost,
                    limit: this.budget.max_cost_per_day,
                };
            }
        }
        // Check monthly budget
        if (this.budget.max_cost_per_month !== undefined) {
            const monthCost = this.getMonthCost();
            if (monthCost + estimatedCost > this.budget.max_cost_per_month) {
                return {
                    exceeded: true,
                    reason: 'monthly',
                    currentCost: monthCost,
                    limit: this.budget.max_cost_per_month,
                };
            }
        }
        return { exceeded: false };
    }
    /**
     * Register alert callback
     */
    onAlert(callback) {
        this.alertCallbacks.push(callback);
    }
    /**
     * Get all cost entries
     */
    getEntries(options = {}) {
        return this.filterEntries(options);
    }
    /**
     * Clear all entries (useful for testing)
     */
    clear() {
        this.entries = [];
    }
    /**
     * Export entries as CSV
     */
    exportCSV() {
        const headers = [
            'timestamp',
            'provider',
            'model',
            'input_tokens',
            'output_tokens',
            'total_tokens',
            'cost_usd',
        ];
        const rows = this.entries.map((entry) => [
            entry.timestamp.toISOString(),
            entry.provider,
            entry.model,
            entry.input_tokens,
            entry.output_tokens,
            entry.total_tokens,
            entry.cost_usd,
        ]);
        return [headers.join(','), ...rows.map((row) => row.join(','))].join('\n');
    }
    /**
     * Filter entries by criteria
     */
    filterEntries(options) {
        return this.entries.filter((entry) => {
            if (options.startDate && entry.timestamp < options.startDate) {
                return false;
            }
            if (options.endDate && entry.timestamp > options.endDate) {
                return false;
            }
            if (options.provider && entry.provider !== options.provider) {
                return false;
            }
            if (options.model && entry.model !== options.model) {
                return false;
            }
            return true;
        });
    }
    /**
     * Check budgets and trigger alerts
     */
    checkBudgets(entry) {
        // Check daily budget alert
        if (this.budget.max_cost_per_day && this.budget.alert_threshold_pct) {
            const todayCost = this.getTodayCost();
            const threshold = (this.budget.max_cost_per_day * this.budget.alert_threshold_pct) / 100;
            if (todayCost >= threshold) {
                const summary = this.getSummary({
                    startDate: new Date(new Date().setHours(0, 0, 0, 0)),
                });
                this.triggerAlerts(summary);
            }
        }
        // Check monthly budget alert
        if (this.budget.max_cost_per_month && this.budget.alert_threshold_pct) {
            const monthCost = this.getMonthCost();
            const threshold = (this.budget.max_cost_per_month * this.budget.alert_threshold_pct) / 100;
            if (monthCost >= threshold) {
                const startOfMonth = new Date();
                startOfMonth.setDate(1);
                startOfMonth.setHours(0, 0, 0, 0);
                const summary = this.getSummary({ startDate: startOfMonth });
                this.triggerAlerts(summary);
            }
        }
    }
    /**
     * Trigger alert callbacks
     */
    triggerAlerts(summary) {
        for (const callback of this.alertCallbacks) {
            try {
                callback(summary);
            }
            catch (error) {
                console.error('Cost tracker alert callback error:', error);
            }
        }
    }
}
/**
 * Global cost tracker instance
 */
let globalTracker = null;
/**
 * Get or create global cost tracker
 */
export function getGlobalCostTracker(budget) {
    if (!globalTracker) {
        globalTracker = new CostTracker(budget);
    }
    return globalTracker;
}
/**
 * Reset global cost tracker (useful for testing)
 */
export function resetGlobalCostTracker() {
    globalTracker = null;
}
//# sourceMappingURL=cost-tracker.js.map