/**
 * Prompt Template Engine
 *
 * Implements PromptTemplate interface with Jinja2-like templating.
 * Supports variable substitution, type validation, and required field checking.
 */
export class PromptTemplate {
    name;
    template;
    variables;
    constructor(options) {
        this.name = options.name;
        this.template = options.template;
        this.variables = options.variables;
        this.validateTemplate();
    }
    /**
     * Render template with provided values
     */
    render(values) {
        // Validate required variables
        this.validateValues(values);
        // Merge with defaults
        const finalValues = this.mergeWithDefaults(values);
        // Replace variables in template
        return this.replaceVariables(this.template, finalValues);
    }
    /**
     * Get list of required variables
     */
    getRequiredVariables() {
        return Object.values(this.variables)
            .filter((v) => v.required)
            .map((v) => v.name);
    }
    /**
     * Get list of all variables
     */
    getAllVariables() {
        return Object.keys(this.variables);
    }
    /**
     * Check if a variable is required
     */
    isVariableRequired(name) {
        return this.variables[name]?.required || false;
    }
    /**
     * Validate template syntax
     */
    validateTemplate() {
        const varPattern = /\{\{([^}]+)\}\}/g;
        const matches = Array.from(this.template.matchAll(varPattern));
        for (const match of matches) {
            const varName = match[1].trim();
            if (!this.variables[varName]) {
                throw new Error(`Template variable "{{${varName}}}" not defined in variables schema`);
            }
        }
    }
    /**
     * Validate provided values
     */
    validateValues(values) {
        // Check required variables
        for (const [name, variable] of Object.entries(this.variables)) {
            if (variable.required && !(name in values)) {
                throw new Error(`Required variable "${name}" not provided for template "${this.name}"`);
            }
        }
        // Type check provided values
        for (const [name, value] of Object.entries(values)) {
            const variable = this.variables[name];
            if (!variable) {
                // Warn but don't error on extra variables
                continue;
            }
            if (!this.isValueOfType(value, variable.type)) {
                throw new TypeError(`Variable "${name}" expected type "${variable.type}" but got "${typeof value}"`);
            }
        }
    }
    /**
     * Merge values with defaults
     */
    mergeWithDefaults(values) {
        const result = { ...values };
        for (const [name, variable] of Object.entries(this.variables)) {
            if (!(name in result) && variable.default !== undefined) {
                result[name] = variable.default;
            }
        }
        return result;
    }
    /**
     * Replace variables in template
     */
    replaceVariables(template, values) {
        return template.replace(/\{\{([^}]+)\}\}/g, (match, varName) => {
            const name = varName.trim();
            const value = values[name];
            if (value === undefined || value === null) {
                return '';
            }
            // Format value based on type
            return this.formatValue(value);
        });
    }
    /**
     * Format value for template output
     */
    formatValue(value) {
        if (typeof value === 'string') {
            return value;
        }
        if (typeof value === 'number' || typeof value === 'boolean') {
            return String(value);
        }
        if (Array.isArray(value)) {
            return value.map((v) => this.formatValue(v)).join('\n');
        }
        if (typeof value === 'object') {
            return JSON.stringify(value, null, 2);
        }
        return String(value);
    }
    /**
     * Type checking helper
     */
    isValueOfType(value, type) {
        switch (type) {
            case 'string':
                return typeof value === 'string';
            case 'number':
                return typeof value === 'number';
            case 'boolean':
                return typeof value === 'boolean';
            case 'array':
                return Array.isArray(value);
            case 'object':
                return typeof value === 'object' && !Array.isArray(value) && value !== null;
            default:
                return false;
        }
    }
}
/**
 * Template Builder - Fluent API for constructing templates
 */
export class PromptTemplateBuilder {
    name = '';
    template = '';
    variables = {};
    setName(name) {
        this.name = name;
        return this;
    }
    setTemplate(template) {
        this.template = template;
        return this;
    }
    addVariable(name, type, options = {}) {
        this.variables[name] = {
            name,
            type,
            required: options.required !== false,
            description: options.description,
            default: options.default,
        };
        return this;
    }
    build() {
        if (!this.name) {
            throw new Error('Template name is required');
        }
        if (!this.template) {
            throw new Error('Template string is required');
        }
        return new PromptTemplate({
            name: this.name,
            template: this.template,
            variables: this.variables,
        });
    }
}
/**
 * Pre-built templates for common use cases
 */
export const CommonTemplates = {
    /**
     * Policy evaluation template
     */
    policyEvaluation: new PromptTemplate({
        name: 'policy-evaluation',
        template: `Evaluate the following code changes against the policy:

Policy: {{policy}}

Changes:
{{changes}}

Files Modified:
{{files}}

Identify any violations and explain why they violate the policy.`,
        variables: {
            policy: {
                name: 'policy',
                type: 'string',
                required: true,
                description: 'Policy rules to evaluate against',
            },
            changes: {
                name: 'changes',
                type: 'string',
                required: true,
                description: 'Code changes to evaluate',
            },
            files: {
                name: 'files',
                type: 'array',
                required: true,
                description: 'List of modified files',
            },
        },
    }),
    /**
     * Component specification template
     */
    componentSpec: new PromptTemplate({
        name: 'component-spec',
        template: `Generate a component specification for:

Component Name: {{name}}
Purpose: {{purpose}}
Context: {{context}}

Include: interface, dependencies, error handling, and test scenarios.`,
        variables: {
            name: {
                name: 'name',
                type: 'string',
                required: true,
                description: 'Component name',
            },
            purpose: {
                name: 'purpose',
                type: 'string',
                required: true,
                description: 'Component purpose',
            },
            context: {
                name: 'context',
                type: 'object',
                required: false,
                description: 'Additional context',
                default: {},
            },
        },
    }),
};
//# sourceMappingURL=template.js.map