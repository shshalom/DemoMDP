# MLang Configuration
version: v1

# Policy resolution
resolver:
  # Channel to use for policy resolution (stable, preview, dev)
  channel: stable

  # Registry provider (file-based by default)
  registry:
    type: file
    path: .mlang/packs

  # Last Known Good (LKG) fallback
  lkg:
    enabled: true
    ttl: 86400  # 24 hours in seconds

# State storage
state:
  # DSN for state capsule storage
  # file:// for local filesystem (default, zero config)
  # postgresql:// for PostgreSQL (advanced, enables full AOI lifecycle)
  dsn: file://.mlang/store

  # AOI works with both storage backends:
  # - file://   → Evaluation + detection work, but state doesn't persist across runs
  # - postgresql:// → Full lifecycle tracking (detect → counter-PR → follow-up PR)
  #
  # To enable PostgreSQL for full AOI workflow:
  # 1. Start: docker run -d -p 5432:5432 -e POSTGRES_PASSWORD=postgres -e POSTGRES_DB=mdp_aoi postgres:16
  # 2. Migrate: npx @mdp-framework/mlang aoi migrate --database mdp_aoi --user postgres --password postgres
  # 3. Change DSN to: postgresql://postgres:postgres@localhost:5432/mdp_aoi
  # 4. Add PostgreSQL service to .github/workflows/*.yml (see AOI_SETUP.md)

  # Retention policy
  retention:
    default_ttl: 2592000  # 30 days
    prune_interval: 86400  # daily

# Policy signing
signing:
  # Require signed policies
  require_signatures: false

  # Public keys directory for verification
  keys_dir: .mlang/keys

# Observability
observability:
  # Enable verbose mode
  verbose: false

  # Enable trace mode
  trace: false

  # Event sink (stdout, jsonl, otel)
  sink: stdout

  # Redact sensitive data
  redact: true

# Execution mode
execution:
  # Mode: enforce, report, dry-run
  mode: report

  # Allow enforcement (gating policies)
  allow_enforcement: false

# Role-to-policy mappings
roles:
  pr:
    policies:
      - eng.pr.review
      - eng.pr.description

  feature:
    policies:
      - eng.feature.discovery

  issue:
    policies:
      - eng.issue.debug

# External MCP Server configuration
# IMPORTANT: Set JIRA_API_TOKEN in GitHub repository secrets for CI/CD
mcp:
  # Atlassian MCP Server (Jira + Confluence) - Autodesk Internal
  # Using @adsk/adsk-atlassian-mcp from Autodesk Artifactory
  atlassian:
    command: npx
    args:
      - --registry
      - https://npm.autodesk.com/artifactory/api/npm/autodesk-npm-virtual
      - -y
      - "@adsk/adsk-atlassian-mcp@latest"
      - mcp
      - --jira
    env:
      JIRA_ACCESS_TOKEN: ${JIRA_API_TOKEN}
      WIKI_ACCESS_TOKEN: dummy

  # Get API token from: https://id.atlassian.com/manage-profile/security/api-tokens
  # Note: Same API token works for both Jira and Confluence
  #
  # For local development:
  #   export JIRA_API_TOKEN="your-token-here"
  #
  # For GitHub Actions:
  #   Settings → Secrets → Actions → New repository secret
  #   Name: JIRA_API_TOKEN
  #   Value: your-token-here

  # Slack MCP Server - For AOI notifications
  # Using korotovsky/slack-mcp-server (actively maintained alternative)
  slack:
    command: npx
    args:
      - -y
      - slack-mcp-server@latest
    env:
      # Slack authentication (choose one method)
      # Option 1: Bot Token (recommended for CI/CD)
      SLACK_BOT_TOKEN: ${SLACK_BOT_TOKEN}
      # Option 2: Stealth mode (browser tokens)
      # SLACK_MCP_XOXC_TOKEN: ${SLACK_XOXC_TOKEN}
      # SLACK_MCP_XOXD_TOKEN: ${SLACK_XOXD_TOKEN}

      # Enable message posting (required for AOI notifications)
      SLACK_MCP_ADD_MESSAGE_TOOL: "true"

  # To set up Slack:
  # 1. Create Slack App: https://api.slack.com/apps
  # 2. Add Bot Token Scopes: chat:write, channels:read, channels:history
  # 3. Install app to workspace
  # 4. Copy Bot User OAuth Token (starts with xoxb-)
  # 5. Add secret SLACK_BOT_TOKEN to GitHub repository

# AOI (Architecture of Intent) configuration
aoi:
  jira_project: AOI
  slack_route: aoi-alerts
